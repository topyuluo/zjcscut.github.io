<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>JUC线程池ThreadPoolExecutor源码分析 | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 5px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
  

  
    <article id="post" class="post white-box card-shadow  article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/2019/07/15/java-concurrency-thread-pool-executor/">
        JUC线程池ThreadPoolExecutor源码分析
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Concurrency/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Concurrency</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年7月15日</p>
  </a>
</div>

          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-07-21T23:56:36+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年7月21日</p>
  </a>
</div>

          
        
          
            
  
    <div class="new-meta-item browse busuanzi">
      <a class='notlink'>
        <i class="fas fa-eye" aria-hidden="true"></i>
        <p>
          <span id="busuanzi_value_page_pv">
            <i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i>
          </span>
        </p>
      </a>
    </div>
  


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：12.2k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：48分钟</p>
    </a>
  </div>


          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201907/j-u-c-t-p-e-logo.png" alt=""></p>
<h2 id="前提">前提</h2>
<p>很早之前就打算看一次JUC线程池<code>ThreadPoolExecutor</code>的源码实现，由于近段时间比较忙，一直没有时间整理出源码分析的文章。之前在分析扩展线程池实现可回调的<code>Future</code>时候曾经提到并发大师<code>Doug Lea</code>在设计线程池<code>ThreadPoolExecutor</code>的提交任务的顶层接口<code>Executor</code>只有一个无状态的执行方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>ExecutorService</code>提供了很多扩展方法底层基本上是基于<code>Executor#execute()</code>方法进行扩展。本文着重分析<code>ThreadPoolExecutor#execute()</code>的实现，笔者会从实现原理、源码实现等角度结合简化例子进行详细的分析。<code>ThreadPoolExecutor</code>的源码从JDK8到JDK11基本没有变化，本文编写的时候使用的是JDK11。</p>
<a id="more"></a>
<h2 id="ThreadPoolExecutor的原理">ThreadPoolExecutor的原理</h2>
<p><code>ThreadPoolExecutor</code>里面使用到JUC同步器框架<code>AbstractQueuedSynchronizer</code>（俗称<code>AQS</code>）、大量的位操作、<code>CAS</code>操作。<code>ThreadPoolExecutor</code>提供了固定活跃线程（核心线程）、额外的线程（线程池容量 - 核心线程数这部分额外创建的线程，下面称为非核心线程）、任务队列以及拒绝策略这几个重要的功能。</p>
<h3 id="JUC同步器框架">JUC同步器框架</h3>
<p><code>ThreadPoolExecutor</code>里面使用到JUC同步器框架，主要用于四个方面：</p>
<ul>
<li>全局锁<code>mainLock</code>成员属性，是可重入锁<code>ReentrantLock</code>类型，主要是用于访问工作线程<code>Worker</code>集合和进行数据统计记录时候的加锁操作。</li>
<li>条件变量<code>termination</code>，<code>Condition</code>类型，主要用于线程进行等待终结<code>awaitTermination()</code>方法时的带期限阻塞。</li>
<li>任务队列<code>workQueue</code>，<code>BlockingQueue&lt;Runnable&gt;</code>类型，任务队列，用于存放待执行的任务。</li>
<li>工作线程，内部类<code>Worker</code>类型，是线程池中真正的工作线程对象。</li>
</ul>
<p>关于<code>AQS</code>笔者之前写过一篇相关源码分析的文章：<a href="http://www.throwable.club/2019/04/07/java-juc-aqs-source-code" target="_blank" rel="noopener">JUC同步器框架AbstractQueuedSynchronizer源码图文分析</a>。</p>
<h3 id="核心线程">核心线程</h3>
<p>这里先参考<code>ThreadPoolExecutor</code>的实现并且进行简化，实现一个只有核心线程的线程池，要求如下：</p>
<ul>
<li>暂时不考虑任务执行异常情况下的处理。</li>
<li>任务队列为无界队列。</li>
<li>线程池容量固定为核心线程数量。</li>
<li>暂时不考虑拒绝策略。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoreThreadPool</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coreSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoreThreadPool</span><span class="params">(<span class="keyword">int</span> coreSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++threadCount &lt;= coreSize) &#123;</span><br><span class="line">            <span class="keyword">new</span> Worker(command).start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                workQueue.put(command);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Runnable firstTask;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(String.format(<span class="string">"Worker-%d"</span>, COUNTER.getAndIncrement()));</span><br><span class="line">            <span class="keyword">this</span>.firstTask = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Runnable task = <span class="keyword">this</span>.firstTask;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">null</span> != task || <span class="keyword">null</span> != (task = getTask())) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> workQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CoreThreadPool pool = <span class="keyword">new</span> CoreThreadPool(<span class="number">5</span>);</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                .forEach(i -&gt; pool.execute(() -&gt;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"Thread:%s,value:%d"</span>, Thread.currentThread().getName(), i))));</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某次运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:Worker-<span class="number">0</span>,value:<span class="number">0</span></span><br><span class="line">Thread:Worker-<span class="number">3</span>,value:<span class="number">3</span></span><br><span class="line">Thread:Worker-<span class="number">2</span>,value:<span class="number">2</span></span><br><span class="line">Thread:Worker-<span class="number">1</span>,value:<span class="number">1</span></span><br><span class="line">Thread:Worker-<span class="number">4</span>,value:<span class="number">4</span></span><br><span class="line">Thread:Worker-<span class="number">1</span>,value:<span class="number">5</span></span><br><span class="line">Thread:Worker-<span class="number">2</span>,value:<span class="number">8</span></span><br><span class="line">Thread:Worker-<span class="number">4</span>,value:<span class="number">7</span></span><br><span class="line">Thread:Worker-<span class="number">0</span>,value:<span class="number">6</span></span><br><span class="line">Thread:Worker-<span class="number">3</span>,value:<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>设计此线程池的时候，核心线程是懒创建的，如果线程空闲的时候则阻塞在任务队列的<code>take()</code>方法，其实对于<code>ThreadPoolExecutor</code>也是类似这样实现，只是如果使用了<code>keepAliveTime</code>并且允许核心线程超时（<code>allowCoreThreadTimeOut</code>设置为<code>true</code>）则会使用<code>BlockingQueue#poll(keepAliveTime)</code>进行轮询代替永久阻塞。</p>
<h3 id="其他附加功能">其他附加功能</h3>
<p>构建<code>ThreadPoolExecutor</code>实例的时候，需要定义<code>maximumPoolSize</code>（线程池最大线程数）和<code>corePoolSize</code>（核心线程数）。当任务队列是有界的阻塞队列，核心线程满负载，任务队列已经满的情况下，会尝试创建额外的<code>maximumPoolSize - corePoolSize</code>个线程去执行新提交的任务。当<code>ThreadPoolExecutor</code>这里实现的两个主要附加功能是：</p>
<ul>
<li>一定条件下会创建非核心线程去执行任务，非核心线程的回收周期（线程生命周期终结时刻）是<code>keepAliveTime</code>，线程生命周期终结的条件是：下一次通过任务队列获取任务的时候并且存活时间超过<code>keepAliveTime</code>。</li>
<li>提供拒绝策略，也就是在核心线程满负载、任务队列已满、非核心线程满负载的条件下会触发拒绝策略。</li>
</ul>
<h2 id="源码分析">源码分析</h2>
<p>先分析线程池的关键属性，接着分析其状态控制，最后重点分析<code>ThreadPoolExecutor#execute()</code>方法。</p>
<h3 id="关键属性">关键属性</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制变量-存放状态和线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务队列，必须是阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全局锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// awaitTermination方法使用的等待条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录峰值线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录已经成功执行完毕的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程工厂，用于创建新的线程实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝执行处理器，对应不同的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲线程等待任务的时间周期，单位是纳秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否允许核心线程超时，如果为true则keepAliveTime对核心线程也生效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看参数列表最长的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自定义核心线程数、线程池容量（最大线程数）、空闲线程等待任务周期、任务队列、线程工厂、拒绝策略。下面简单分析一下每个参数的含义和作用：</p>
<ul>
<li><strong><code>corePoolSize</code></strong>：int类型，核心线程数量。</li>
<li><strong><code>maximumPoolSize</code></strong>：int类型，最大线程数量，也就是线程池的容量。</li>
<li><strong><code>keepAliveTime</code></strong>：long类型，线程空闲等待时间，也和工作线程的生命周期有关，下文会分析。</li>
<li><strong><code>unit</code></strong>：<code>TimeUnit</code>类型，<code>keepAliveTime</code>参数的时间单位，实际上<code>keepAliveTime</code>最终会转化为纳秒。</li>
<li><strong><code>workQueue</code></strong>：<code>BlockingQueue&lt;Runnable&gt;</code>类型，等待队列或者叫任务队列。</li>
<li><strong><code>threadFactory</code></strong>：<code>ThreadFactory</code>类型，线程工厂，用于创建工作线程（包括核心线程和非核心线程），默认使用<code>Executors.defaultThreadFactory()</code>作为内建线程工厂实例，一般自定义线程工厂才能更好地跟踪工作线程。</li>
<li><strong><code>handler</code></strong>：<code>RejectedExecutionHandler</code>类型，线程池的拒绝执行处理器，更多时候称为拒绝策略，拒绝策略执行的时机是当阻塞队列已满、没有空闲的线程（包括核心线程和非核心线程）并且继续提交任务。提供了4种内建的拒绝策略实现：
<ul>
<li><code>AbortPolicy</code>：直接拒绝策略，也就是不会执行任务，直接抛出<code>RejectedExecutionException</code>，这是<strong>默认的拒绝策略</strong>。</li>
<li><code>DiscardPolicy</code>：抛弃策略，也就是直接忽略提交的任务（通俗来说就是空实现）。</li>
<li><code>DiscardOldestPolicy</code>：抛弃最老任务策略，也就是通过<code>poll()</code>方法取出任务队列队头的任务抛弃，然后执行当前提交的任务。</li>
<li><code>CallerRunsPolicy</code>：调用者执行策略，也就是当前调用<code>Executor#execute()</code>的线程直接调用任务<code>Runnable#run()</code>，<strong>一般不希望任务丢失会选用这种策略，但从实际角度来看，原来的异步调用意图会退化为同步调用</strong>。</li>
</ul>
</li>
</ul>
<h3 id="状态控制">状态控制</h3>
<p>状态控制主要围绕原子整型成员变量<code>ctl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_MASK = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ctl值获取运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~COUNT_MASK; &#125;</span><br><span class="line"><span class="comment">// 通过ctl值获取工作线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过运行状态和工作线程数计算ctl的值，或运算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS操作线程数增加1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS操作线程数减少1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数直接减少1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ctl.addAndGet(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析一下线程池的状态变量，工作线程上限数量位的长度是<code>COUNT_BITS</code>，它的值是<code>Integer.SIZE - 3</code>，也就是正整数29：</p>
<blockquote>
<p>我们知道，整型包装类型Integer实例的大小是4 byte，一共32 bit，也就是一共有32个位用于存放0或者1。<br>
在ThreadPoolExecutor实现中，使用32位的整型包装类型存放工作线程数和线程池状态。<br>
其中，低29位用于存放工作线程数，而高3位用于存放线程池状态，所以线程池的状态最多只能有2^3种。<br>
工作线程上限数量为2^29 - 1，超过5亿，这个数量在短时间内不用考虑会超限。</p>
</blockquote>
<p>接着看工作线程上限数量掩码<code>COUNT_MASK</code>，它的值是<code>(1 &lt; COUNT_BITS) - l</code>，也就是1左移29位，再减去1，如果补全32位，它的位视图如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201907/j-u-c-t-p-e-1.png" alt="j-u-c-t-p-e-1"></p>
<p>然后就是线程池的状态常量，这里只详细分析其中一个，其他类同，这里看<code>RUNNING</code>状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -1的补码为：111-11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 左移29位后：111-00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 10进制值为：-536870912 </span></span><br><span class="line"><span class="comment">// 高3位111的值就是表示线程池正在处于运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<p>控制变量<code>ctl</code>的组成就是通过线程池运行状态<code>rs</code>和工作线程数<code>wc</code>通过<strong>或运算</strong>得到的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rs=RUNNING值为：111-00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// wc的值为0：000-00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// rs | wc的结果为：111-00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> rs | wc; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们怎么从<code>ctl</code>中取出高3位的线程池状态？上面源码中提供的<code>runStateOf()</code>方法就是提取运行状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先把COUNT_MASK取反(~COUNT_MASK)，得到：111-00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// ctl位图特点是：xxx-yyyyyyyyyyyyyyyyyyyyyyyyyyyyyy</span></span><br><span class="line"><span class="comment">// 两者做一次与运算即可得到高3位xxx</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; ~COUNT_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，取出低29位的工作线程数量只需要把<code>ctl</code>和<code>COUNT_MASK</code>(<code>000-11111111111111111111111111111</code>)做一次<strong>与运算</strong>即可。</p>
<p>工作线程数为0的前提下，小结一下线程池的运行状态常量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态名称</th>
<th style="text-align:center">位图</th>
<th style="text-align:center">十进制值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>RUNNING</code></td>
<td style="text-align:center"><code>111-00000000000000000000000000000</code></td>
<td style="text-align:center">-536870912</td>
<td style="text-align:center">运行中状态，可以接收新的任务和执行任务队列中的任务</td>
</tr>
<tr>
<td style="text-align:center"><code>SHUTDOWN</code></td>
<td style="text-align:center"><code>000-00000000000000000000000000000</code></td>
<td style="text-align:center">0</td>
<td style="text-align:center">shutdown状态，不再接收新的任务，但是会执行任务队列中的任务</td>
</tr>
<tr>
<td style="text-align:center"><code>STOP</code></td>
<td style="text-align:center"><code>001-00000000000000000000000000000</code></td>
<td style="text-align:center">536870912</td>
<td style="text-align:center">停止状态，不再接收新的任务，也不会执行任务队列中的任务，中断所有执行中的任务</td>
</tr>
<tr>
<td style="text-align:center"><code>TIDYING</code></td>
<td style="text-align:center"><code>010-00000000000000000000000000000</code></td>
<td style="text-align:center">1073741824</td>
<td style="text-align:center">整理中状态，所有任务已经终结，工作线程数为0，过渡到此状态的工作线程会调用钩子方法<code>terminated()</code></td>
</tr>
<tr>
<td style="text-align:center"><code>TERMINATED</code></td>
<td style="text-align:center"><code>011-00000000000000000000000000000</code></td>
<td style="text-align:center">1610612736</td>
<td style="text-align:center">终结状态，钩子方法<code>terminated()</code>执行完毕</td>
</tr>
</tbody>
</table>
<p>这里有一个比较特殊的技巧，由于运行状态值存放在高3位，所以可以直接通过十进制值（<strong>甚至可以忽略低29位，直接用<code>ctl</code>进行比较，或者使用<code>ctl</code>和线程池状态常量进行比较</strong>）来比较和判断线程池的状态：</p>
<blockquote>
<p>工作线程数为0的前提下：RUNNING(-536870912) &lt; SHUTDOWN(0) &lt; STOP(536870912) &lt; TIDYING(1073741824) &lt; TERMINATED(1610612736)</p>
</blockquote>
<p>下面这三个方法就是使用这种技巧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctl和状态常量比较，判断是否小于</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl和状态常量比较，判断是否小于或等于</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl和状态常量SHUTDOWN比较，判断是否处于RUNNING状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是线程池状态的跃迁图：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201907/j-u-c-t-p-e-2.png" alt="j-u-c-t-p-e-2"></p>
<blockquote>
<p>PS：线程池源码中有很多中间变量用了简单的单字母表示，例如c就是表示ctl、wc就是表示worker count、rs就是表示running status。</p>
</blockquote>
<h3 id="execute方法源码分析">execute方法源码分析</h3>
<p>线程池异步执行任务的方法实现是<code>ThreadPoolExecutor#execute()</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行命令，其中命令（下面称任务）对象是Runnable的实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断命令（任务）对象非空</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 获取ctl的值</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 判断如果当前工作线程数小于核心线程数，则创建新的核心线程并且执行传入的任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="comment">// 如果创建新的核心线程成功则直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 这里说明创建核心线程失败，需要更新ctl的临时变量c</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明创建新的核心线程失败，也就是当前工作线程数大于等于corePoolSize</span></span><br><span class="line">    <span class="comment">// 判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务（放入任务失败返回false）</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 这里是向任务队列投放任务成功，对线程池的运行中状态做二次检查</span></span><br><span class="line">        <span class="comment">// 如果线程池二次检查状态是非运行中状态，则从任务队列移除当前的任务调用拒绝策略处理之（也就是移除前面成功入队的任务实例）</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 调用拒绝策略处理任务 - 返回</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 走到下面的else if分支，说明有以下的前提：</span></span><br><span class="line">        <span class="comment">// 0、待执行的任务已经成功加入任务队列</span></span><br><span class="line">        <span class="comment">// 1、线程池可能是RUNNING状态</span></span><br><span class="line">        <span class="comment">// 2、传入的任务可能从任务队列中移除失败（移除失败的唯一可能就是任务已经被执行了）</span></span><br><span class="line">        <span class="comment">// 如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null - 返回</span></span><br><span class="line">        <span class="comment">// 也就是创建的非核心线程不会马上运行，而是等待获取任务队列的任务去执行 </span></span><br><span class="line">        <span class="comment">// 如果前工作线程数量不为0，原来应该是最后的else分支，但是可以什么也不做，因为任务已经成功入队列，总会有合适的时机分配其他空闲线程去执行它</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明有以下的前提：</span></span><br><span class="line">    <span class="comment">// 0、线程池中的工作线程总数已经大于等于corePoolSize（简单来说就是核心线程已经全部懒创建完毕）</span></span><br><span class="line">    <span class="comment">// 1、线程池可能不是RUNNING状态</span></span><br><span class="line">    <span class="comment">// 2、线程池可能是RUNNING状态同时任务队列已经满了</span></span><br><span class="line">    <span class="comment">// 如果向任务队列投放任务失败，则会尝试创建非核心线程传入任务执行</span></span><br><span class="line">    <span class="comment">// 创建非核心线程失败，此时需要拒绝执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 调用拒绝策略处理任务 - 返回</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简单分析一下整个流程：</p>
<ol>
<li>如果当前工作线程总数小于<code>corePoolSize</code>，则直接创建核心线程执行任务（任务实例会传入直接用于构造工作线程实例）。</li>
<li>如果当前工作线程总数大于等于<code>corePoolSize</code>，判断线程池是否处于运行中状态，同时尝试用非阻塞方法向任务队列放入任务，这里会二次检查线程池运行状态，如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为null。</li>
<li>如果向任务队列投放任务失败（任务队列已经满了），则会尝试创建非核心线程传入任务实例执行。</li>
<li>如果创建非核心线程失败，此时需要拒绝执行任务，调用拒绝策略处理任务。</li>
</ol>
<p><strong>这里是一个疑惑点</strong>：为什么需要二次检查线程池的运行状态，当前工作线程数量为0，尝试创建一个非核心线程并且传入的任务对象为null？这个可以看API注释：</p>
<blockquote>
<p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结）或者执行当前方法的时候线程池是否已经shutdown了。所以我们需要二次检查线程池的状态，必须时把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程。</p>
</blockquote>
<p>任务提交流程从调用者的角度来看如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201907/j-u-c-t-p-e-3.png" alt="j-u-c-t-p-e-3"></p>
<h3 id="addWorker方法源码分析">addWorker方法源码分析</h3>
<p><code>boolean addWorker(Runnable firstTask, boolean core)</code>方法的第一的参数可以用于直接传入任务实例，第二个参数用于标识将要创建的工作线程是否核心线程。方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加工作线程，如果返回false说明没有新创建工作线程，如果返回true说明创建和启动工作线程成功</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:  </span><br><span class="line">    <span class="comment">// 注意这是一个死循环 - 最外层循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// 这个是十分复杂的条件，这里先拆分多个与（&amp;&amp;）条件：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态至少为SHUTDOWN状态，也就是rs &gt;= SHUTDOWN(0)</span></span><br><span class="line">        <span class="comment">// 2. 线程池状态至少为STOP状态，也就是rs &gt;= STOP(1)，或者传入的任务实例firstTask不为null，或者任务队列为空</span></span><br><span class="line">        <span class="comment">// 其实这个判断的边界是线程池状态为shutdown状态下，不会再接受新的任务，在此前提下如果状态已经到了STOP、或者传入任务不为空、或者任务队列为空（已经没有积压任务）都不需要添加新的线程</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 注意这也是一个死循环 - 二层循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 这里每一轮循环都会重新获取工作线程数wc</span></span><br><span class="line">            <span class="comment">// 1. 如果传入的core为true，表示将要创建核心线程，通过wc和corePoolSize判断，如果wc &gt;= corePoolSize，则返回false表示创建核心线程失败</span></span><br><span class="line">            <span class="comment">// 1. 如果传入的core为false，表示将要创非建核心线程，通过wc和maximumPoolSize判断，如果wc &gt;= maximumPoolSize，则返回false表示创建非核心线程失败</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 成功通过CAS更新工作线程数wc，则break到最外层的循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 走到这里说明了通过CAS更新工作线程数wc失败，这个时候需要重新判断线程池的状态是否由RUNNING已经变为SHUTDOWN</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 如果线程池状态已经由RUNNING已经变为SHUTDOWN，则重新跳出到外层循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 如果线程池状态依然是RUNNING，CAS更新工作线程数wc失败说明有可能是并发更新导致的失败，则在内层循环重试即可 </span></span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 传入任务实例firstTask创建Worker实例，Worker构造里面会通过线程工厂创建新的Thread对象，所以下面可以直接操作Thread t = w.thread</span></span><br><span class="line">        <span class="comment">// 这一步Worker实例已经创建，但是没有加入工作线程集合或者启动它持有的线程Thread实例</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里需要全局加锁，因为会改变一些指标值和非线程安全的集合</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="comment">// 这里主要在加锁的前提下判断ThreadFactory创建的线程是否存活或者判断获取锁成功之后线程池状态是否已经更变为SHUTDOWN</span></span><br><span class="line">                <span class="comment">// 1. 如果线程池状态依然为RUNNING，则只需要判断线程实例是否存活，需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// 2. 如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// 对于2，换言之，如果线程池处于SHUTDOWN状态下，同时传入的任务实例firstTask不为null，则不会添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                <span class="comment">// 这一步其实有可能创建了新的Worker实例但是并不启动（临时对象，没有任何强引用），这种Worker有可能成功下一轮GC被收集的垃圾对象</span></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 把创建的工作线程实例添加到工作线程集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// 尝试更新历史峰值工作线程数，也就是线程池峰值容量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 这里更新工作线程是否启动成功标识为true，后面才会调用Thread#start()方法启动真实的线程实例</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，需要从工作线程集合移除对应的Worker</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Worker失败</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从工作线程集合移除之</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// wc数量减1    </span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 基于状态判断尝试终结线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者发现了<code>Doug Lea</code>大神十分喜欢复杂的条件判断，而且单行复杂判断不喜欢加花括号，像下面这种代码在他编写的很多类库中都比较常见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">    &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">        || firstTask != <span class="keyword">null</span></span><br><span class="line">        || workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">//  代码拆分一下如下 </span></span><br><span class="line">boolean atLeastShutdown = runStateAtLeast(c, SHUTDOWN);     # rs &gt;= SHUTDOWN(0)</span><br><span class="line"><span class="keyword">boolean</span> atLeastStop = runStateAtLeast(c, STOP) || firstTask != <span class="keyword">null</span> || workQueue.isEmpty();     </span><br><span class="line"><span class="keyword">if</span> (atLeastShutdown &amp;&amp; atLeastStop)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的分析逻辑中需要注意一点，<code>Worker</code>实例创建的同时，在其构造函数中会通过<code>ThreadFactory</code>创建一个Java线程<code>Thread</code>实例，后面会加锁后二次检查是否需要把<code>Worker</code>实例添加到工作线程集合<code>workers</code>中和是否需要启动<code>Worker</code>中持有的<code>Thread</code>实例，只有启动了<code>Thread</code>实例实例，<code>Worker</code>才真正开始运作，否则只是一个无用的临时对象。<code>Worker</code>本身也实现了<code>Runnable</code>接口，它可以看成是一个<code>Runnable</code>的适配器。</p>
<h3 id="工作线程内部类Worker源码分析">工作线程内部类Worker源码分析</h3>
<p>线程池中的每一个具体的工作线程被包装为内部类<code>Worker</code>实例，<code>Worker</code>继承于<code>AbstractQueuedSynchronizer(AQS)</code>，实现了<code>Runnable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">        * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存ThreadFactory创建的线程实例，如果ThreadFactory创建线程失败则为null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 保存传入的Runnable任务实例</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 记录每个线程完成的任务总数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一的构造函数，传入任务实例firstTask，注意可以为null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 禁止线程中断，直到runWorker()方法执行</span></span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 通过ThreadFactory创建线程实例，注意一下Worker实例自身作为Runnable用于创建新的线程实例</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托到外部的runWorker()方法，注意runWorker()方法是线程池的方法，而不是Worker的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock methods</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line">    <span class="comment">//  是否持有独占锁，state值为1的时候表示持有锁，state值为0的时候表示已经释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占模式下尝试获取资源，这里没有判断传入的变量，直接CAS判断0更新为1是否成功，成功则设置独占线程为当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占模式下尝试是否资源，这里没有判断传入的变量，直接把state设置为0</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动后进行线程中断，注意这里会判断线程实例的中断标志位是否为false，只有中断标志位为false才会中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Worker</code>的构造函数里面的逻辑十分重要，通过<code>ThreadFactory</code>创建的<code>Thread</code>实例同时传入<code>Worker</code>实例，因为<code>Worker</code>本身实现了<code>Runnable</code>，所以可以作为任务提交到线程中执行。只要<code>Worker</code>持有的线程实例<code>w</code>调用<code>Thread#start()</code>方法就能在合适时机执行<code>Worker#run()</code>。简化一下逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addWorker()方法中构造</span></span><br><span class="line">Worker worker = createWorker();</span><br><span class="line"><span class="comment">// 通过线程池构造时候传入</span></span><br><span class="line">ThreadFactory threadFactory = getThreadFactory();</span><br><span class="line"><span class="comment">// Worker构造函数中</span></span><br><span class="line">Thread thread = threadFactory.newThread(worker);</span><br><span class="line"><span class="comment">// addWorker()方法中启动</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<p><code>Worker</code>继承自<code>AQS</code>，这里使用了<code>AQS</code>的独占模式，有个技巧是构造<code>Worker</code>的时候，把<code>AQS</code>的资源（状态）通过<code>setState(-1)</code>设置为-1，这是因为<code>Worker</code>实例刚创建时<code>AQS</code>中<code>state</code>的默认值为0，此时线程尚未启动，不能在这个时候进行线程中断，见<code>Worker#interruptIfStarted()</code>方法。<code>Worker</code>中两个覆盖<code>AQS</code>的方法<code>tryAcquire()</code>和<code>tryRelease()</code>都没有判断外部传入的变量，前者直接<code>CAS(0,1)</code>，后者直接<code>setState(0)</code>。接着看核心方法<code>ThreadPoolExecutor#runWorker()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程，实际上和Worker持有的线程实例是相同的</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取Worker中持有的初始化时传入的任务对象，这里注意存放在临时变量task中</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">// 设置Worker中持有的初始化时传入的任务对象为null</span></span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 由于Worker初始化时AQS中state设置为-1，这里要先做一次解锁把state更新为0，允许线程中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 记录线程是否因为用户异常终结，默认是true</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化任务对象不为null，或者从任务队列获取任务不为空（从任务队列获取到的任务会更新到临时变量task中）</span></span><br><span class="line">        <span class="comment">// getTask()由于使用了阻塞队列，这个while循环如果命中后半段会处于阻塞或者超时阻塞状态，getTask()返回为null会导致线程跳出死循环使线程终结</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Worker加锁，本质是AQS获取资源并且尝试CAS更新state由0更变为1</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止（也就是由RUNNING或者SHUTDOWN状态向STOP状态变更），那么要确保当前工作线程是中断状态</span></span><br><span class="line">            <span class="comment">// 否则，要保证当前线程不是中断状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                    runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 钩子方法，任务执行前</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="comment">// 钩子方法，任务执行后 - 正常情况</span></span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法，任务执行后 - 异常情况</span></span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 清空task临时变量，这个很重要，否则while会死循环执行同一个task</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 累加Worker完成的任务数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// Worker解锁，本质是AQS释放资源，设置state为0</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里说明某一次getTask()返回为null，线程正常退出</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 处理线程退出，completedAbruptly为true说明由于用户异常导致线程非正常退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点拆解分析一下判断当前工作线程中断状态的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">        (Thread.interrupted() &amp;&amp;</span><br><span class="line">        runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">    !wt.isInterrupted())</span><br><span class="line">    wt.interrupt();</span><br><span class="line"><span class="comment">// 先简化一下判断逻辑，如下</span></span><br><span class="line"><span class="comment">// 判断线程池状态是否至少为STOP，rs &gt;= STOP(1)</span></span><br><span class="line"><span class="keyword">boolean</span> atLeastStop = runStateAtLeast(ctl.get(), STOP);</span><br><span class="line"><span class="comment">// 判断线程池状态是否至少为STOP，同时判断当前线程的中断状态并且清空当前线程的中断状态</span></span><br><span class="line"><span class="keyword">boolean</span> interruptedAndAtLeastStop = Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP);</span><br><span class="line"><span class="keyword">if</span> (atLeastStop || interruptedAndAtLeastStop &amp;&amp; !wt.isInterrupted())&#123;</span><br><span class="line">    wt.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Thread.interrupted()</code>方法获取线程的中断状态同时会清空该中断状态，这里之所以会调用这个方法是因为在执行上面这个<code>if</code>逻辑同时外部有可能调用<code>shutdownNow()</code>方法，<code>shutdownNow()</code>方法中也存在中断所有<code>Worker</code>线程的逻辑，但是由于<code>shutdownNow()</code>方法中会遍历所有<code>Worker</code>做线程中断，有可能无法及时在任务提交到<code>Worker</code>执行之前进行中断，所以这个中断逻辑会在<code>Worker</code>内部执行，就是<code>if</code>代码块的逻辑。这里还要注意的是：<code>STOP</code>状态下会拒绝所有新提交的任务，不会再执行任务队列中的任务，同时会中断所有<code>Worker</code>线程。也就是，<strong>即使任务Runnable已经<code>runWorker()</code>中前半段逻辑取出，只要还没走到调用其Runnable#run()，都有可能被中断</strong>。假设刚好发生了进入<code>if</code>代码块的逻辑同时外部调用了<code>shutdownNow()</code>方法，那么<code>if</code>逻辑内会判断线程中断状态并且重置，那么<code>shutdownNow()</code>方法中调用的<code>interruptWorkers()</code>就不会因为中断状态判断出现问题导致二次中断线程（会导致异常）。</p>
<p>小结一下上面<code>runWorker()</code>方法的核心流程：</p>
<ol>
<li><code>Worker</code>先执行一次解锁操作，用于解除不可中断状态。</li>
<li>通过<code>while</code>循环调用<code>getTask()</code>方法从任务队列中获取任务（当然，首轮循环也有可能是外部传入的firstTask任务实例）。</li>
<li>如果线程池更变为<code>STOP</code>状态，则需要确保工作线程是中断状态并且进行中断处理，否则要保证工作线程必须不是中断状态。</li>
<li>执行任务实例<code>Runnale#run()</code>方法，任务实例执行之前和之后（包括正常执行完毕和异常执行情况）分别会调用钩子方法<code>beforeExecute()</code>和<code>afterExecute()</code>。</li>
<li><code>while</code>循环跳出意味着<code>runWorker()</code>方法结束和工作线程生命周期结束（<code>Worker#run()</code>生命周期完结），会调用<code>processWorkerExit()</code>处理工作线程退出的后续工作。</li>
</ol>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201907/j-u-c-t-p-e-4.png" alt="j-u-c-t-p-e-4"></p>
<p>接下来分析一下从任务队列中获取任务的<code>getTask()</code>方法和处理线程退出的后续工作的<code>processWorkerExit()</code>方法。</p>
<h3 id="getTask方法源码分析">getTask方法源码分析</h3>
<p><code>getTask()</code>方法是工作线程在<code>while</code>死循环中获取任务队列中的任务对象的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录上一次从队列中拉取的时候是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="comment">// 注意这是死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">// 第一个if：如果线程池状态至少为SHUTDOWN，也就是rs &gt;= SHUTDOWN(0)，则需要判断两种情况（或逻辑）：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态至少为STOP(1)，也就是线程池正在停止，一般是调用了shutdownNow()方法</span></span><br><span class="line">        <span class="comment">// 2. 任务队列为空</span></span><br><span class="line">        <span class="comment">// 如果在线程池至少为SHUTDOWN状态并且满足上面两个条件之一，则工作线程数wc减去1，然后直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跑到这里说明线程池还处于RUNNING状态，重新获取一次工作线程数</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// timed临时变量勇于线程超时控制，决定是否需要通过poll()此带超时的非阻塞方法进行任务队列的任务拉取</span></span><br><span class="line">        <span class="comment">// 1.allowCoreThreadTimeOut默认值为false，如果设置为true，则允许核心线程也能通过poll()方法从任务队列中拉取任务</span></span><br><span class="line">        <span class="comment">// 2.工作线程数大于核心线程数的时候，说明线程池中创建了额外的非核心线程，这些非核心线程一定是通过poll()方法从任务队列中拉取任务</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">// 第二个if：</span></span><br><span class="line">        <span class="comment">// 1.wc &gt; maximumPoolSize说明当前的工作线程总数大于maximumPoolSize，说明了通过setMaximumPoolSize()方法减少了线程池容量</span></span><br><span class="line">        <span class="comment">// 或者 2.timed &amp;&amp; timedOut说明了线程命中了超时控制并且上一轮循环通过poll()方法从任务队列中拉取任务为null</span></span><br><span class="line">        <span class="comment">// 并且 3. 工作线程总数大于1或者任务队列为空，则通过CAS把线程数减去1，同时返回null，</span></span><br><span class="line">        <span class="comment">// CAS把线程数减去1失败会进入下一轮循环做重试</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果timed为true，通过poll()方法做超时拉取，keepAliveTime时间内没有等待到有效的任务，则返回null</span></span><br><span class="line">            <span class="comment">// 如果timed为false，通过take()做阻塞拉取，会阻塞到有下一个有效的任务时候再返回（一般不会是null）</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="comment">// 这里很重要，只有非null时候才返回，null的情况下会进入下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 跑到这里说明上一次从任务队列中获取到的任务为null，一般是workQueue.poll()方法超时返回null</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中，有两处十分庞大的<code>if</code>逻辑，对于第一处<code>if</code>可能导致工作线程数减去1直接返回<code>null</code>的场景有：</p>
<ol>
<li>线程池状态为<code>SHUTDOWN</code>，一般是调用了<code>shutdown()</code>方法，并且任务队列为空。</li>
<li>线程池状态为<code>STOP</code>。</li>
</ol>
<p>对于第二处<code>if</code>，逻辑有点复杂，先拆解一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程总数大于maximumPoolSize，说明了通过setMaximumPoolSize()方法减少了线程池容量</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = wc &gt; maximumPoolSize;</span><br><span class="line"><span class="comment">// 允许线程超时同时上一轮通过poll()方法从任务队列中拉取任务为null</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = timed &amp;&amp; timedOut;</span><br><span class="line"><span class="comment">// 工作线程总数大于1</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = wc &gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 任务队列为空</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = workQueue.isEmpty();</span><br><span class="line"><span class="keyword">boolean</span> r = (b1 || b2) &amp;&amp; (b3 || b4);</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑大多数情况下是针对非核心线程。在<code>execute()</code>方法中，当线程池总数已经超过了<code>corePoolSize</code>并且还小于<code>maximumPoolSize</code>时，当任务队列已经满了的时候，会通过<code>addWorker(task,false)</code>添加非核心线程。而这里的逻辑恰好类似于<code>addWorker(task,false)</code>的反向操作，用于减少非核心线程，使得工作线程总数趋向于<code>corePoolSize</code>。如果对于非核心线程，上一轮循环获取任务对象为<code>null</code>，这一轮循环很容易满足<code>timed &amp;&amp; timedOut</code>为true，这个时候<code>getTask()</code>返回null会导致<code>Worker#runWorker()</code>方法跳出死循环，之后执行<code>processWorkerExit()</code>方法处理后续工作，而该非核心线程对应的<code>Worker</code>则变成“游离对象”，等待被JVM回收。当<code>allowCoreThreadTimeOut</code>设置为true的时候，这里分析的非核心线程的生命周期终结逻辑同时会适用于核心线程。那么可以总结出<code>keepAliveTime</code>的意义：</p>
<ul>
<li>当允许核心线程超时，也就是<code>allowCoreThreadTimeOut</code>设置为true的时候，此时<code>keepAliveTime</code>表示空闲的工作线程的存活周期。</li>
<li>默认情况下不允许核心线程超时，此时<code>keepAliveTime</code>表示空闲的非核心线程的存活周期。</li>
</ul>
<p>在一些特定的场景下，配置合理的<code>keepAliveTime</code>能够更好地利用线程池的工作线程资源。</p>
<h3 id="processWorkerExit方法源码分析">processWorkerExit方法源码分析</h3>
<p><code>processWorkerExit()</code>方法是为将要终结的<code>Worker</code>做一次清理和数据记录工作（因为<code>processWorkerExit()</code>方法也包裹在<code>runWorker()</code>方法<code>finally</code>代码块中，其实工作线程在执行完<code>processWorkerExit()</code>方法才算真正的终结）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 因为抛出用户异常导致线程终结，直接使工作线程数减1即可</span></span><br><span class="line">    <span class="comment">// 如果没有任何异常抛出的情况下是通过getTask()返回null引导线程正常跳出runWorker()方法的while死循环从而正常终结，这种情况下，在getTask()中已经把线程数减1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 全局的已完成任务记录数加上此将要终结的Worker中的已完成任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 工作线程集合中移除此将要终结的Worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 见下一小节分析，用于根据当前线程池的状态判断是否需要进行线程池terminate处理</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果线程池的状态小于STOP，也就是处于RUNNING或者SHUTDOWN状态的前提下：</span></span><br><span class="line">    <span class="comment">// 1.如果线程不是由于抛出用户异常终结，如果允许核心线程超时，则保持线程池中至少存在一个工作线程</span></span><br><span class="line">    <span class="comment">// 2.如果线程由于抛出用户异常终结，或者当前工作线程数，那么直接添加一个新的非核心线程</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">// 如果允许核心线程超时，最小值为0，否则为corePoolSize</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果最小值为0，同时任务队列不空，则更新最小值为1</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 工作线程数大于等于最小值，直接返回不新增非核心线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的后面部分区域，会判断线程池的状态，如果线程池是<code>RUNNING</code>或者<code>SHUTDOWN</code>状态的前提下，如果当前的工作线程由于抛出用户异常被终结，那么会新创建一个非核心线程。如果当前的工作线程并不是抛出用户异常被终结（正常情况下的终结），那么会这样处理：</p>
<ul>
<li><code>allowCoreThreadTimeOut</code>为true，也就是允许核心线程超时的前提下，如果任务队列空，则会通过创建一个非核心线程保持线程池中至少有一个工作线程。</li>
<li><code>allowCoreThreadTimeOut</code>为false，如果工作线程总数大于<code>corePoolSize</code>则直接返回，否则创建一个非核心线程，也就是会趋向于保持线程池中的工作线程数量趋向于<code>corePoolSize</code>。</li>
</ul>
<p><code>processWorkerExit()</code>执行完毕之后，意味着该工作线程的生命周期已经完结。</p>
<h3 id="tryTerminate方法源码分析">tryTerminate方法源码分析</h3>
<p>每个工作线程终结的时候都会调用<code>tryTerminate()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 判断线程池的状态，如果是下面三种情况下的任意一种则直接返回：</span></span><br><span class="line">        <span class="comment">// 1.线程池处于RUNNING状态</span></span><br><span class="line">        <span class="comment">// 2.线程池至少为TIDYING状态，也就是TIDYING或者TERMINATED状态，意味着已经走到了下面的步骤，线程池即将终结</span></span><br><span class="line">        <span class="comment">// 3.线程池至少为STOP状态并且任务队列不为空</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 工作线程数不为0，则中断工作线程集合中的第一个空闲的工作线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// CAS设置线程池状态为TIDYING，如果设置成功则执行钩子方法terminated()</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 最后更新线程池状态为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 唤醒阻塞在termination条件的所有线程，这个变量的await()方法在awaitTermination()中调用</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断空闲的工作线程，onlyOne为true的时候，只会中断工作线程集合中的某一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 这里判断线程不是中断状态并且尝试获取锁成功的时候才进行线程中断</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里跳出循环，也就是只中断集合中第一个工作线程</span></span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有疑惑的地方是<code>tryTerminate()</code>方法的第二个<code>if</code>代码逻辑：工作线程数不为0，则中断工作线程集合中的第一个空闲的工作线程。方法API注释中有这样一段话：</p>
<blockquote>
<p>If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate.<br>
当满足终结线程池的条件但是工作线程数不为0，这个时候需要中断一个空闲的工作线程去确保线程池关闭的信号得以传播。</p>
</blockquote>
<p>下面将会分析的<code>shutdown()</code>方法中会通过<code>interruptIdleWorkers()</code>中断所有的空闲线程，这个时候有可能有非空闲的线程在执行某个任务，执行任务完毕之后，如果它刚好是核心线程，就会在下一轮循环阻塞在任务队列的<code>take()</code>方法，如果不做额外的干预，它甚至会在线程池关闭之后永久阻塞在任务队列的<code>take()</code>方法中。为了避免这种情况，每个工作线程退出的时候都会尝试中断工作线程集合中的某一个空闲的线程，确保所有空闲的线程都能够正常退出。</p>
<p><code>interruptIdleWorkers()</code>方法中会对每一个工作线程先进行<code>tryLock()</code>判断，只有返回<code>true</code>才有可能进行线程中断。我们知道<code>runWorker()</code>方法中，工作线程在每次从任务队列中获取到非null的任务之后，会先进行加锁<code>Worker#lock()</code>操作，这样就能避免线程在执行任务的过程中被中断，保证被中断的一定是空闲的工作线程。</p>
<h3 id="shutdown方法源码分析">shutdown方法源码分析</h3>
<p>线程池关闭操作有几个相关的变体方法，先看<code>shutdown()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 权限校验，安全策略相关判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置SHUTDOWN状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断所有的空闲的工作线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// 钩子方法</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用上面分析果敢的尝试terminate方法，使状态更变为TIDYING，执行钩子方法terminated()后，最终状态更新为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升提状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert targetState == SHUTDOWN || targetState == STOP;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池状态至少为targetState或者CAS设置状态为targetState则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, targetState) ||</span><br><span class="line">            ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断所有的空闲的工作线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看<code>shutdownNow()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 权限校验，安全策略相关判断</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 设置STOP状态</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有的空闲的工作线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">// 清空工作队列并且取出所有的未执行的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 调用上面分析果敢的尝试terminate方法，使状态更变为TIDYING，执行钩子方法terminated()后，最终状态更新为TERMINATED</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shutdownNow()</code>方法会把线程池状态先更变为<code>STOP</code>，然后遍历任务队列，取出（移除）所有任务存放在一个列表中返回。</p>
<p>最后看<code>awaitTermination()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 转换timeout的单位为纳秒</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环等待直到线程池状态更变为TERMINATED，每轮循环等待nanos纳秒</span></span><br><span class="line">        <span class="keyword">while</span> (runStateLessThan(ctl.get(), TERMINATED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>awaitTermination()</code>虽然不是<code>shutdown()</code>方法体系，但是它的处理逻辑就是确保调用此方法的线程会阻塞到<code>tryTerminate()</code>方法成功把线程池状态更新为<code>TERMINATED</code>后再返回，可以使用在某些需要感知线程池终结时刻的场景。</p>
<p>有一点值得关注的是：<code>shutdown()</code>或者<code>shutdownNow()</code>方法<strong>只会中断空闲的工作线程</strong>，如果工作线程正在执行任务对象<code>Runnable#run()</code>，这种情况下的工作线程不会中断，而是等待下一轮执行<code>getTask()</code>方法的时候通过线程池状态判断正常终结该工作线程。</p>
<h3 id="reject方法源码分析">reject方法源码分析</h3>
<p><code>reject(Runnable command)</code>方法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用线程池持有的成员<code>RejectedExecutionHandler</code>实例回调任务实例和当前线程池实例。</p>
<h3 id="钩子方法分析">钩子方法分析</h3>
<p>到JDK11为止，<code>ThreadPoolExecutor</code>提供的钩子方法没有增加，有以下几个：</p>
<ul>
<li><code>beforeExecute(Thread t, Runnable r)</code>：任务对象<code>Runnable#run()</code>执行之前触发回调。</li>
<li><code>afterExecute(Runnable r, Throwable t)</code>：任务对象<code>Runnable#run()</code>执行之后（包括异常完成情况和正常完成情况）触发回调。</li>
<li><code>terminated()</code>：线程池关闭的时候，状态更变为<code>TIDYING</code>成功之后会回调此方法，执行此方法完毕后，线程池状态会更新为<code>TERMINATED</code>。</li>
<li><code>onShutdown()</code>：<code>shutdown()</code>方法执行时候会回调此方法，API注释中提到此方法主要提供给<code>ScheduledThreadPoolExecutor</code>使用。</li>
</ul>
<p>其中<code>onShutdown()</code>的方法修饰符为<code>default</code>，其他三个方法的修饰符为<code>protected</code>，必要时候可以自行扩展这些方法，可以实现监控、基于特定时机触发具体操作等等。</p>
<h3 id="其他方法">其他方法</h3>
<p>线程池本身提供了大量数据统计相关的方法、扩容方法、预创建方法等等，这些方法的源码并不复杂，这里不做展开分析。</p>
<p><strong>核心线程相关：</strong></p>
<ul>
<li><code>getCorePoolSize()</code>：获取核心线程数。</li>
<li><code>setCorePoolSize()</code>：重新设置线程池的核心线程数。</li>
<li><code>prestartCoreThread()</code>：预启动一个核心线程，当且仅当工作线程数量小于核心线程数量。</li>
<li><code>prestartAllCoreThreads()</code>：预启动所有核心线程。</li>
</ul>
<p><strong>线程池容量相关：</strong></p>
<ul>
<li><code>getMaximumPoolSize()</code>：获取线程池容量。</li>
<li><code>setMaximumPoolSize()</code>：重新设置线程池的最大容量。</li>
</ul>
<p><strong>线程存活周期相关：</strong></p>
<ul>
<li><code>setKeepAliveTime()</code>：设置空闲工作线程的存活周期。</li>
<li><code>getKeepAliveTime()</code>：获取空闲工作线程的存活周期。</li>
</ul>
<p><strong>其他监控统计相关方法：</strong></p>
<ul>
<li><code>getTaskCount()</code>：获取所有已经被执行的任务总数的近似值。</li>
<li><code>getCompletedTaskCount()</code>：获取所有已经执行完成的任务总数的近似值。</li>
<li><code>getLargestPoolSize()</code>：获取线程池的峰值线程数（最大池容量）。</li>
<li><code>getActiveCount()</code>：获取所有活跃线程总数（正在执行任务的工作线程）的近似值。</li>
<li><code>getPoolSize()</code>：获取工作线程集合的容量（当前线程池中的总工作线程数）。</li>
</ul>
<p><strong>任务队列操作相关方法：</strong></p>
<ul>
<li><code>purge()</code>：移除任务队列中所有是<code>Future</code>类型并且已经处于<code>Cancelled</code>状态的任务。</li>
<li><code>remove()</code>：从任务队列中移除指定的任务。</li>
<li><code>BlockingQueue&lt;Runnable&gt; getQueue()</code>：获取任务队列的引用。</li>
</ul>
<h2 id="小结">小结</h2>
<p>本文花大量功夫基于每一行代码分析JUC线程池<code>ThreadPoolExecutor</code>的核心方法<code>execute()</code>的实现，这个方法是整个线程池相关体系的基石，有了它才能扩展出带回调的异步执行和基于时间进行任务调度的功能，后面将会编写两篇文章分别详细分析线程池扩展服务<code>ExecutorService</code>的功能源码实现以及调度线程池<code>ScheduledThreadPoolExecutor</code>的源码实现，预计要耗时2-3周。</p>
<p>（本文完 e-a-20190715 c-7-d 最近项目比较紧，没办法及时更新）</p>

          
            <br>
            
              
                
              
                
              
                
              
                
              
                
              
                
                  <section class='widget card-shadow  copyright'>
  <div class='content'>
    
      <blockquote>
        
          
            <p>作者：<a href="http://www.throwable.club" target="_blank" rel="noopener">Throwable</a></p>

          
        
          
            <p>版权：博客内容遵循<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a>，转载请在文章明显位置注明作者及出处</p>

          
        
          
            <p>本文永久链接是：<a href=http://throwable.club/2019/07/15/java-concurrency-thread-pool-executor/>http://throwable.club/2019/07/15/java-concurrency-thread-pool-executor/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

                
              
                
              
                
              
                
              
                
              
            
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  <section class='widget card-shadow  text'>
  <header>
  <div>
    
      <i class=" fa-fw" aria-hidden="true"></i><span class='name'>打赏</span>
    

  </div>
  
</header>

  <div class='content'>
    
      <p>
        <iframe src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/simple-mine/index.html" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;"  frameborder="0" scrolling="no"></iframe>
      </p>
    
  </div>
</section>

                
              
                
              
                
              
                
              
            
          
        </div>
        
          <br>
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>Java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/ThreadPoolExecutor/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>ThreadPoolExecutor</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=http://throwable.club/2019/07/15/java-concurrency-thread-pool-executor/&title=JUC线程池ThreadPoolExecutor源码分析 | Throwable's Blog&pics=https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg&summary=
前提
很早之前就打算看一次JUC线程池ThreadPoolExecutor的源码实现，由于近段时间比较忙，一直没有时间整理出源码分析的文章。之前在分析扩展线程池实现可回调的Future时候曾经提到并发大师Doug Lea在设计线程池ThreadPoolExecutor的提交任务的顶层接口Executor只有一个无状态的执行方法：
1234public interface Executor &#123;    void execute(Runnable command);&#125;
而ExecutorService提供了很多扩展方法底层基本上是基于Executor#execute()方法进行扩展。本文着重分析ThreadPoolExecutor#execute()的实现，笔者会从实现原理、源码实现等角度结合简化例子进行详细的分析。ThreadPoolExecutor的源码从JDK8到JDK11基本没有变化，本文编写的时候使用的是JDK11。"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://throwable.club/2019/07/15/java-concurrency-thread-pool-executor/&title=JUC线程池ThreadPoolExecutor源码分析 | Throwable's Blog&pics=https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg&summary=
前提
很早之前就打算看一次JUC线程池ThreadPoolExecutor的源码实现，由于近段时间比较忙，一直没有时间整理出源码分析的文章。之前在分析扩展线程池实现可回调的Future时候曾经提到并发大师Doug Lea在设计线程池ThreadPoolExecutor的提交任务的顶层接口Executor只有一个无状态的执行方法：
1234public interface Executor &#123;    void execute(Runnable command);&#125;
而ExecutorService提供了很多扩展方法底层基本上是基于Executor#execute()方法进行扩展。本文着重分析ThreadPoolExecutor#execute()的实现，笔者会从实现原理、源码实现等角度结合简化例子进行详细的分析。ThreadPoolExecutor的源码从JDK8到JDK11基本没有变化，本文编写的时候使用的是JDK11。"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class='qrcode' rel="external nofollow noopener noreferrer" href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACt0lEQVR42u3aQW4jMQwEQP//09kHJLa7ScnJAjUnH2INSwYkhuTjET9fT57vf5Ov1r4lX79+8PDw8A6F/n3pBPY6oGTlzbd+2AI8PDy8a7zXx/frQ/np0k/WeQ3IedGVg4eHh/fHeHli3R7rrzcFDw8P7//irRLcUQ1hs914eHh493jtMb3Zgryw+9FaCx4eHt7Rs3pPPfv5Sn8PDw8Pb91Vb5teZw/9A9Hi4eHhXeDlB+5smCAZI0gaY5s48fDw8M7y9sXZltEWavN3/fAZDw8P74O8dlAgT3DbcavkXUUFBQ8PD2/Ny0sJ+dJt8p3Hk28uHh4e3j1e3uBvD+U2Qc+LGkUzDA8PD+8Cb1ZgPdswyy+YfJ03VWo8PDy8BW9z4LbN/s1A1azMgYeHh/cZXjsWkBR8Z+3/WSRPRwfw8PDwDvFuhDIruSYXw/CKwsPDw7vAy0u9SXDtsb5/V7tZeHh4eGd5s3S5HQhIGm+ztlz9W+Hh4eGVvLZtnzelkqBn21og8fDw8C7wZv/S5xfDbAShLUYkW4CHh4d3ipf/89/m5klJt/0d6kEEPDw8vAu8Tas+D73duNn1UCTTeHh4eGteElbb6JqVJ/KNwMPDw/td3qYEkIeyuQbywjEeHh7eZ3hn0+u29NBeIe0IAh4eHt4NXt7an6XjedCb7XhsvoCHh4c34rUHfXJt5OMFs4JFcdfh4eHhXeC15Yk2iAS2f95Mk+Hh4eGteV/lk7e7bsDywa9opgwPDw9vxNssnRdt85GC2edj9wkeHh5e2U/PB6eStDsfEZi1xIphAjw8PLxrvP1r2qO/TcSP1Vrw8PDwPs6bFXbza6AdZn3zLjw8PLw/wMvT2TxNnw1pRdcJHh4e3jVe2/TKG0558fdKYwwPDw/vbs+9Lq3mwwGb1PnwoAAeHh7enPcPtz01yolQXOsAAAAASUVORK5CYII='>
        
          <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/wechat.png">
        
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=http://throwable.club/2019/07/15/java-concurrency-thread-pool-executor/&title=JUC线程池ThreadPoolExecutor源码分析 | Throwable's Blog&pics=https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg&summary=
前提
很早之前就打算看一次JUC线程池ThreadPoolExecutor的源码实现，由于近段时间比较忙，一直没有时间整理出源码分析的文章。之前在分析扩展线程池实现可回调的Future时候曾经提到并发大师Doug Lea在设计线程池ThreadPoolExecutor的提交任务的顶层接口Executor只有一个无状态的执行方法：
1234public interface Executor &#123;    void execute(Runnable command);&#125;
而ExecutorService提供了很多扩展方法底层基本上是基于Executor#execute()方法进行扩展。本文着重分析ThreadPoolExecutor#execute()的实现，笔者会从实现原理、源码实现等角度结合简化例子进行详细的分析。ThreadPoolExecutor的源码从JDK8到JDK11基本没有变化，本文编写的时候使用的是JDK11。"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
      
        <a class='qrcode' rel="external nofollow noopener noreferrer" href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACt0lEQVR42u3aQW4jMQwEQP//09kHJLa7ScnJAjUnH2INSwYkhuTjET9fT57vf5Ov1r4lX79+8PDw8A6F/n3pBPY6oGTlzbd+2AI8PDy8a7zXx/frQ/np0k/WeQ3IedGVg4eHh/fHeHli3R7rrzcFDw8P7//irRLcUQ1hs914eHh493jtMb3Zgryw+9FaCx4eHt7Rs3pPPfv5Sn8PDw8Pb91Vb5teZw/9A9Hi4eHhXeDlB+5smCAZI0gaY5s48fDw8M7y9sXZltEWavN3/fAZDw8P74O8dlAgT3DbcavkXUUFBQ8PD2/Ny0sJ+dJt8p3Hk28uHh4e3j1e3uBvD+U2Qc+LGkUzDA8PD+8Cb1ZgPdswyy+YfJ03VWo8PDy8BW9z4LbN/s1A1azMgYeHh/cZXjsWkBR8Z+3/WSRPRwfw8PDwDvFuhDIruSYXw/CKwsPDw7vAy0u9SXDtsb5/V7tZeHh4eGd5s3S5HQhIGm+ztlz9W+Hh4eGVvLZtnzelkqBn21og8fDw8C7wZv/S5xfDbAShLUYkW4CHh4d3ipf/89/m5klJt/0d6kEEPDw8vAu8Tas+D73duNn1UCTTeHh4eGteElbb6JqVJ/KNwMPDw/td3qYEkIeyuQbywjEeHh7eZ3hn0+u29NBeIe0IAh4eHt4NXt7an6XjedCb7XhsvoCHh4c34rUHfXJt5OMFs4JFcdfh4eHhXeC15Yk2iAS2f95Mk+Hh4eGteV/lk7e7bsDywa9opgwPDw9vxNssnRdt85GC2edj9wkeHh5e2U/PB6eStDsfEZi1xIphAjw8PLxrvP1r2qO/TcSP1Vrw8PDwPs6bFXbza6AdZn3zLjw8PLw/wMvT2TxNnw1pRdcJHh4e3jVe2/TKG0558fdKYwwPDw/vbs+9Lq3mwwGb1PnwoAAeHh7enPcPtz01yolQXOsAAAAASUVORK5CYII='>
        
          <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qrcode.png">
        
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


        
        
            <div class="prev-next">
                
                    <section class="prev">
                        <span class="art-item-left">
                            <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                            <h4>
                                <a href="/2019/07/27/java-concurrency-executor-service/" rel="prev" title="JUC线程池服务ExecutorService接口实现源码分析">
                                  
                                      JUC线程池服务ExecutorService接口实现源码分析
                                  
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/blog/tags/Java/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Java</a> <a class="tag" href="/blog/tags/ExecutorService/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> ExecutorService</a>
                                </h6>
                            
                        </span>
                    </section>
                
                
                    <section class="next">
                        <span class="art-item-right" aria-hidden="true">
                            <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                            <h4>
                                <a href="/2019/07/02/java-concurrency-listenable-future/" rel="prev" title="JUC线程池扩展可回调的Future">
                                    
                                        JUC线程池扩展可回调的Future
                                    
                                </a>
                            </h4>
                            
                                
                                <h6 class="tags">
                                    <a class="tag" href="/blog/tags/Java/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Java</a> <a class="tag" href="/blog/tags/ListenableFuture/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> ListenableFuture</a>
                                </h6>
                            
                        </span>
                    </section>
                
            </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments card-shadow ">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
      
      
        <section id="comments">
          <div id="valine_container" class="valine_thread">
            <i class="fas fa-spinner fa-spin fa-fw"></i>
          </div>
        </section>
      
    </section>
  </article>


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'JUC线程池ThreadPoolExecutor源码分析',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
        
      
        
          
  <section class='widget card-shadow  toc-wrapper'>
    <header>
  <div>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    

  </div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前提"><span class="toc-text">前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor的原理"><span class="toc-text">ThreadPoolExecutor的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JUC同步器框架"><span class="toc-text">JUC同步器框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心线程"><span class="toc-text">核心线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他附加功能"><span class="toc-text">其他附加功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关键属性"><span class="toc-text">关键属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态控制"><span class="toc-text">状态控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute方法源码分析"><span class="toc-text">execute方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWorker方法源码分析"><span class="toc-text">addWorker方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工作线程内部类Worker源码分析"><span class="toc-text">工作线程内部类Worker源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTask方法源码分析"><span class="toc-text">getTask方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processWorkerExit方法源码分析"><span class="toc-text">processWorkerExit方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryTerminate方法源码分析"><span class="toc-text">tryTerminate方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown方法源码分析"><span class="toc-text">shutdown方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reject方法源码分析"><span class="toc-text">reject方法源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#钩子方法分析"><span class="toc-text">钩子方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他方法"><span class="toc-text">其他方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>












  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  
    
      
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0.6/js/volantis.min.js"></script>

    
  
  <script>
  var GUEST_INFO = ['nick','mail','link'];
  var guest_info = 'nick,mail,link'.split(',').filter(function(item){
    return GUEST_INFO.indexOf(item) > -1
  });
  var notify = 'true' == true;
  var verify = 'true' == true;
  var valine = new Valine();
  valine.init({
    el: '#valine_container',
    notify: notify,
    verify: verify,
    guest_info: guest_info,
    
    appId: "2rSnXSt7hr4528jSF4ifr2lJ-gzGzoHsz",
    appKey: "n5fe705fSsz4JHfwwtym1Fus",
    placeholder: "(゜-゜)つロ 干杯~-bilibili",
    pageSize:'10',
    avatar:'mp',
    lang:'zh-cn',
    highlight:'true'
  })
  </script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
