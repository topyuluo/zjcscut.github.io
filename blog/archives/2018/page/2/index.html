<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2018 | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 10px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
	
		
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/09/java-reflection-class-load/">
      深入分析Java反射(五)-类实例化和类加载
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月9日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：15分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-12T00:45:32+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月12日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(五)-类实例化和类加载</h1>
<h2 id="前提">前提</h2>
<p>其实在前面写过的《深入分析Java反射(一)-核心类库和方法》已经介绍过通过类名或者<code>java.lang.Class</code>实例去实例化一个对象，在《浅析Java中的资源加载》中也比较详细地介绍过类加载过程中的双亲委派模型，这篇文章主要是加深一些对类实例化和类加载的认识。</p>
<h2 id="类实例化">类实例化</h2>
<p>在反射类库中，用于实例化对象只有两个方法：</p>
<ul>
<li><code>T java.lang.Class#newInstance()</code>：这个方法只需要提供<code>java.lang.Class&lt;T&gt;</code>的实例就可以实例化对象，如果提供的是无限定类型<code>Class&lt;?&gt;</code>则得到的是Object类型的返回值，可以进行强转。这个方法不支持任何入参，底层实际上也是依赖无参数的构造器Constructor进行实例化。</li>
<li><code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>：这个方法需要提供<code>java.lang.reflect.Constructor&lt;T&gt;</code>实例和一个可变参数数组进行对象的实例化，上面提到的<code>T java.lang.Class#newInstance()</code>底层也是依赖此方法。这个方法除了可以传入构造参数之外，还有一个好处就是可以通过``抑制修饰符访问权限检查，也就是私有的构造器也可以用于实例化对象。</li>
</ul>
<p>在编写反射类库的时候，优先选择<code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>进行对象实例化，目前参考很多优秀的框架(例如Spring)都是用这个方法进行对象实例化。</p>
<h2 id="类加载">类加载</h2>
<p>类加载实际上由类加载器(ClassLoader)完成，<code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>方法提现了类加载过程中遵循了双亲委派模型，实际上，我们可以覆写此方法完全不遵循双亲委派模型，实现同一个类(这里指的是全类名完全相同)重新加载。JDK中提供类加载相关的特性有两个方法：</p>
<ul>
<li><code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>：通过类加载器实例去加载类，一般应用类路径下的类是由<code>jdk.internal.loader.ClassLoaders$AppClassLoader</code>加载，也可以自行继承<code>java.lang.ClassLoader</code>实现自己的类加载器。</li>
<li><code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>：通过全类名进行类加载，可以通过参数控制类初始化行为。</li>
</ul>
<h3 id="ClassLoader中的类加载">ClassLoader中的类加载</h3>
<p>类加载过程其实是一个很复杂的过程，主要包括下面的步骤：</p>
<ul>
<li>1、加载过程：使用(自定义)类加载器去获取类文件字节码字节类的过程，Class实例在这一步生成，作为方法区的各种数据类型的访问入口。</li>
<li>2、验证过程：JVM验证字节码的合法性。</li>
<li>3、准备过程：为类变量分配内存并且设置初始值。</li>
<li>4、解析过程：JVM把常量池中的符号替换为直接引用。</li>
<li>5、初始化过程：执行类构造器<code>&lt;cinit&gt;()</code>方法，<code>&lt;cinit&gt;()</code>方法是编译器自动收集所有类变量的赋值动作和静态代码块中的语句合并生成，收集顺序由语句在源文件中出现的顺序决定，JVM保证在子类<code>&lt;cinit&gt;()</code>方法调用前父类的<code>&lt;cinit&gt;()</code>方法已经执行完毕。</li>
</ul>
<p><code>ClassLoader#loadClass()</code>方法就是用于控制类加载过程的第一步-加载过程，也就是控制字节码字节数组和类名生成Class实例的过程。<code>ClassLoader</code>中还有一个<code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</code>方法用于指定全类名和字节码字节数组去定义一个类，我们再次看下<code>loadClass()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查类是否已经加载过，如果已经加载过，则直接返回</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="comment">// 委派父类加载器去加载类</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 委派父类加载器如果加载失败则调用findClass方法进行加载动作</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展点-1</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 扩展点-2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>loadClass()</code>方法留下了两个扩展点用于改变类加载的行为，而<code>findClass()</code>方法就是用于扩展父类加载器加载失败的情况下，子类加载器的行为。当然，实际上<code>Class&lt;?&gt; loadClass(String name, boolean resolve)</code>方法<strong>是非final的方法，可以整个方法覆写掉，这样子就有办法完全打破双亲委派机制</strong>。但是注意一点，即使打破双亲委派机制，子类加载器也不可能重新加载一些由Bootstrap类加载器加载的类库如<code>java.lang.String</code>，这些是由JVM验证和保证的。自定义类加载器的使用在下一节的&quot;类重新加载&quot;中详细展开。</p>
<p>最后还有两点十分重要：</p>
<ul>
<li>1、<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性</strong>，也就是一个类在JVM中的签名是加载它的类加载器和它本身，<strong>对于每一个类加载器，都拥有一个独立的类命名空间</strong>。</li>
<li>2、<strong>比较两个类是否&quot;相等&quot;，只有这两个类是由同一个类加载器加载的前提下才有意义</strong>。即使这两个类的全类名一致、来源于同一个字节码文件、被同一个Java虚拟机加载，但是加载它们的类加载器不同，那么它们必定不相等。这里相等的范畴包括：<code>Class</code>对象的<code>equals()</code>方法、<code>isAssignableForm()</code>方法、<code>isInstance()</code>方法的返回结果以及使用<code>instanceof</code>关键字做对象所属关系时候的判定等情况。</li>
</ul>
<h3 id="Class中的类加载">Class中的类加载</h3>
<p><code>java.lang.Class</code>中的类加载主要由<code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>方法完成，该方法可以指定全类名、是否初始化和类加载器实例。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">        <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">        caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">            <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sm.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                        ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt; caller) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>它最终调用的是JVM的本地接口方法，由于暂时没有能力分析JVM的源码，只能通过<code>forName</code>方法的注释理解方法的功能：</p>
<blockquote>
<p>返回给定字符串全限定名称、指定类加载器的类或者接口的Class实例，此方法会尝试对类或者接口进行locate、load and link操作，如果loader参数为null，则使用bootstrap类加载器进行加载，如果initialize参数为true同时类或者接口在早期没有被初始化，则会进行初始化操作。</p>
</blockquote>
<p>也就是说initialize参数对于已经初始化过的类或者接口来说是没有意义的。这个方法的特性还可以参考<a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html" target="_blank" rel="noopener">Java语言规范的12章中的内容</a>，这里不做展开。</p>
<p>虽然暂时没法分析JVM本地接口方法<code>native Class&lt;?&gt; forName0()</code>的功能，但是它依赖一个类加载器实例入参，可以大胆猜测它也是依赖于类加载器的<code>loadClass()</code>进行类加载的。</p>
<h2 id="类重新加载">类重新加载</h2>
<p>先提出一个实验，如果定义一个类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用字节码工具修改<code>say()</code>方法的内容为<code>System.out.println(&quot;Hello Throwable!&quot;);</code>，并且使用自定义的ClassLoader重新加载一个同类名的<code>Sample</code>类，那么通过<code>new</code>关键字实例化出来的<code>Sample</code>对象调用<code>say()</code>到底打印&quot;Hello Doge!“还是&quot;Hello Throwable!”？</p>
<p>先引入字节码工具javassist用于修改类的字节码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.24.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性使用的自定义类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">		CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">		<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">		Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">        <span class="comment">// 类路径中的Demo类</span></span><br><span class="line">		Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">		demo.say();</span><br><span class="line">		<span class="comment">// 新的Demo类</span></span><br><span class="line">		newDemoClass.getDeclaredMethod(<span class="string">"say"</span>).invoke(newDemoClass.newInstance());</span><br><span class="line">		<span class="comment">// 比较</span></span><br><span class="line">		System.out.println(newDemoClass.equals(Demo<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello Doge!</span><br><span class="line">Hello Throwable!</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>这里得出的结论是：</p>
<ul>
<li><code>new</code>关键字只能使用在当前类路径下的类的实例化，而这些类都是由应用类加载器加载，如果上面的例子中<code>newDemoClass.newInstance()</code>强制转换为Demo类型会报错。</li>
<li>通过自定义类加载器加载的和当前类路径相同名全类名的类只能通过反射去使用，而且即使全类名相同，由于类加载器隔离，它们其实是不相同的类。</li>
</ul>
<h3 id="如何避免类重新加载导致内存溢出">如何避免类重新加载导致内存溢出</h3>
<p>实际上，JDK没有提供方法去卸载一个已经加载的类，也就是类的生命周期是由JVM管理的，因此要解决类重新加载导致内存溢出的问题归根结底就是解决重新加载的类被回收的问题。由于创建出来是的<code>java.lang.Class</code>对象，如果需要回收它，则要考虑下面几点：</p>
<ul>
<li>1、<code>java.lang.Class</code>对象反射创建的实例需要被回收。</li>
<li>2、<code>java.lang.Class</code>对象不能被任何地方强引用。</li>
<li>3、加载<code>java.lang.Class</code>对象的<code>ClassLoder</code>已经被回收。</li>
</ul>
<p>基于这几点考虑可以做个试验验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里故意建立一个数组占用大量内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, List&lt;Class&lt;?&gt;&gt;&gt; CACHE = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">			CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">			<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">			Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">			add(classLoader, newDemoClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理类加载器和它加载过的类</span></span><br><span class="line">		clear();</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (CACHE.containsKey(classLoader)) &#123;</span><br><span class="line">			CACHE.get(classLoader).add(clazz);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			CACHE.put(classLoader, classes);</span><br><span class="line">			classes.add(clazz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CACHE.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用VM参数<code>-XX:+PrintGC -XX:+PrintGCDetails</code>执行上面的方法，JDK11默认使用G1收集器，由于Z收集器还在实验阶段，不是很建议使用，执行main方法后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11.374</span>s][info   ][gc,task       ] GC(<span class="number">17</span>) Using <span class="number">8</span> workers of <span class="number">8</span> <span class="keyword">for</span> full compaction</span><br><span class="line">[<span class="number">11.374</span>s][info   ][gc,start      ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>)</span></span><br><span class="line"><span class="function">[11.374s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,stringtable ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Cleaned string and symbol table, strings: 5637 processed, 0 removed, symbols: 135915 processed, 0 removed</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects 54.378ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction 0.422ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers 0.598ms</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap 0.362ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Eden regions: 44-&gt;0<span class="params">(<span class="number">9</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Survivor regions: 12-&gt;0<span class="params">(<span class="number">12</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Old regions: 146-&gt;7</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Humongous regions: 3-&gt;2</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,metaspace   ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Metaspace: 141897K-&gt;9084<span class="title">K</span><span class="params">(<span class="number">1062912</span>K)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc             ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 205M-&gt;3<span class="title">M</span><span class="params">(<span class="number">30</span>M)</span> 273.440ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.31</span>s Sys=<span class="number">0.08</span>s Real=<span class="number">0.27</span>s</span><br></pre></td></tr></table></figure>
<p>可见FullGC之后，元空间(Metaspace)回收了(141897-9084)KB，一共回收了202M的内存空间，初步可以认为元空间的内存被回收了，接下来注释掉main方法中调用的<code>clear()</code>方法，再调用一次main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,heap        ] GC(<span class="number">17</span>) Humongous regions: <span class="number">3</span>-&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,metaspace   ] GC(<span class="number">17</span>) Metaspace: <span class="number">141884</span>K-&gt;<span class="number">141884</span>K(<span class="number">1458176</span>K)</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc             ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 201M-&gt;166<span class="title">M</span><span class="params">(<span class="number">564</span>M)</span> 115.504ms</span></span><br><span class="line"><span class="function">[4.083s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.84</span>s Sys=<span class="number">0.00</span>s Real=<span class="number">0.12</span>s</span><br></pre></td></tr></table></figure>
<p>可见元空间在FullGC执行没有进行回收，而堆内存的回收率也比较低，由此可以得出一个经验性的结论：只需要通过ClassLoader对象做映射关系保存使用它加载出来的新的类，只需要确保这些类没有没强引用、类实例都已经销毁，那么只需要移除ClassLoader对象的引用，那么在JVM进行GC的时候会把ClassLoader对象以及使用它加载的类回收，这样做就可以避免元空间的内存泄漏。</p>
<h2 id="小结">小结</h2>
<p>通过一些资料和实验，深化了类加载过程的一些认识。</p>
<p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机-第二版》</li>
<li>JDK11部分源码</li>
</ul>
<p>(本文完 e-2018129 c-2-d r-20181212)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/08/java-reflection-dynamic-proxy/">
      深入分析Java反射(四)-动态代理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月8日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：27分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-08T20:25:34+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(四)-动态代理</h1>
<h2 id="动态代理的简介">动态代理的简介</h2>
<p>Java动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。Java动态代理实际上通过反射技术，把代理对象和被代理对象(真实对象)的代理关系建立延迟到程序运行之后，动态创建新的代理类去完成对真实对象的代理操作(可以改变原来真实对象的方法行为)，这一点成为了当前主流的AOP框架和延迟加载功能的基础。本文在查看和编写动态代理相关的代码使用的是JDK11，不过JDK动态代理相关的功能和接口已经相对稳定，不必担心JDK版本升级带来的兼容性问题，但是需要注意由于JDK9引入了模块概念，动态代理的源码也有不少的改动。下文先介绍设计模式中的代理模式，接着会分析JDK动态代理的核心类库、流程和机制，最后分析其底层源码级别实现。</p>
<h2 id="设计模式中的代理模式">设计模式中的代理模式</h2>
<p>代理模式是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-2.png" alt="j-r-d-p-2.png"></p>
<p>代理模式主要包括三种角色：</p>
<ul>
<li>Subject抽象主题角色：一般定义为抽象类或者接口，是作为功能的定义，提供一系列抽象的功能方法。</li>
<li>RealSubject具体(真实)主题角色：一般称为被委托角色或者被代理角色，它是Subject的一个具体实现。</li>
<li>ProxySubject代理主题角色：一般称为委托角色或者代理角色，一般ProxySubject也实现(或者继承)Subject，接收一个具体的Subject实例RealSubject，在RealSubject处理前后做预定义或者后置操作，甚至可以直接忽略RealSubject原来的方法。</li>
</ul>
<p>把上面的类图编写成代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"RealSubject doSomething..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.subject = subject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		subject.doSomething();</span><br><span class="line">		doOtherThing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ProxySubject doOtherThing..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(subject);</span><br><span class="line">		proxySubject.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>Client#main()</code>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealSubject doSomething...</span><br><span class="line">ProxySubject doOtherThing...</span><br></pre></td></tr></table></figure>
<p>代理模式在日常的场景中也经常碰到，比较常见的一个场景就是游戏代练，套进去上面的代码可以写个比较生动的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"操作Throwable游戏角色打怪升级"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Player player;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyPlayer</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.player = player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		login();</span><br><span class="line">		<span class="keyword">this</span>.player.playGame();</span><br><span class="line">		logout();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"登录Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"退出Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式有几个比较大的优点：</p>
<ul>
<li>职责清晰：也就是真实主题角色只需要实现具体的逻辑，不需关注代理类的职责，而代理类也只需要处理预处理和后置的逻辑，类的职责分明。</li>
<li>高扩展性：由于职责分明，也就是真实主题角色可以随时修改实现，这样就能通过更新或者替换真实主题的实现并且不改变代理主题角色的情况下改变具体功能。</li>
<li>高灵活性：主要体现在后面提到的动态代理。</li>
</ul>
<h2 id="JDK动态代理的核心API">JDK动态代理的核心API</h2>
<p>JDK动态代理提供外部使用的主要依赖两个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>：可以理解为代理类的工厂类(其实也是父类，见下文)。</li>
<li><code>java.lang.reflect.InvocationHandler</code>：代理实例需要实现的调用处理器接口。</li>
</ul>
<h3 id="Proxy">Proxy</h3>
<p><code>java.lang.reflect.Proxy</code>是JDK动态代理的核心类，它的核心功能是提供静态方法来为一组接口动态地生成代理类并且返回代理实例对象，类似于代理类实例的工厂类。<code>java.lang.reflect.Proxy</code>主要提供四个public静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>InvocationHandler getInvocationHandler(Object proxy)</code>：通过制定的代理类实例查找它关联的调用处理器实例。</li>
<li><code>Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>：用于获取关联于指定类装载器和一组接口的动态代理类的类对象，也就是获取<code>$ProxyXXX</code>的类型，此方法在JDK9以后标记为过期，原因是：在命名模块中生成的代理类是封闭的，模块外的代码无法访问这些类(违反模块规则调用了会抛异常)。</li>
<li><code>boolean isProxyClass(Class&lt;?&gt; cl)</code>：用于判断指定类是否是一个动态代理类。</li>
<li><code>Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code>：这个是JDK动态代理最核心的方法，用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，也就是生成<code>$ProxyXXX</code>的实例。此方法需要指定类加载器<code>java.lang.ClassLoader</code>，Proxy静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是在运行时动态生成的而非预存在于任何一个.class文件中。interfaces是Class数组，也就是需要使用InvocationHandler进行代理访问的接口类型数组，这里的h参数就是调用处理器的实例。</li>
</ul>
<h3 id="InvocationHandler">InvocationHandler</h3>
<p><code>java.lang.reflect.InvocationHandler</code>是调用处理器接口，它自定义了一个<code>invoke</code>方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>proxy：Object类型，此参数即是代理类实例，也就是<code>$ProxyXXX</code>的实例。</li>
<li>method：<code>java.lang.reflect.Method</code>类型，被调用的方法的实例。</li>
<li>args：Object[]类型，被调用方法的参数数组。</li>
</ul>
<p>实现<code>java.lang.reflect.InvocationHandler</code>接口，通过实现<code>invoke</code>方法即可添加代理访问的逻辑，在这个逻辑代码块中除了可以调用委托类的方法，还可以织入额外的自定义逻辑，AOP就是这样实现的。</p>
<h2 id="JDK动态代理的流程">JDK动态代理的流程</h2>
<p>JDK动态代理的使用流程如下：</p>
<ul>
<li>1、通过实现<code>java.lang.reflect.InvocationHandler</code>接口创建自定义的调用处理器。</li>
<li>2、通过为<code>java.lang.reflect.Proxy</code>类指定<code>ClassLoader</code>对象和一组interface来创建动态代理类。</li>
<li>3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型。</li>
<li>4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy为包括Interface接口在内的一组接口动态创建代理类的类对象</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span>, ... &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过反射从生成的类对象获得构造函数对象</span></span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数对象创建动态代理类实例</span></span><br><span class="line">Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的过程比较复杂，可以进行精简。简化后的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl实现了InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">handler</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="JDK动态代理的机制">JDK动态代理的机制</h2>
<p>首先是JDK动态代理生成的代理类本身的特点：</p>
<ul>
<li>1、<strong>包(或者JDK9引入的模块)</strong>：如果所代理的接口都是public的，那么它将被定义在包<code>com.sun.proxy</code>；如果所代理的接口中有非public的接口(因为接口不能被定义为protect或private，所以除public之外就是默认的package访问级别，修饰符为default)，那么它将被定义在该接口所在包(假设代理了<code>throwable.club</code>包中的某非public接口A，那么新生成的代理类所在的包就是<code>throwable.club</code>)，值得注意的是，<strong>如果接口数组中存在非public的接口，那么它们必须在同一个包路径下，否则会抛异常</strong>。这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问。</li>
<li>2、<strong>类修饰符</strong>：该代理类具有final和public修饰符，<strong>意味着它可以被所有的类访问，但是不能被再度继承</strong>。</li>
<li>3、<strong>类名</strong>：代理类名称格式是<code>$ProxyN</code>，其中N是一个逐一递增的阿拉伯数字，代表<code>java.lang.reflect.Proxy</code>类第N次生成的动态代理类，值得注意的一点是，并不是每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口(包括接口排列的顺序相同)试图重复创建动态代理类，它会从缓存中获取先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li>
<li>4、<strong>类继承关系</strong>：代理类的继承关系图如下：</li>
</ul>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-1.png" alt="j-r-d-p-1.png"></p>
<p>由图可知，<code>java.lang.reflect.Proxy</code>类是代理类的父类，这个规则适用于所有由<code>java.lang.reflect.Proxy</code>创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。</p>
<h3 id="代理类实例的特点">代理类实例的特点</h3>
<p>每个代理类实例都会关联一个调用处理器对象，可以通过<code>java.lang.reflect.Proxy</code>提供的静态方法<code>getInvocationHandler()</code>去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行，此外，值得注意的是，代理类的根类<code>java.lang.Object</code>中有三个方法也同样会被分派到调用处理器的<code>invoke</code>方法执行，它们是<code>hashCode</code>、<code>equals</code>和<code>toString</code>，可能的原因有：</p>
<ul>
<li>一、因为这些方法为public且非final类型，能够被代理类覆盖。</li>
<li>二、因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口(或继承于该接口的某子接口)的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。</li>
</ul>
<h3 id="被代理的一组接口的特点">被代理的一组接口的特点</h3>
<p>首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过65535，这是JVM设定的限制，这一点在代理类生成的时候也做了判断。</p>
<h3 id="异常处理">异常处理</h3>
<p>从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于Throwable接口，但事实是否如此呢？答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛Throwable异常。那么如果在invoke方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Jdk动态代理类已经为我们设计好了解决方法：它将会抛出<code>UndeclaredThrowableException</code> 异常。这个异常是一个<code>RuntimeException</code>类型，所以不会引起编译错误。通过该异常的<code>getCause</code>方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。</p>
<h2 id="JDK动态代理源码分析">JDK动态代理源码分析</h2>
<p>因为JDK动态代理核心逻辑都在<code>java.lang.reflect.Proxy</code>类中，下面简单分析一下这个类的源码。先看<code>Proxy</code>类中的几个重要的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口组中接口都为为public时候代理类创建的包路径：com.sun.proxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的构造方法参数类型数组，可见代理类的构造参数只有InvocationHandler类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存了所有已经调用过setAccessible(true)的代理类的构造(Constructor)实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这里注意到<code>ClassLoaderValue</code>，下文会调用到它的一个很复杂的调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intf是Class&lt;?&gt;类型</span></span><br><span class="line"><span class="comment">//loader是类加载器实例</span></span><br><span class="line"><span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">    loader,</span><br><span class="line">    (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BiFunction&lt;? <span class="keyword">super</span> ClassLoader,? <span class="keyword">super</span> CLV,? extends V&gt; mappingFunction)</span> </span></span><br><span class="line"><span class="function">						<span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>上面的<code>computeIfAbsent</code>中使用了函数式接口和Lambda表达式，如果Lambda表达式玩的比较熟练看起来应该没问题，它的功能可以解读为：通过接口类型和类加载器实例计算通过接口类型和类加载器实例构建<code>ProxyBuilder</code>实例并且调用<code>ProxyBuilder#build()</code>得到的结果，如果结果已经存在则直接返回缓存。其实<code>computeIfAbsent</code>在<code>Map</code>接口中也定义了同样的方法，功能是相似的。</p>
<p>接着看<code>Proxy</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此可以明确一点，既然所有动态代理类都是<code>java.lang.reflect.Proxy</code>的子类，那么它们一定具备一个包含<code>InvocationHandler</code>参数的构造器。接着查看``方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空判断									  </span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="comment">// 当前调用类获取</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">                                    ? <span class="keyword">null</span></span><br><span class="line">                                    : Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 获取代理类的构造器实例								</span></span><br><span class="line">    Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line">    <span class="comment">// 生成代理实例</span></span><br><span class="line">    <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看<code>getProxyConstructor</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; getProxyConstructor(Class&lt;?&gt; caller,</span><br><span class="line">                                                  ClassLoader loader,</span><br><span class="line">                                                  Class&lt;?&gt;... interfaces)&#123;</span><br><span class="line">    <span class="comment">// 这里需要区分代理接口数组中只有单个接口和多个接口的逻辑				  </span></span><br><span class="line">    <span class="comment">// 而基本的逻辑都是先校验当前调用类的权限，后续获取Constructor实例委托到ProxyBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length == <span class="number">1</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; intf = interfaces[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 接口克隆</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfsArray = interfaces.clone();</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intfsArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intfs).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明确，核心的逻辑都交给了<code>Proxy</code>的内部类<code>ProxyBuilder</code>完成，先看<code>ProxyBuilder</code>的静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的简单类名的前置字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成下一个代理类的数字计数器，记住它是静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了已经生成的代理类-Boolean的映射，已经生成过对应代理类则记录为true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Boolean&gt; reverseProxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个代理接口的情况，其实也是把接口转换为List</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, Class&lt;?&gt; intf) &#123;</span><br><span class="line">    <span class="keyword">this</span>(loader, Collections.singletonList(intf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个代理接口的情况</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    <span class="comment">// 通过JVM参数强制关闭动态代理功能则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isModuleSystemInited()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Proxy is not supported until "</span></span><br><span class="line">                + <span class="string">"module system is fully initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理接口数量不能超过65535，也就是最多代理65535个接口</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded: "</span></span><br><span class="line">                + interfaces.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集接口数组中所有接口的非静态方法的返回值类型、共享(shared)参数类型和共享(shared)异常类型，注释说是收集代理接口的方法签名</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; refTypes = referencedTypes(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保上一步得到的代理接口方法签名的类型都是"可见(其实就是类型都存在)"的，通过遍历调用Class.forName(type.getName(), false, ld)去判断</span></span><br><span class="line">    validateProxyInterfaces(loader, interfaces, refTypes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="comment">// 获取代理类最终生成的模块，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、所有代理接口的修饰符都为public，接口所在模块都能公开访问，则返回unnamed模块</span></span><br><span class="line">    <span class="comment">// 2、如果有任意的代理接口是包私有，则返回该包所在的模块		、</span></span><br><span class="line">    <span class="comment">// 3、所有代理接口的修饰符都为public，有任意至少一个接口所在模块不能公开访问，则返回该不能公开访问的模块，</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = mapToModule(loader, interfaces, refTypes);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getLoader</span><span class="params">(<span class="keyword">module</span>)</span> </span>== loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个构造器处理的逻辑也是相对复杂，主要是因为引入模块管理的概念，接着看<code>ProxyBuilder#build()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; build() &#123;</span><br><span class="line">    <span class="comment">// 定义代理类，实际上是动态生成代理类字节码和缓存它的类型的过程</span></span><br><span class="line">    Class&lt;?&gt; proxyClass = defineProxyClass(<span class="keyword">module</span>, interfaces);</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回代理类的构造</span></span><br><span class="line">        cons = proxyClass.getConstructor(constructorParams);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到逻辑最复杂的代理类的生成过程<code>ProxyBuilder#defineProxyClass()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">    <span class="comment">// 这里就是定义代理类包路径的逻辑，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、代理接口数组所有接口都是public修饰，则代理类包路径为com.sun.proxy</span></span><br><span class="line">    <span class="comment">// 2、代理接口数组有任意接口是包私有的，则代理类包路径为该私有包的路径			</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;  <span class="comment">// non-public, final</span></span><br><span class="line">            String pkg = intf.getPackageName();</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面几个if都是包路径的合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// all proxy interfaces are public</span></span><br><span class="line">        proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + <span class="string">"."</span> + m.getName()</span><br><span class="line">                               : PROXY_PACKAGE_PREFIX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proxyPkg.isEmpty() &amp;&amp; m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Unnamed package cannot be added to "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.getDescriptor().packages().contains(proxyPkg)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(proxyPkg + <span class="string">" not exist in "</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器加1返回新的计数值			</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    <span class="comment">// 生成代理类全类名，一个常见的格式是：com.sun.proxy.$Proxy1</span></span><br><span class="line">    String proxyName = proxyPkg.isEmpty()</span><br><span class="line">                            ? proxyClassNamePrefix + num</span><br><span class="line">                            : proxyPkg + <span class="string">"."</span> + proxyClassNamePrefix + num;</span><br><span class="line">    ClassLoader loader = getLoader(m);</span><br><span class="line">    trace(proxyName, m, loader, interfaces);</span><br><span class="line">    <span class="comment">// 动态生成代理类字节码字节数组			</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Unsafe定义代理类-这里是通过字节码定义新的类				</span></span><br><span class="line">        Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span><br><span class="line">                                         <span class="number">0</span>, proxyClassFile.length,</span><br><span class="line">                                         loader, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 缓存代理类已经生成过的标记												 </span></span><br><span class="line">        reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步为止，代理类的生成过程已经大致分析完毕，<code>ProxyGenerator</code>中涉及到大量字节码操作，这里就不深入分析了。那么回到最前面的方法，得到代理类和它的构造实例，接着就可以生成代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(Class&lt;?&gt; caller, // <span class="keyword">null</span> <span class="keyword">if</span> no SecurityManager</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Constructor&lt;?&gt; cons,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(caller, cons.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里简单反射调用Constructor#newInstance(h)</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结一下：</p>
<ul>
<li><strong>接口数组中所有接口元素的类修饰符最好一致为public。如果接口数组中存在非default修饰的接口元素，那么接口数组中的所有接口类都要放在同一个包下，并且都要使用default修饰。</strong></li>
<li>很少情况下我们修改接口的修饰符，默认为public，那么所有代理类的包路径都是<code>com.sun.proxy</code>，全类名是:<code>com.sun.proxy.$ProxyN</code>。</li>
<li>代理接口数量不能超过65535。</li>
</ul>
<h2 id="JDK动态代理类的源代码">JDK动态代理类的源代码</h2>
<p>前面已经分析完了代理类的生成过程，这里举个简单的使用例子，并且观察生成的动态代理类的源代码。</p>
<p><strong>使用例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before say hello...</span><br><span class="line">throwable say hello!</span><br><span class="line">After say hello...</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在被代理类<code>DefaultSimple</code>实例的方法调用前后织入了自定义的逻辑，这就是通过JDK动态代理实现AOP的底层原理。在JDK8中可以直接使用<code>sun.misc.ProxyGenerator</code>去输出代理类的class文件，但是JDK11中这个代理类生成器已经变成<code>java.lang.reflect.ProxyGenerator</code>，并且这个类是包私有的，我们无法使用，但是它提供了<code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>这个VM参数让我们可以保存代理类的class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># JVM参数</span><br><span class="line">-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>配置好VM参数后，再次调用mian方法就能看到在项目的顶层包路径下看到对应的类<code>com.sun.proxy.$Proxy0</code>，目前从<code>java.lang.reflect.ProxyGenerator</code>源码看无法控制代理类文件的输出路径，生成的代理类内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类的代码比较简单，有如下几个特点：</p>
<ul>
<li>1、代理类继承于<code>java.lang.reflect.Proxy</code>，实现了接口数组中的接口元素类，构造函数只有一个<code>InvocationHandler</code>类型的参数。</li>
<li>2、接口中的所有被代理方法包括<code>equals</code>、<code>toString</code>、<code>hashCode</code>都建立了一个对应的Method私有静态实例，在最后面的静态代码块中实例化。</li>
<li>3、所有代理方法都是用public final修饰，也就是代理类中的代理方法是不能覆盖的。</li>
<li>4、所有代理方法都是通过<code>InvocationHandler</code>实例的<code>invoke</code>方法进行调用的，记得第一个参数是代理类实例本身，如果用了在<code>InvocationHandler#invoke()</code>方法实现过程中使用了这个参数有可能造成死循环。</li>
</ul>
<h2 id="小结">小结</h2>
<p>诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的<strong>单继承机制</strong>注定了这些动态代理类们无法实现对class的动态代理(所以只能代理接口，实际上是基于反射对方法级别的逻辑进行编织)。有很多条理由，可以否定对class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。但是，不完美并不等于不伟大，伟大是一种本质，JDK动态代理就是佐例。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第1部分</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy2/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第2部分</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 e-20181208 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/05/java-reflection-generics/">
      深入分析Java反射(三)-泛型
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月5日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：28分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-05T23:20:21+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月5日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(三)-泛型</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射中一个比较难的问题-泛型。</p>
<h2 id="泛型的简介">泛型的简介</h2>
<p>泛型是在2004年JavaSE 5.0(JDK1.5)版本中添加到Java编程语言中的泛型编程工具。泛型的设计是为了应用在Java的类型系统，<strong>提供&quot;用类型或者方法操作各种类型的对象从而提供编译期的类型安全功能(原文：a type or method to operate on objects of various types while providing compile-time type safety)&quot;</strong>。但是在2016年的一些研究表明，泛型并不是在所有的情况下都能保证编译期的类型安全，例如切面(Aspect)编程的编译期类型安全并没有完全实现。</p>
<p><strong>泛型的一个最大的优点就是：提供编译期的类型安全</strong>。举个很简单的例子，在引入泛型之前，<code>ArrayList</code>内部只维护了一个Object数组引用，这种做法有两个问题：</p>
<ul>
<li>从数组列表获取一个元素的时候必须进行类型的强转。</li>
<li>向数组列表中可以添加任何类型的对象，导致无法得知数组列表中存放了什么类型的元素。</li>
</ul>
<p>引入泛型之后，我们可以通过类型参数明确定义<code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaSE 7以后的版本中构造函数可以省略类型，编译器可以推导出实际类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>下面先列举出Java中泛型的一些事实：</p>
<ul>
<li><strong>Java虚拟机中不存在泛型，只有普通的类和方法，但是字节码中存放着泛型相关的信息</strong>。</li>
<li>所有的类型参数都使用它们的限定类型替换。</li>
<li>桥方法(Bridge Method)由编译器合成，用于保持多态(<strong>Java虚拟机利用方法的参数类型、方法名称和方法返回值类型确定一个方法</strong>)。</li>
<li>为了保持类型的安全性，必要时需要进行类型的强制转换。</li>
</ul>
<h2 id="理解类型擦除">理解类型擦除</h2>
<h3 id="类型擦除是什么">类型擦除是什么</h3>
<p>类型擦除(或者更多时候喜欢称为&quot;<strong>泛型擦除</strong>&quot;)的具体表现是：无论何时定义一个泛型类型，都自动提供一个相应的原始类型(Raw Type，这里的原始类型并不是指int、boolean等基本数据类型)，原始类型的类名称就是带有泛型参数的类删去泛型参数后的类型名称，而原始类型会擦除(Erased)类型变量，并且把它们替换为限定类型(如果没有指定限定类型，则擦除为Object类型)，举个例子<code>Pair&lt;T&gt;</code>带有泛型参数的类型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>擦除类型后的<code>Pair&lt;T&gt;</code>的原始类型为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个更复杂的例子，如果泛型参数类型是有上限的，变量会擦除为上限的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T lower;</span><br><span class="line">	<span class="keyword">private</span> T upper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T lower, T upper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lower = lower;</span><br><span class="line">		<span class="keyword">this</span>.upper = upper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除后的<code>Interval&lt;T extends Comparable &amp; Serializable&gt;</code>原始类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Comparable lower;</span><br><span class="line">	<span class="keyword">private</span> Comparable upper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable lower, Comparable upper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lower = lower;</span><br><span class="line">		<span class="keyword">this</span>.upper = upper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种多个泛型上限的类型，应该尽量把标识接口上限类型放在边界列表的尾部，这样做可以提高效率。</p>
<h3 id="为什么需要擦除类型">为什么需要擦除类型</h3>
<p>在JDK1.5之前，也就是在泛型出现之前，所有的类型包括基本数据类型(int、byte等)、包装类型、其他自定义的类型等等都可以使用类文件(.class)字节码对应的<code>java.lang.Class</code>描述，也就是<code>java.lang.Class</code>类的一个具体实例对象就可以代表任意一个指定类型的原始类型。这里把泛型出现之前的所有类型暂时称为&quot;历史原始类型&quot;。</p>
<p>在JDK1.5之后，数据类型得到了扩充，出历史原始类型扩充了四种泛型类型：参数化类型(ParameterizedType)、类型变量类型(TypeVariable)、限定符类型(WildcardType)、泛型数组类型(GenericArrayType)。历史原始类型和新扩充的泛型类型都应该统一成各自的字节码文件类型对象，也就应该把泛型类型归并进去<code>java.lang.Class</code>中。但是由于JDK已经迭代了很多版本，泛型并不属于当前Java中的基本成分，如果JVM中引入真正的泛型类型，那么必须涉及到JVM指令集和字节码文件的修改(这个修改肯定不是小的修改，因为JDK当时已经迭代了很多年，而类型是编程语言的十分基础的特性，引入泛型从项目功能迭代角度看可能需要整个JVM项目做回归测试)，这个功能的代价十分巨大，所以Java没有在Java虚拟机层面引入泛型。</p>
<p>Java为了使用泛型，于是使用了类型擦除的机制引入了&quot;泛型的使用&quot;，并没有真正意义上引入和实现泛型。Java中的泛型实现的是编译期的类型安全，也就是泛型的类型安全检查是在编译期由编译器(常见的是javac)实现的，这样就能够确保数据基于类型上的安全性并且避免了强制类型转换的麻烦(实际上，强制类型转换是由编译器完成了，只是不需要人为去完成而已)。<strong>一旦编译完成，所有的泛型类型都会被擦除，如果没有指定上限，就会擦除为Object类型，否则擦除为上限类型。</strong></p>
<p>既然Java虚拟机中不存在泛型，那么为什么可以从JDK中的一些类库获取泛型信息？这是因为类文件(.class)或者说字节码文件本身存储了泛型的信息，相关类库(可以是JDK的类库，也可以是第三方的类库)读取泛型信息的时候可以从字节码文件中提取，例如比较常用的字节码操作类库ASM就可以读取字节码中的信息甚至改造字节码动态生成类。例如前面提到的<code>Interval&lt;T extends Comparable &amp; Serializable&gt;</code>类，使用<code>javap -c -v</code>命令查看其反编译得到的字节码信息，可以看到其签名如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature: #22                          // &lt;T::Ljava/lang/Comparable;:Ljava/io/Serializable;&gt;Ljava/lang/Object;Ljava/io/Serializable;</span><br></pre></td></tr></table></figure>
<p>这里的签名信息实际上是保存在常量池中的，关于字节码文件的解析将来会出一个系列文章详细展开。</p>
<h2 id="Type体系">Type体系</h2>
<p>前文提到了在JDK1.5中引入了四种新的泛型类型<code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code>、<code>java.lang.reflect.GenericArrayType</code>，包括原来存在的<code>java.lang.Class</code>，一共存在五种类型。为了程序的扩展性，引入了<code>java.lang.reflect.Type</code>类作为这五种类型的公共父接口，这样子就可以使用<code>java.lang.reflect.Type</code>类型参数去接收以上五种子类型的实参或者返回值，由此从逻辑上统一了泛型相关的类型和原始存在的<code>java.lang.Class</code>描述的类型。Type体系如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-g-1.png" alt="j-r-g-1.png"></p>
<p>注意：</p>
<ul>
<li>ParameterizedType、TypeVariable、WildcardType、GenericArrayType都是接口，它们位于<code>java.lang.reflect</code>包中。</li>
<li>ParameterizedTypeImpl、TypeVariableImpl、WildcardTypeImpl、GenericArrayTypeImpl是四种泛型类型的实现，位于<code>sun.reflect.generics.reflectiveObjects</code>包中。</li>
</ul>
<p>Type体系虽然看似很美好解决了泛型相关的类型和原始存在的<code>java.lang.Class</code>描述的类型的统一问题，但是引入了新的问题：如果一个方法返回值为<code>java.lang.reflect.Type</code>类型，或者一个方法的入参类型为<code>java.lang.reflect.Type</code>类型，这两种情况下，可能需要对<code>java.lang.reflect.Type</code>类型的对象做子类型判断，因为它的子类型有可能是上面提到的五种类型中的其中一种，这一点提高了编码的复杂性。</p>
<h3 id="ParameterizedType">ParameterizedType</h3>
<p>ParameterizedType，parameterized type，也就是参数化类型，注释里面说到<code>ParameterizedType</code>表示一个参数化类型，例如<code>Collection&lt;String&gt;</code>，实际上只要带有参数化(泛型)标签<code>&lt;ClassName&gt;</code>的参数或者属性，都属于ParameterizedType。例如下面的类型都是ParameterizedType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set;</span><br><span class="line">Class&lt;Integer&gt; clazz;</span><br><span class="line">MyClass&lt;String&gt; myClass;</span><br><span class="line">List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而像下面的忽略泛型参数或者基本数据类型和基本数据类型的包装类都不是ParameterizedType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"throwbale"</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">Set set;</span><br><span class="line">List list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.lang.reflect.ParameterizedType</code>接口继承自<code>java.lang.reflect.Type</code>接口，实现类是<code>sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</code>，其实，必要的时候，我们也可以自行实现ParameterizedType，像一些Json解析工具都是自行实现ParameterizedType的。ParameterizedType接口的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getActualTypeArguments()：返回这个ParameterizedType类型的参数的实际类型Type数组，Type数组里面的元素有可能是Class、ParameterizedType、TypeVariable、GenericArrayType或者WildcardType之一。值得注意的是，无论泛型符号<code>&lt;&gt;</code>中有几层<code>&lt;&gt;</code>嵌套，这个方法仅仅脱去最外层的<code>&lt;&gt;</code>，之后剩下的内容就作为这个方法的返回值。</li>
<li>Type getRawType()：返回的是当前这个ParameterizedType的原始类型，从ParameterizedTypeImpl的源码看来，原始类型rawType一定是一个<code>Class&lt;?&gt;</code>实例。举个例子，<code>List&lt;Person&gt;</code>通过<code>getRawType()</code>获取到的Type实例实际上是<code>Class&lt;?&gt;</code>实例，和List.class等价。</li>
<li>Type getOwnerType()：获取原始类型所属的类型，从ParameterizedTypeImpl的源码看来，就是调用了原始类型rawType的<code>getDeclaringClass()</code>方法，而像rawType为<code>List&lt;T&gt;</code>、<code>Map&lt;T&gt;</code>这些类型的getOwnerType()实际上就是调用List.class.getDeclaringClass()，Map.class.getDeclaringClass()，返回值都是null。</li>
</ul>
<p>举个关于ParameterizedType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main13</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Sub&gt; subClass = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Type genericSuperclass = subClass.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">            <span class="comment">//获取父类泛型类型数组</span></span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type type : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(type + <span class="string">" is ParameterizedType -&gt; "</span> + (type <span class="keyword">instanceof</span> ParameterizedType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Field field = subClass.getDeclaredField(<span class="string">"clazz"</span>);</span><br><span class="line">        Type genericType = field.getGenericType();</span><br><span class="line">        System.out.println(genericType + <span class="string">" is ParameterizedType -&gt; "</span> + (genericType <span class="keyword">instanceof</span> ParameterizedType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span>&lt;<span class="title">String</span>, <span class="title">List</span>&lt;<span class="title">Person</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">false</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">util</span>.<span class="title">List</span>&lt;<span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main13</span>$<span class="title">Person</span>&gt; <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">true</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>&lt;?&gt; <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">true</span></span></span><br></pre></td></tr></table></figure>
<h3 id="TypeVariable">TypeVariable</h3>
<p>TypeVariable，type variable，也就是类型变量，它是各种类型变量的公共父接口，它主要用来表示带有上界的泛型参数的信息，它和ParameterizedType不同的地方是，ParameterizedType表示的参数的最外层一定是已知具体类型的(如<code>List&lt;String&gt;</code>)，而TypeVariable面向的是K、V、E等这些泛型参数字面量的表示。常见的TypeVariable的表示形式是<code>&lt;T extends KnownType-1 &amp; KnownType-2&gt;</code>。TypeVariable接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获得泛型的上限，若未明确声明上边界则默认为Object</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    <span class="comment">//获取声明该类型变量实体(即获得类、方法或构造器名)</span></span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得名称，即K、V、E之类名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得注解类型的上限，若未明确声明上边界则默认为长度为0的数组</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getBounds()：获得该类型变量的上限(上边界)，若无显式定义(extends)，默认为Object，类型变量的上限可能不止一个，因为可以用&amp;符号限定多个（这其中有且只能有一个为类或抽象类，且必须放在extends后的第一个，即若有多个上边界，则第一个&amp;之后的必为接口）。</li>
<li>D getGenericDeclaration：获得声明(定义)这个类型变量的类型及名称，会使用泛型的参数字面量表示，如<code>public void club.throwable.Main.query(java.util.List&lt;club.throwable.Person&gt;)</code>。</li>
<li>String getName()：获取泛型参数的字面量名称，即K、V、E之类名称。</li>
<li>AnnotatedType[] getAnnotatedBounds()：Jdk1.8新增的方法，用于获得注解类型的上限，若未明确声明上边界则默认为长度为0的数组。</li>
</ul>
<p>举个关于TypeVariable的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main14</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; subClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        TypeVariable&lt;Class&lt;Supper&gt;&gt;[] typeParameters = subClass.getTypeParameters();</span><br><span class="line">        <span class="keyword">for</span> (TypeVariable&lt;Class&lt;Supper&gt;&gt; typeVariable : typeParameters) &#123;</span><br><span class="line">            System.out.println(<span class="string">"getBounds --&gt; "</span> + Arrays.toString(typeVariable.getBounds()));</span><br><span class="line">            System.out.println(<span class="string">"getGenericDeclaration  --&gt; "</span> + typeVariable.getGenericDeclaration());</span><br><span class="line">            System.out.println(<span class="string">"getName --&gt; "</span> + typeVariable.getName());</span><br><span class="line">            AnnotatedType[] annotatedBounds = typeVariable.getAnnotatedBounds();</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"getAnnotatedBounds --&gt; "</span>);</span><br><span class="line">            <span class="keyword">for</span> (AnnotatedType annotatedType : annotatedBounds) &#123;</span><br><span class="line">                java.lang.annotation.Annotation[] annotations = annotatedType.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span> (java.lang.annotation.Annotation annotation : annotations) &#123;</span><br><span class="line">                    stringBuilder.append(annotation).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(stringBuilder.toString());</span><br><span class="line">            System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Annotation &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">InterFace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Person</span> &amp; <span class="title">InterFace</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getBounds --&gt; [class org.throwable.inherited.Main14$Person, interface org.throwable.inherited.Main14$InterFace]</span><br><span class="line">getGenericDeclaration  --&gt; <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main14</span>$<span class="title">Supper</span></span></span><br><span class="line"><span class="class"><span class="title">getName</span> --&gt; <span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">getAnnotatedBounds</span> --&gt;</span></span><br><span class="line"><span class="class"></span>===================</span><br><span class="line">getBounds --&gt; [interface org.throwable.inherited.Main14$Annotation]</span><br><span class="line">getGenericDeclaration  --&gt; <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main14</span>$<span class="title">Supper</span></span></span><br><span class="line"><span class="class"><span class="title">getName</span> --&gt; <span class="title">E</span></span></span><br><span class="line"><span class="class"><span class="title">getAnnotatedBounds</span> --&gt;</span></span><br><span class="line"><span class="class"></span>===================</span><br></pre></td></tr></table></figure>
<h3 id="WildcardType">WildcardType</h3>
<p>WildcardType用于表示通配符(?)类型的表达式的泛型参数，例如<code>&lt;? extends Number&gt;</code>等。根据WildcardType注释提示：现阶段通配符表达式仅仅接受一个上边界或者下边界，这个和定义类型变量时候可以指定多个上边界是不一样。但是为了保持扩展性，这里返回值类型写成了数组形式。实际上现在返回的数组的大小就是1。WildcardType接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WildcardType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getUpperBounds();</span><br><span class="line"></span><br><span class="line">    Type[] getLowerBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getUpperBounds()：获取泛型通配符的上限类型Type数组，实际上目前该数组只有一个元素，也就是说只能有一个上限类型。</li>
<li>Type[] getLowerBounds()：获取泛型通配符的下限类型Type数组，实际上目前该数组只有一个元素，也就是说只能有一个下限类型。</li>
</ul>
<p>举个关于WildcardType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main16</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Main16&gt; clazz = Main16<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"print"</span>.equals(method.getName())) &#123;</span><br><span class="line">                Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (Type type : genericParameterTypes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                        ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                        <span class="keyword">for</span> (Type actualType : actualTypeArguments) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (actualType <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">                                WildcardType wildcardType = (WildcardType) actualType;</span><br><span class="line">                                System.out.println(<span class="string">"WildcardType --&gt; "</span> + wildcardType + <span class="string">" getUpperBounds--&gt; "</span></span><br><span class="line">                                        + Arrays.toString(wildcardType.getUpperBounds()) + <span class="string">" getLowerBounds--&gt; "</span> + Arrays.toString(wildcardType.getLowerBounds()));</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Not WildcardType --&gt; "</span> + actualType);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;? extends Number&gt; list, Set&lt;? <span class="keyword">super</span> Person&gt; persons)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WildcardType --&gt; ? extends java.lang.Number getUpperBounds--&gt; [class java.lang.Number] getLowerBounds--&gt; []</span><br><span class="line">WildcardType --&gt; ? super org.throwable.inherited.Main16$Person getUpperBounds--&gt; [class java.lang.Object] getLowerBounds--&gt; [interface org.throwable.inherited.Main16$Person]</span><br></pre></td></tr></table></figure>
<p>这里注意的是<code>List&lt;? extends Number&gt; list</code>这个参数整体来看是ParameterizedType类型，剥掉第一次List之后的<code>? extends Number</code>是WildcardType类型。</p>
<h3 id="GenericArrayType">GenericArrayType</h3>
<p>GenericArrayType，generic array type，也就是泛型数组，也就是元素类型为泛型类型的数组实现了该接口。它要求元素的类型是ParameterizedType或TypeVariable(实际中发现元素是GenericArrayType也是允许的)。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] listArray; <span class="comment">//是GenericArrayType,元素是List&lt;String&gt;类型，也就是ParameterizedType类型</span></span><br><span class="line">T[] tArray; <span class="comment">//是GenericArrayType,元素是T类型，也就是TypeVariable类型</span></span><br><span class="line"></span><br><span class="line">Person[] persons; <span class="comment">//不是GenericArrayType</span></span><br><span class="line">List&lt;String&gt; strings; <span class="comment">//不是GenericArrayType</span></span><br></pre></td></tr></table></figure>
<p>GenericArrayType接口的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericArrayType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type getGenericComponentType()：获取泛型数组中元素的类型。注意无论从左向右有几个<code>[]</code>并列，这个方法仅仅脱去最右边的<code>[]</code>之后剩下的内容就作为这个方法的返回值。</li>
</ul>
<p>举个关于GenericArrayType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main15</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method[] methods = Main15<span class="class">.<span class="keyword">class</span>.<span class="title">getMethods</span>()</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"method"</span>.equals(method.getName())) &#123;</span><br><span class="line">                Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (Type type : genericParameterTypes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"GenericArrayType --&gt; "</span> + type + <span class="string">" getGenericComponentType --&gt; "</span></span><br><span class="line">                                + ((GenericArrayType) type).getGenericComponentType());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Not GenericArrayType --&gt; "</span> + type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String[] strings, List&lt;String&gt; ls, List&lt;String&gt;[] lsa, T[] ts, List&lt;T&gt;[] tla, T[][] tts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Not GenericArrayType --&gt; class [Ljava.lang.String;</span><br><span class="line">Not GenericArrayType --&gt; java.util.List&lt;java.lang.String&gt;</span><br><span class="line">GenericArrayType --&gt; java.util.List&lt;java.lang.String&gt;[] getGenericComponentType --&gt; java.util.List&lt;java.lang.String&gt;</span><br><span class="line">GenericArrayType --&gt; T[] getGenericComponentType --&gt; T</span><br><span class="line">GenericArrayType --&gt; java.util.List&lt;T&gt;[] getGenericComponentType --&gt; java.util.List&lt;T&gt;</span><br><span class="line">GenericArrayType --&gt; T[][] getGenericComponentType --&gt; T[]</span><br></pre></td></tr></table></figure>
<p>这里分析一下：</p>
<ul>
<li><code>String[] strings</code>：数组是Class类型。</li>
<li><code>List&lt;String&gt; ls</code>：列表是ParameterizedType类型。</li>
<li><code>List&lt;String&gt;[] lsa</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是<code>java.util.List&lt;java.lang.String&gt;</code>，也就是数组元素是ParameterizedType类型。</li>
<li><code>T[] ts</code>：s数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是T，也就是数组元素是TypeVariable类型。</li>
<li><code>List&lt;T&gt;[] tla</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是<code>java.util.List&lt;T&gt;</code>，也就是数组元素是ParameterizedType类型。</li>
<li><code>T[][] tts</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型T[]，也就是数组元素是GenericArrayType类型。</li>
</ul>
<h2 id="泛型的约束">泛型的约束</h2>
<p>使用Java泛型的时候需要考虑一些限制，这些限制大多数是由泛型类型擦除引起的。</p>
<ul>
<li>1、不能用基本类型实例化类型参数，也就是8种基本类型不能作为泛型参数，例如<code>Pair&lt;int&gt;</code>是非法的，会导致编译错误，而<code>Pair&lt;Integer&gt;</code>是合法的。</li>
<li>2、运行时的类型查询只能适用于原始类型(非参数化类型)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的两种做法是错误的</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;)  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair)  <span class="comment">//Right</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3、不能创建参数化类型的数组，例如<code>Pair&lt;String&gt;[] arr = new Pair&lt;String&gt;[10]</code>是非法的。</li>
<li>4、不能实例化类型变量或者类型变量数组，例如<code>T t = new T()</code>或者<code>T[] arr = new T[10]</code>都是非法的。</li>
<li>5、Varargs警告，这是因为第4点原因导致的，一般会发生在泛型类型变量作为可变参数的情况，例如<code>public static &lt;T&gt; addAll(Collection&lt;T&gt; con,T ... ts)</code>，第二个参数实际上就是泛型类型变量数组，但是这种情况是合法的，不过会受到编译器的警告，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解或者<code>@SafeVarargs</code>注解标注该方法以消除警告。</li>
<li>6、不能在静态域或者方法中引用类型变量，例如<code>private static T singleInstance;</code>这样是非法的。</li>
<li>7、不能抛出或者抛出或者捕获泛型类型变量，但是如果在异常规范中使用泛型类型变量则是允许的，举两个例子仔细品味一下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(T t)&#123;  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable e)&#123;  </span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8、通过使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解可以消除Java类型系统的部分基本限制，一般使用在强制转换原始类型为泛型类型(只是在编译层面告知编译器)的情况，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加此注解会收到编译器的警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有泛型的继承规则和通配符规则(可以看下前面介绍的Type的子类型)等等，这里不详细展开。</p>
<h2 id="再议泛型数组的问题">再议泛型数组的问题</h2>
<p>在Java泛型约束中，无法实例化参数化类型数组，例如<code>Pair&lt;Integer&gt;[] table = new Pair&lt;Integer&gt;[10];</code>是非法的。根本原因在于泛型类型的擦除和数组会记录元素类型的特性。举个例子，假设可以实例化参数化类型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>上面的参数化类型数组在泛型擦除之后，数组实例table的类型为<code>Pair[]</code>，数组元素类型为<code>Pair</code>，可以强转为<code>Object[]</code>类型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArray = table;</span><br></pre></td></tr></table></figure>
<p>基于泛型擦除，数组objArray可以任意赋值<code>Pair&lt;AnyType&gt;</code>的泛型化实例，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objArray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Integer&gt;();</span><br><span class="line">objArray[<span class="number">1</span>] = <span class="keyword">new</span> Pair&lt;Long&gt;();</span><br><span class="line">objArray[<span class="number">2</span>] = <span class="keyword">new</span> Pair&lt;String&gt;();</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><strong>这样子能够通过数组存储元素的检查，后续操作数组元素随时会出现ClassCastException。基于以上的原因，Java从编译层面直接拒绝创建参数化类型数组</strong>。</p>
<p>另外，类型变量数组的实例化也是非法的，如<code>T[] tt = new T[10];</code>，这是因为类型变量仅仅是编译期的字面量，其实和Java的类型体系是不相关的。</p>
<p>但是要注意一点：<strong>参数化类型数组和类型变量数组可以作为方法入参变量或者类的成员变量</strong>。例如下面的做法是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Pair&lt;T&gt;[] attr;</span><br><span class="line">	<span class="keyword">private</span> T[] ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Pair&lt;T&gt; pair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T[] ts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一点，可以查看前一篇文章，其实<strong>可以使用反射创建泛型数组</strong>。</p>
<h2 id="无限定通配符">无限定通配符</h2>
<p>泛型中支持无限定通配符<code>&lt;?&gt;</code>，使用无限定通配符类型的实例有以下限制：</p>
<ul>
<li>所有的Getter方法只能返回Object类型的值。</li>
<li>所有的Setter方法只能赋值null，其他类型的值的设置都是非法的。</li>
</ul>
<p>无限定通配符类型可以看做原始类型的一个影子类型，它屏蔽了除了null之外的设值操作，所有获取值的方法只能返回Object类型结果，这种特性使得通过无限定通配符类型进行一些简单的操作变得十分方便，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果反射用得比较熟的话，<code>java.lang.Class</code>也有类似的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = ...;</span><br><span class="line">Object instance = <span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="桥方法-Bridge-Method">桥方法(Bridge Method)</h2>
<p>先说明一下什么是桥方法，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Supper</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类<code>Supper&lt;T&gt;</code>在泛型擦除后原始类型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Object t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类<code>Sub</code>虽然实现了父类<code>Supper</code>，但是它只实现了<code>void method(Integer value)</code>而没有实现父类中的<code>void method(Object t)</code>，这个时候，编译期编译器会为子类<code>Sub</code>创建此方法，也就是子类<code>Sub</code>会变成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Supper</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.method((Integer) value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你直接这样编写一个子类<code>Sub</code>是会编译报错，而上面这里编译器生成的<code>void method(Object value)</code>方法就是桥方法。可以用反射验证一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Method[] declaredMethods = Sub<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethods</span>()</span>;</span><br><span class="line">	List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">		<span class="keyword">if</span> (method.getName().equals(<span class="string">"method"</span>)) &#123;</span><br><span class="line">			methods.add(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">		System.out.println(String.format(<span class="string">"name=%s,paramTypes=%s,isBridge=%s"</span>, method.getName(),</span><br><span class="line">		Arrays.toString(method.getParameterTypes()), method.isBridge()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">name=method,paramTypes=[class java.lang.Integer],isBridge=false</span><br><span class="line">name=method,paramTypes=[class java.lang.Object],isBridge=true</span><br></pre></td></tr></table></figure>
<p>桥方法的定义比较模糊，因此这里只考虑它出现的情况，不做盲目的定义。不单只是子类实现带有泛型参数的父类会产生桥方法，还有一种比较常见的情况是在方法覆盖的时候指定一个更加&quot;严格的&quot;返回值类型的时候，也会产生桥方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Employee implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里实际上，Employee覆盖了Object的clone()方法，因此实际上编译后Employee如下</span></span><br><span class="line"><span class="keyword">public</span> Employee implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是桥方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为：</p>
<ul>
<li>编译的时候Java的方法签名是方法名称加上方法参数类型列表，也就是方法名和参数类型列表确定一个方法的签名(这样就可以很好理解方法重载，还有Java中的参数都是形参，所以参数名称没有实质意义，只有参数类型才是有意义的)。</li>
<li>Java虚拟机定义一个方法的签名是由方法名称、方法返回值类型和方法参数类型列表组成，所以JVM认为返回值类型不同，而方法名称和参数类型列表一致的方法是不相同的方法。</li>
</ul>
<p>仔细看，其实两种情况都是由于继承才导致桥方法出现。</p>
<h2 id="JDK中操作泛型的API">JDK中操作泛型的API</h2>
<p>这里列举一下JDK中笔者所知的操作泛型的相关API(可以会有遗漏)，这些API主要和反射操作相关：</p>
<p><strong><code>java.lang.Class</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericInterfaces()</td>
<td style="text-align:center">返回类实例的接口的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericSuperclass()</td>
<td style="text-align:center">返回类实例的父类的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Constructor</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">返回构造器的异常的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回构造器的方法参数的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Method</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">返回方法的异常的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回方法参数的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericReturnType()</td>
<td style="text-align:center">返回方法返回值的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Field</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type getGenericType()</td>
<td style="text-align:center">返回属性的泛型类型</td>
</tr>
</tbody>
</table>
<p>如果在使用上面的方法得到的返回值和期望的返回值不相同，请加深对泛型类型擦除的认识。</p>
<h2 id="小结">小结</h2>
<p>参考资料：</p>
<p>个人认为，泛型其实是JDK迭代过程中妥协和兼容历史的产物，它是一种没有实现的泛型，当然，提供编译期类型安全这一点可以让开发者避免类型转换出现人为错误，也就是说：Java中的泛型使得程序或者代码的可读性和安全性提高，这是它的最大优势。</p>
<ul>
<li>《Java核心技术卷I-基础知识》</li>
<li><a href="https://en.wikipedia.org/wiki/Generics_in_Java" target="_blank" rel="noopener">维基百科-Generics in Java</a></li>
</ul>
<p>(本文完 e-20181204-c-3d r-20181205)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/02/java-reflection-array-enum/">
      深入分析Java反射(二)-数组和枚举
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月2日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：10分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-04T23:42:12+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月4日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(二)-数组和枚举</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射中可能用到的两个比较特殊的类型，数组和枚举，分别对应<code>java.lang.reflect.Array</code>和<code>java.lang.Enum</code>，后者其实并不是反射类库包中的类，但是反射的基础类库里面有使用枚举类型的方法。</p>
<h2 id="数组类型">数组类型</h2>
<p>数组是一种包含固定数量的相同类型组件(Component)的引用类型对象，也就是说数组的长度是不可变，它的每个元素都是相同类型的。创建数组实例需要定义数组的长度和组件的类型。<strong>数组是由Java虚拟机实现(这一点很重要，这就是为什么JDK类库中没有数组对应的类型的原因，array也不是Java中的保留关键字，操作数组的底层方法都是native方法)</strong>，数组类型只有继承自<code>java.lang.Object</code>的方法，数组的<code>length</code>方法实际上并不属于数组类型的一部分，数组的<code>length</code>方法其实最终调用的是<code>java.lang.reflect.Array#getLength()</code>，注意到这个方法是native方法。<code>java.lang.reflect.Array</code>是基于反射操作数组的核心类。</p>
<p>使用非反射方式创建数组实例的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fully_qualified_class_name[] variable_name  = &#123;val1，val2，val3，...&#125;;</span><br><span class="line"></span><br><span class="line">fully_qualified_class_name[] variable_name = <span class="keyword">new</span> fully_qualified_class_name[$&#123;fix_length&#125;];</span><br><span class="line"></span><br><span class="line">例如：<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>使用反射方式就是使用<code>java.lang.reflect.Array</code>中的相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">Object o = Array.newInstance(c, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    String v = cVals[i];</span><br><span class="line">    Constructor ctor = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Object val = ctor.newInstance(v);</span><br><span class="line">    Array.set(o, i, val);</span><br><span class="line">&#125;</span><br><span class="line">Object[] oo = (Object[]) o;</span><br></pre></td></tr></table></figure>
<p>下面列举一下<code>java.lang.reflect.Array</code>中的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static Object newInstance(Class&lt;?&gt; componentType, int length)</td>
<td style="text-align:center">指定组件类型和数组固定长度创建一维数组</td>
</tr>
<tr>
<td style="text-align:center">static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)</td>
<td style="text-align:center">指定组件类型和多个固定长度创建多维数组，维度的最大值为255</td>
</tr>
<tr>
<td style="text-align:center">static native int getLength(Object array)</td>
<td style="text-align:center">获取数组长度</td>
</tr>
<tr>
<td style="text-align:center">static native Object get(Object array, int index)</td>
<td style="text-align:center">通过下标访问数组元素</td>
</tr>
<tr>
<td style="text-align:center">static native void set(Object array, int index, Object value)</td>
<td style="text-align:center">通过下标设置数组元素</td>
</tr>
</tbody>
</table>
<p>这里省略了一部分对于<code>Int</code>、<code>Boolean</code>等原始类型的Setter和Getter方法。</p>
<p>在<code>java.lang.Class</code>和数组相关的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">native boolean isArray()</td>
<td style="text-align:center">判断类型是否数组类型</td>
</tr>
<tr>
<td style="text-align:center">Class&lt;?&gt; getComponentType()</td>
<td style="text-align:center">如果是数组类型则返回其组件类型，否则返回null</td>
</tr>
</tbody>
</table>
<p>这里举个例子加深下印象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCreationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这个是我们创建的最终目标数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String R = <span class="string">"java.math.BigInteger[] bi = &#123;123,234,345&#125;"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] S = <span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>, <span class="string">"234"</span>, <span class="string">"345"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;BigInteger&gt; componentType = BigInteger<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Object arrayObject = Array.newInstance(componentType, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">			String each = S[i];</span><br><span class="line">			Constructor&lt;BigInteger&gt; constructor = componentType.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			BigInteger value = constructor.newInstance(each);</span><br><span class="line">			Array.set(arrayObject, i, value);</span><br><span class="line">		&#125;</span><br><span class="line">		Object[] result = (Object[]) arrayObject;</span><br><span class="line">		System.out.println(String.format(<span class="string">"%s[] = %s"</span>, componentType, Arrays.toString(result)));</span><br><span class="line">		<span class="keyword">int</span> length = Array.getLength(arrayObject);</span><br><span class="line">		System.out.println(<span class="string">"Length = "</span> + length);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			System.out.println(String.format(<span class="string">"index = %d,value = %s"</span>, i, Array.get(arrayObject, i)));</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; arrayObjectClass = arrayObject.getClass();</span><br><span class="line">		System.out.println(<span class="string">"Is array type:"</span> + arrayObjectClass.isArray());</span><br><span class="line">		System.out.println(<span class="string">"Component type:"</span> + arrayObjectClass.getComponentType());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class java.math.BigInteger[] = [123, 234, 345]</span><br><span class="line">Length = <span class="number">3</span></span><br><span class="line">index = <span class="number">0</span>,value = <span class="number">123</span></span><br><span class="line">index = <span class="number">1</span>,value = <span class="number">234</span></span><br><span class="line">index = <span class="number">2</span>,value = <span class="number">345</span></span><br><span class="line">Is array type:<span class="keyword">true</span></span><br><span class="line">Component type:<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">math</span>.<span class="title">BigInteger</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>java.lang.reflect.Array</code>中的Setter和Getter方法如果越界操作数组元素，会抛出<code>ArrayIndexOutOfBoundsException</code>，通过Setter设置和数组初始化时候的组件类型不一致的元素会抛出<code>IllegalArgumentException</code>。</p>
<h3 id="细议数组类型">细议数组类型</h3>
<p>前面说到了数组类型的一些基础特性，这里补充一些比较高级的使用方法。</p>
<p><strong>创建特定元素类型的数组：</strong></p>
<p>因为Java泛型擦除的问题，实际上我们使用<code>Array#newInstance</code>方法只能得到一个Object类型的结果实例，其实这个结果实例的类型就是<code>ComponentType[]</code>，这里只是返回了它的父类(Object)类型实例，因此我们可以直接强转，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = (String[]) Array.newInstance(String<span class="class">.<span class="keyword">class</span>, 3)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>获取数组类型：</strong></p>
<p>在非反射方式下，我们可以通过<code>数组实例.class</code>通过class字面量直接获取数组类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = String[]<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
<p>反射条件下，可以通过<code>Class.forName()</code>获取数组类型，但是调用此方法的时候有个限制，类名必须使用JVM可以识别的签名形式，就是<code>[L${ComponentType};</code>，注意<code>Class.forName()</code>无法获取原始类型(如int、boolean)的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能漏了左边的[L和右边的;</span></span><br><span class="line">Class stringArrayClass = Class.forName(<span class="string">"[Ljava.lang.String;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这样做会抛出ClassNotFoundException</span></span><br><span class="line">Class intClass1 = Class.forName(<span class="string">"I"</span>);</span><br><span class="line">Class intClass2 = Class.forName(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>获取数组元素(组件)类型：</strong></p>
<p>目前获取数组组件类型只能通过数组类型实例去调用<code>Class#getComponentType()</code>。</p>
<h2 id="枚举类型">枚举类型</h2>
<p>枚举是一种语言结构(Language Construct)，用于定义可以使用一组固定的名值对表示的类型安全的枚举(原文是：An enum is a language construct that is used to define type-safe enumerations which can be used when a fixed set of named values is desired)。所有枚举都继承自<code>java.lang.Enum</code>。枚举可以包含一个或者多个枚举常量，这些枚举常量都是该枚举的实例。枚举的声明其实和一个普通的Class的声明相似，因为它可以包含字段、方法和构造函数之类的成员。</p>
<p>因为枚举就是普通的Java类，因此反射相关类库中并没有添加一个<code>java.lang.reflect.Enum</code>类型，反射中的API和枚举相关的有：</p>
<ul>
<li><code>boolean java.lang.Class#isEnum()</code>：判断类型是否枚举类型。</li>
<li><code>T[] java.lang.Class#getEnumConstants()</code>：获取类型中所有的枚举常量。</li>
<li><code>boolean java.lang.reflect.Field#isEnumConstant()</code>：判断属性是否枚举类型。</li>
</ul>
<p>如果实例中的成员属性为枚举，那么枚举的反射操作实际上就是<code>java.lang.reflect.Field</code>的相关操作。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> Color &#123;</span><br><span class="line">		RED, BLACK, BLUE</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Color color = Color.BLACK;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;Color&gt; colorClass = Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		System.out.println(<span class="string">"Color class is enum:"</span> + colorClass.isEnum());</span><br><span class="line">		System.out.println(<span class="string">"Color values:"</span> + Arrays.toString(colorClass.getEnumConstants()));</span><br><span class="line">		ColorHolder colorHolder = <span class="keyword">new</span> ColorHolder();</span><br><span class="line">		Class&lt;ColorHolder&gt; holderClass = ColorHolder<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Field field = holderClass.getDeclaredField(<span class="string">"color"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(<span class="string">"Old color:"</span> + field.get(colorHolder));</span><br><span class="line">		field.set(colorHolder, Color.RED);</span><br><span class="line">		System.out.println(<span class="string">"New color:"</span> + field.get(colorHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Color class is enum:true</span><br><span class="line">Color values:[RED, BLACK, BLUE]</span><br><span class="line">Old color:BLACK</span><br><span class="line">New color:RED</span><br></pre></td></tr></table></figure>
<p>之前写过一篇文章《JDK中枚举的底层实现》，从枚举类的字节码翻译出类的代码逻辑，这里翻出来那个例子(手机操作系统枚举)说一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PhoneOsEnum &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 安卓</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ANDROID(<span class="number">1</span>, <span class="string">"android"</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ios</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	IOS(<span class="number">2</span>, <span class="string">"ios"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer type;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line"></span><br><span class="line">	PhoneOsEnum(Integer type, String typeName) &#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> typeName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是我们使用Java的关于枚举的语法创建出来的枚举类型，是编译前我们看到的Java类文件，实际上，编译完成之后，枚举类型会变成一个普通的Java类，它有以下特点：</p>
<ul>
<li>1、枚举类型会变成一个普通Java类，这个Java类会继承<code>java.lang.Enum</code>，并且把自身类型作为泛型参数类型，构造函数中必定包含name(字符串类型String)、ordinal(整型int)参数，因为父类<code>java.lang.Enum</code>的构造要求传入这两个参数。</li>
<li>2、所有的枚举成员属性都变成<code>static final</code>修饰的在第1步中提到的Java类的实例，属性的名称和原来枚举的名字一致，实例在静态代码块中创建。</li>
<li>3、新增了一个<code>static final</code>修饰的第1步中提到的Java类的数组实例，名称为<code>$VALUES</code>，此数组在静态代码块中创建，基于此数组还新增了一个静态方法<code>values()</code>，此方法就是直接返回数组的克隆。</li>
</ul>
<p>也就是上面提到的<code>PhoneOsEnum</code>在编译完成之后会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneOsEnumeration</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">PhoneOsEnumeration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PhoneOsEnumeration</span><span class="params">(String name, <span class="keyword">int</span> ordinal, Integer type, String typeName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, ordinal);</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> PhoneOsEnumeration[] values() &#123;</span><br><span class="line">		<span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneOsEnumeration <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Enum.valueOf(PhoneOsEnumeration<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer type;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration ANDROID;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration IOS;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration[] $VALUES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		ANDROID = <span class="keyword">new</span> PhoneOsEnumeration(<span class="string">"ANDROID"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"android"</span>);</span><br><span class="line">		IOS = <span class="keyword">new</span> PhoneOsEnumeration(<span class="string">"IOS"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"ios"</span>);</span><br><span class="line">		$VALUES = <span class="keyword">new</span> PhoneOsEnumeration[]&#123;ANDROID, IOS&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，如果你直接编写一个Java类去继承<code>java.lang.Enum</code>会编译报错，也就是Java希望把枚举的行为和特性交由自身控制而不是开发者去控制，从编译层面控制枚举的类型安全。如果细心一点会发现，枚举中<code>valueOf(String name)</code>也是由<code>java.lang.Class</code>提供的，追溯到最里层是<code>T[] java.lang.Class#getEnumConstants()</code>方法，其实有可能在构造<code>$VALUES</code>属性的时候也是用到这个方法，这一点就没有深究下去，编译层面的东西可能会牵涉很多方面的知识，还没有到达那种水平。</p>
<h2 id="小结">小结</h2>
<p>数组和枚举在Java中的使用频率也是比较高的，特别是算法或者框架中，本文尝试从反射角度介绍这两个类型的使用方式，掌握它们对数组或者枚举的使用有很大的帮助。</p>
<p>(本文完 e-2018122-c-1-d r-2018124-c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/02/java-reflection-lib/">
      深入分析Java反射(一)-核心类库和方法
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月2日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：8.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：33分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-02T12:24:09+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月2日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(一)-核心类库和方法</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射的基本概念以及核心类<code>Class</code>、<code>Constructor</code>、<code>Method</code>、<code>Field</code>、<code>Parameter</code>的常用方法。</p>
<p>本文极长，请准备一个使自己舒服的姿势阅读。</p>
<h2 id="什么是反射">什么是反射</h2>
<p>反射(Reflection)是一种可以在运行时检查和动态调用类、构造、方法、属性等等的编程语言的能力，甚至可以不需要在编译期感知类的名称、方法的名称等等。<strong><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Oracle关于Java反射的官方教程</a>中指出反射是由应用程序使用，用于检查或修改在Java虚拟机中运行的应用程序的运行时行为，这是一个相对高级的功能，需要由掌握Java语言基础知识的开发者使用</strong>。</p>
<p>反射的优点有很多，前面提到可以检查或修改应用程序的运行时行为、抑制修饰符限制直接访问私有属性等等，这里主要列举一下它的缺点：</p>
<ul>
<li>性能开销：由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能低于非反射操作，应避免在性能敏感应用程序中频繁调用反射操作代码片段。</li>
<li>安全限制：反射需要运行时权限，不能在安全管理器(security manager)下进行反射操作。</li>
<li>代码可移植性：反射代码打破了抽象，反射的类库有可能随着平台(JDK)升级发生改变，反射代码中允许执行非反射代码的逻辑例如允许访问私有字段，这些问题都有可能影响到代码的可移植性。</li>
</ul>
<p>JDK中对和反射相关的类库集中在<code>java.lang.reflect</code>包和<code>java.lang</code>包中，<code>java.lang.reflect</code>包和<code>java.lang</code>包是开发者可以直接使用的，部分<code>java.lang.reflect</code>包中接口的实现类存放在<code>sun.reflect</code>包中，一般情况下<code>sun</code>包下的类库有可能跟随平台升级发生改变，一般尽量少用，否则有可能因为JDK升级导致原来的代码无法正常运行。还有部分反射相关的类库存放在<code>jdk.internal.reflect</code>包中，这个包是JDK内部使用的包，一般也不建议滥用其中的类库。可以理解为<code>java.lang.reflect</code>包和<code>java.lang</code>包中的类库就是面向开发者的类库。</p>
<h2 id="图解反射核心类的体系">图解反射核心类的体系</h2>
<p><code>java.lang.reflect</code>包反射核心类有核心类<code>Class</code>、<code>Constructor</code>、<code>Method</code>、<code>Field</code>、<code>Parameter</code>，它们的基础体系如下：</p>
<p><code>java.lang.Class</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-1.png" alt="j-r-1.png"></p>
<p><code>java.lang.reflect.Constructor</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-2.png" alt="j-r-2.png"></p>
<p><code>java.lang.reflect.Method</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-3.png" alt="j-r-3.png"></p>
<p><code>java.lang.reflect.Field</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-4.png" alt="j-r-4.png"></p>
<p><code>java.lang.reflect.Parameter</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-5.png" alt="j-r-5.png"></p>
<p>由它们的类继承图可以看出：</p>
<ul>
<li>Class、Constructor、Method、Field、Parameter共有的父接口是AnnotatedElement。</li>
<li>Constructor、Method、Field共有的父类是AnnotatedElement、AccessibleObject和Member。</li>
<li>Constructor、Method共有的父类是AnnotatedElement、AccessibleObject、Member、GenericDeclaration和Executable。</li>
</ul>
<p>下面会先简单分析<code>AnnotatedElement</code>、<code>AccessibleObject</code>、<code>Member</code>、<code>GenericDeclaration</code>、<code>Executable</code>几个类提供的功能，然后重点分析<code>Class</code>、<code>Constructor</code>、<code>Method</code>、<code>Field</code>、<code>Parameter</code>的常用方法。</p>
<p>这里先说一个规律，在Class中，<code>getXXX()</code>方法和<code>getDeclearedXXX()</code>方法有所区别。注解类型<code>Annotation</code>的操作方法例外，因为基于注解的修饰符必定是public的：</p>
<ul>
<li>getDeclaredMethod(s)：返回类或接口声明的所有方法，包括公共、保护、默认(包)访问和私有方法，但不包括继承的方法。对于获取Method对象，<code>Method[] methods = clazz.getDeclaredMethods();</code>返回的是clazz本类所有修饰符(public、default、private、protected)的方法数组，但是不包含继承而来的方法。</li>
<li>getMethod(s):返回某个类的所有公用(public)方法包括其继承类的公用方法，当然也包括它所实现接口的方法。对于获取Method对象，<code>Method[] methods = clazz.getMethods();</code>表示返回clazz的父类、父类接口、本类、本类接口中的全部修饰符为public的方法数组。</li>
<li>getDeclaredField(s)和getField(s)、getDeclaredConstructor(s)和getConstructor(s)同上。</li>
<li>getDeclaredAnnotation(s)：返回直接存在于此元素上的所有注解，此方法将忽略继承的注解，准确来说就是忽略@Inherited注解的作用。</li>
<li>getAnnotation(s)：返回此元素上存在的所有注解，包括继承的所有注解。</li>
</ul>
<p>如果想获取一个类的所有修饰符的方法，包括所有父类中的方法，那么建议递归调用<code>getDeclaredMethods()</code>(所谓递归调用就是一直追溯目标类的父类递归调用<code>getDeclaredMethods()</code>方法直到父类为Object类型，这个思路可以参考Spring框架中的相关工具类)。获取一个类的所有Field、Constructor也可以类似操作，可以参考或者直接使用Spring中的工具类ReflectionUtils的相关方法。@Inherited元注解是一个标记注解，@Inherited阐述了某个被标注的Annotation类型是可以被继承的，详细的在分析AnnotatedElement的时候再展开。</p>
<h2 id="Type接口">Type接口</h2>
<p><code>java.lang.reflect.Type</code>接口是Java中所有类型的共同父类，这些类型包括原始类型、泛型类型、数组类型、类型变量和基本类型，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AnnotatedElement接口">AnnotatedElement接口</h2>
<p><code>AnnotatedElement</code>是一个接口，它定义的方法主要和注解操作相关，例如用于判断注解的存在性和获取注解等等。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean isAnnotationPresent(<code>Class&lt;? extends Annotation&gt;</code> annotationClass)</td>
<td style="text-align:center">判断指定的注解类型在当前的实例上是否存在</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T getAnnotation(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">获取当前实例上指定注解类型的注解实例，不存在时返回null</td>
</tr>
<tr>
<td style="text-align:center">Annotation[] getAnnotations()</td>
<td style="text-align:center">获取当前实例上所有注解实例，包括继承获得的注解，不存在则返回长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T getDeclaredAnnotation(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">获取当前实例上指定注解类型的注解实例，不包括继承获得的注解，不存在则返回长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T[] getDeclaredAnnotations(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">获取当前实例上所有的注解实例，不包括继承获得的注解，不存在则返回长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T[] getDeclaredAnnotationsByType(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">在不使用@Repeatable的时候，功能和getDeclaredAnnotations方法一致，如果使用了@Repeatable，则合并解析@Repeatable后的结果</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T[] getAnnotationsByType(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">如果指定annotationClass注解类型可继承(使用了@Inherited)，那么递归调用getDeclaredAnnotationsByType</td>
</tr>
</tbody>
</table>
<p>举个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"-----getAnnotations-----"</span>);</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotation--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation declaredSupperAnnotation = clazz.getDeclaredAnnotation(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(declaredSupperAnnotation);</span><br><span class="line">        System.out.println(<span class="string">"-----getAnnotation--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation supperAnnotation = clazz.getAnnotation(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(supperAnnotation);</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotation--&gt;SubAnnotation-----"</span>);</span><br><span class="line">        SubAnnotation declaredSubAnnotation = clazz.getDeclaredAnnotation(SubAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(declaredSubAnnotation);</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotationsByType--&gt;SubAnnotation-----"</span>);</span><br><span class="line">        SubAnnotation[] declaredSubAnnotationsByType = clazz.getDeclaredAnnotationsByType(SubAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (SubAnnotation subAnnotation : declaredSubAnnotationsByType) &#123;</span><br><span class="line">            System.out.println(subAnnotation);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotationsByType--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation[] declaredSupperAnnotationsByType = clazz.getDeclaredAnnotationsByType(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (SupperAnnotation supperAnnotation1 : declaredSupperAnnotationsByType) &#123;</span><br><span class="line">            System.out.println(supperAnnotation1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----getAnnotationsByType--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation[] supperAnnotationsByType = clazz.getAnnotationsByType(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (SupperAnnotation supperAnnotation2 : supperAnnotationsByType) &#123;</span><br><span class="line">            System.out.println(supperAnnotation2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SupperAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@interface</span> SupperAnnotation &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "SupperAnnotation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@interface</span> SubAnnotation &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "SubAnnotation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----getAnnotations-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SupperAnnotation(value=SupperAnnotation)</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SubAnnotation(value=SubAnnotation)</span><br><span class="line">-----getDeclaredAnnotation--&gt;SupperAnnotation-----</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">-----getAnnotation--&gt;SupperAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SupperAnnotation(value=SupperAnnotation)</span><br><span class="line">-----getDeclaredAnnotation--&gt;SubAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SubAnnotation(value=SubAnnotation)</span><br><span class="line">-----getDeclaredAnnotationsByType--&gt;SubAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SubAnnotation(value=SubAnnotation)</span><br><span class="line">-----getDeclaredAnnotationsByType--&gt;SupperAnnotation-----</span><br><span class="line">-----getAnnotationsByType--&gt;SupperAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SupperAnnotation(value=SupperAnnotation)</span><br></pre></td></tr></table></figure>
<p>可以尝试注释掉@Inherited再运行一次，对比一下结果。如果注释掉@Inherited，从Sub这个类永远无法获取到它的父类Supper中的@SupperAnnotation。Class、Constructor、Method、Field、Parameter都实现了AnnotatedElement接口，所以它们都具备操作注解的功能。</p>
<h2 id="Member接口">Member接口</h2>
<p>Member接口注解提供成员属性的一些描述，主要提供的方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getDeclaringClass()</td>
<td style="text-align:center">获取声明的Class对象，也就是获取当前Member实例的来源Class对象</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">获取实例的名称，对于Constructor返回全类名，对于Method返回方法名，对于Field返回属性名</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">获取实例的修饰符</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">是否合成的</td>
</tr>
</tbody>
</table>
<p>这些方法里面除了<code>isSynthetic()</code>都比较好理解。synthetic总的来说，是由编译器引入的字段、方法、类或其他结构，主要用于JVM内部使用，为了遵循某些规范而作的一些小技巧从而绕过这些规范，有点作弊的感觉，只不过是由编译器光明正大为之，一般开发者是没有权限的(但事实上有时候还是能被利用到的)。下面这个例子参考自<a href="https://blog.csdn.net/a327369238/article/details/52608805" target="_blank" rel="noopener">synthetic Java合成类型</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSynthetic</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println (name + <span class="string">" : "</span> + Class.forName (name).isSynthetic ());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException exc) &#123;</span><br><span class="line">            exc.printStackTrace (System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner ();</span><br><span class="line">        checkSynthetic (<span class="string">"com.fcc.test.Main"</span>);</span><br><span class="line">        checkSynthetic (<span class="string">"com.fcc.test.Main$Inner"</span>);</span><br><span class="line">        checkSynthetic (<span class="string">"com.fcc.test.Main$1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">com.fcc.test.Main : <span class="keyword">false</span></span><br><span class="line">com.fcc.test.Main$Inner : <span class="keyword">false</span></span><br><span class="line">com.fcc.test.Main$<span class="number">1</span> : <span class="keyword">true</span></span><br><span class="line"><span class="comment">//编译结果，生成三个class文件: Main.class/Main$Inner/Main$1.class</span></span><br><span class="line"><span class="comment">// $FF: synthetic class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>$1 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Inner这个内部类是私有的，私有内部类。拥有内部类的类编译后内外部类两者没有关系，那么私有内部类编译后默认是没有对外构造器的(如果以上代码中在Inner手动给一个public的构造器，<code>Main$1</code>是不会出现的)，但是我们又知道，外部类是可以引用内部类的，那么编译后，又是两个毫无关系的类，一个类没对外构造器，但另一个类确实是有对这个类的实例对象权限(这里就是重点，内部类哪怕没有public构造器，外部类都有实例化内部类对象的权限)的，这种情况下编译器就会生成一个合成类，也就是<code>Main$1</code>，一个什么也没有的空类(是的，什么也没有，连构造器都没有)。但到这里，仍然不明白其实现原理是怎么样的，原先以为合成类是那个内部类的副本，外部类访问内部类，在编译器认为只是和合成类交互，只是合成类只有外部类有权限访问，但是事实上，不管内部类怎么变化，合成类只是一个空的类，有点类似标记作用(真正作用却是不得而知)。</p>
<h2 id="AccessibleObject类">AccessibleObject类</h2>
<p><code>AccessibleObject</code>是一个普通Java类，实现了AnnotatedElement接口，但是对应AnnotatedElement的非默认方法的实现都是直接抛异常，也就是AnnotatedElement的接口方法必须由AccessibleObject的子类去实现，个人认为AccessibleObject应该设计为抽象类。<code>AccessibleObject</code>在JDK1.1的时候已经存在，在JDK9的时候被改进过，添加了一些新的方法，下面列举一下常用的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">设置实例是否可以访问，如果设置为true，可以抑制修饰符，直接进行访问</td>
</tr>
<tr>
<td style="text-align:center">boolean isAccessible()</td>
<td style="text-align:center">返回实例是否可以访问，实际上这个值并不准确，它只有在setAccessible被调用的时候才会更新</td>
</tr>
<tr>
<td style="text-align:center">boolean trySetAccessible()</td>
<td style="text-align:center">功能类似于setAccessible(boolean flag)，返回值决定是否抑制修饰符成功</td>
</tr>
<tr>
<td style="text-align:center">static void setAccessible(AccessibleObject[] array, boolean flag)</td>
<td style="text-align:center">setAccessible(boolean flag)的批量操作方法</td>
</tr>
</tbody>
</table>
<p>一般而言，我们需要通过<code>getModifiers()</code>方法判断修饰符是否public，如果是非public，则需要调用<code>setAccessible(true)</code>进行修饰符抑制，否则会因为无权限访问会抛出异常。</p>
<h2 id="GenericDeclaration接口">GenericDeclaration接口</h2>
<p>GenericDeclaration接口继承自AnnotatedElement，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericDeclaration</span> <span class="keyword">extends</span> <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TypeVariable&lt;?&gt;[] getTypeParameters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了一个方法<code>getTypeParameters()</code>用于返回类型变量<code>TypeVariable</code>数组，这里的<code>TypeVariable</code>是类型变量，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得泛型的类型(Type)上限数组，若未明确声明上边界则默认为Object</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    <span class="comment">//获取声明该类型变量实体(即获得类、方法或构造器名)</span></span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得泛型参数的字面量名称，即K、V、E之类名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得泛型的注解类型(AnnotatedType)上限数组，若未明确声明上则为长度为0的空数组</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的文章介绍泛型的时候再展开。</p>
<h2 id="Executable类">Executable类</h2>
<p><code>Executable</code>是一个抽象类，它继承自<code>AccessibleObject</code>，实现了<code>Member</code>和<code>GenericDeclaration</code>接口。<code>Executable</code>的实现类是<code>Method</code>和<code>Constructor</code>，它的主要功能是从<code>Method</code>和<code>Constructor</code>抽取出两者可以共用的一些方法例如注解的操作，参数的操作等等，这里不详细展开。</p>
<h2 id="Modifier">Modifier</h2>
<p>Modifier主要提供一系列的静态方法，用于判断基于int类型的修饰符参数的具体类型，这个修饰符参数来源于Class、Constructor、Method、Field、Parameter的<code>getModifiers()</code>方法。下面介绍一下Modifier的主要方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static boolean isAbstract(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括abstract修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isFinal(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括final修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isInterface(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括interface修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isNative(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括native修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isPrivate(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括private修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isProtected(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括protected修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isPublic(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括public修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isStatic(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括static修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isStrict(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括strictfp修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isSynchronized(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括synchronized修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isTransient(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括transient修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isVolatile(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括volatile修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean toString(int mod)</td>
<td style="text-align:center">返回描述指定修饰符中的访问修饰符标志的字符串</td>
</tr>
</tbody>
</table>
<h2 id="Class类">Class类</h2>
<p><code>Class</code>实现了<code>Serializable</code>、<code>GenericDeclaration</code>、<code>Type</code>、<code>AnnotatedElement</code>接口，它提供了类型判断、类型实例化、获取方法列表、获取字段列表、获取父类泛型类型等方法。下面主要介绍一下它的主要方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> forName(String className)</td>
<td style="text-align:center">传入全类名创建Class实例</td>
</tr>
<tr>
<td style="text-align:center">T newInstance()</td>
<td style="text-align:center">通过当前的Class实例进行实例化对象，返回的就是新建的对象</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">native方法，返回当前Class的修饰符</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回类名称，虚拟机中类名表示</td>
</tr>
<tr>
<td style="text-align:center">String getCanonicalName()</td>
<td style="text-align:center">返回类名称，便于理解的类名表示</td>
</tr>
<tr>
<td style="text-align:center">String getSimpleName()</td>
<td style="text-align:center">返回类名称，源代码中给出的底层类的简单名称</td>
</tr>
<tr>
<td style="text-align:center">Package getPackage()</td>
<td style="text-align:center">返回类的包属性</td>
</tr>
<tr>
<td style="text-align:center">String getPackageName()</td>
<td style="text-align:center">返回类的包路径名称</td>
</tr>
<tr>
<td style="text-align:center">String toGenericString()</td>
<td style="text-align:center">返回描述此Class的字符串，其中包括类型参数的字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>TypeVariable&lt;Class&lt;T&gt;&gt;[]</code> getTypeParameters()</td>
<td style="text-align:center">获取类定义泛型的类型变量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getClasses()</td>
<td style="text-align:center">获取所有的修饰符为public的成员Class，包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getDeclaredClasses()</td>
<td style="text-align:center">获取本类所有修饰符的成员Class，不包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;[]</code> getConstructors()</td>
<td style="text-align:center">获取所有的修饰符为public的构造器，包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;T&gt;</code> getConstructor(<code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">获取参数类型匹配的修饰符为public的构造器，包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;[]</code> getDeclaredConstructors()</td>
<td style="text-align:center">获取本类所有修饰符的构造器，不包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;T&gt;[]</code> getDeclaredConstructor(<code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">获取本类参数类型匹配的所有修饰符的构造器，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method[] getMethods()</td>
<td style="text-align:center">获取本类所有的修饰符为public的方法列表，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method[] getDeclaredMethods()</td>
<td style="text-align:center">获取本类所有修饰符的方法列表，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method getMethod(String name, <code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">通过指定方法名和参数类型获取本类修饰符为public的方法，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method getDeclaredMethod(String name, <code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">通过指定方法名和参数类型获取本类不限修饰符的方法，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field[] getFields()</td>
<td style="text-align:center">获取本类所有的修饰符为public的属性列表，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field[] getDeclaredFields()</td>
<td style="text-align:center">获取本类所有修饰符的属性列表，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field getField(String name)</td>
<td style="text-align:center">通过指定属性名名获取本类修饰符为public的属性，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field getDeclaredField(String name)</td>
<td style="text-align:center">通过指定属性名获取本类不限修饰符的属性，不包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[] getInterfaces()</code></td>
<td style="text-align:center">获取类实现的所有接口的Class数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericInterfaces()</td>
<td style="text-align:center">获取类实现的所有泛型参数接口的Type数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;? super T&gt;</code> getSuperclass()</td>
<td style="text-align:center">获取当前类的父类的Class，如果当前类是Object、接口、基本数据类型(primitive)或者void，则返回null</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericSuperclass()</td>
<td style="text-align:center">获取当前类的泛型参数父类的Type，如果当前类是Object、接口、基本数据类型(primitive)或者void，则返回null</td>
</tr>
<tr>
<td style="text-align:center">native boolean isInstance(Object obj)</td>
<td style="text-align:center">判断传入的object是否当前类的实例</td>
</tr>
<tr>
<td style="text-align:center">native boolean isAssignableFrom(<code>Class&lt;?&gt; cls</code>)</td>
<td style="text-align:center">判断传入的Class对象是否和当前类相同，或者是否当前类的超类或超接口</td>
</tr>
<tr>
<td style="text-align:center">native boolean isInterface()</td>
<td style="text-align:center">判断当前类是否接口</td>
</tr>
<tr>
<td style="text-align:center">native boolean isArray()</td>
<td style="text-align:center">判断当前类是否数组</td>
</tr>
<tr>
<td style="text-align:center">native boolean isPrimitive()</td>
<td style="text-align:center">判断当前类是否基本数据类型</td>
</tr>
<tr>
<td style="text-align:center">boolean isAnnotation()</td>
<td style="text-align:center">判断当前类是否注解类型</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">判断当前类是否复合</td>
</tr>
<tr>
<td style="text-align:center">native <code>Class&lt;?&gt;</code> getComponentType()</td>
<td style="text-align:center">如果当前类是数组，返回数组元素的类型</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getEnclosingClass()</td>
<td style="text-align:center">返回一个类，当前类(一般是成员类)在这个类(封闭类，相对于内部类的外部类或者说外面一层)中定义</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;</code> getEnclosingConstructor()</td>
<td style="text-align:center">返回构造器，当前类是在这个构造函数中定义</td>
</tr>
<tr>
<td style="text-align:center">Method getEnclosingMethod()</td>
<td style="text-align:center">返回方法，当前类是在这个方法中定义</td>
</tr>
<tr>
<td style="text-align:center">Module getModule()</td>
<td style="text-align:center">返回模块，JDK9新增方法</td>
</tr>
</tbody>
</table>
<p><code>getName()</code>、<code>getCanonicalName()</code>和<code>getSimpleName()</code>都是用于获取类的名称，但是有所区别，下面举个列子说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Supper&lt;String, List&lt;Integer&gt;&gt; supper = <span class="keyword">new</span> Supper&lt;&gt;();</span><br><span class="line">		Class&lt;?&gt; clazz = supper.getClass();</span><br><span class="line">		System.out.println(<span class="string">"name-&gt;"</span> + clazz.getName());</span><br><span class="line">		System.out.println(<span class="string">"canonicalName-&gt;"</span> + clazz.getCanonicalName());</span><br><span class="line">		System.out.println(<span class="string">"simpleName-&gt;"</span> + clazz.getSimpleName());</span><br><span class="line">		System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">		String[][] strings = <span class="keyword">new</span> String[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		System.out.println(<span class="string">"name-&gt;"</span> + strings.getClass().getName());</span><br><span class="line">		System.out.println(<span class="string">"canonicalName-&gt;"</span> + strings.getClass().getCanonicalName());</span><br><span class="line">		System.out.println(<span class="string">"simpleName-&gt;"</span> + strings.getClass().getSimpleName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> K key;</span><br><span class="line">		<span class="keyword">private</span> V value;</span><br><span class="line">        <span class="comment">//省略setter和getter方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name-&gt;club.throwable.reflect.Main$Supper</span><br><span class="line">canonicalName-&gt;club.throwable.reflect.Main.Supper</span><br><span class="line">simpleName-&gt;Supper</span><br><span class="line">======================================</span><br><span class="line">name-&gt;[[Ljava.lang.String;</span><br><span class="line">canonicalName-&gt;java.lang.String[][]</span><br><span class="line">simpleName-&gt;String[][]</span><br></pre></td></tr></table></figure>
<p>简单理解为：</p>
<ul>
<li><code>getName()</code>：用于获取类在Java虚拟机中的类名表示。</li>
<li><code>getCanonicalName()</code>：用于获取全类名，包括包路径，包路径以点号分隔。</li>
<li><code>getSimpleName()</code>：用于获取类名，不包括包路径。</li>
</ul>
<p>下面再举一个例子通过类名进行实例化对象和操作，从例子可以看到，实例化对象可以不依赖<code>new</code>关键字，这就是反射的强大之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">"club.throwable.reflect.Main3$Supper"</span>);</span><br><span class="line">		Supper supper = (Supper) clazz.newInstance();</span><br><span class="line">		System.out.println(supper.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> String.format(<span class="string">"%s say hello!"</span>, name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点，<code>Class.forName</code>方法只能使用在修饰符为public的类上，如果使用在其他修饰符类上会抛出异常(IllegalAccessException)，那么，如果上面的Supper类的修饰符修改为private，怎么样才能正常实例化它？这个问题将会在下面分析Constructor的时候得到解决。另外，这里的<code>Class.forName</code>方法不是获取Class实例的唯一方式，总结有以下三种方式：</p>
<ul>
<li>1、使用类的字面量&quot;类名.class&quot;。类字面常量使得创建Class对象的引用时不会自动地初始化该对象，而是按照之前提到的加载，链接，初始化三个步骤，这三个步骤是个懒加载的过程，不使用的时候就不加载。</li>
<li>2、使用<code>Class.forName(全类名);</code>方法。</li>
<li>3、使用实例的<code>getClass()</code>方法。<code>getClass()</code>是所有的对象都能够使用的方法，因为getClass()方法是Object类的方法，所有的类都继承了Object，因此所有类的对象也都具有getClass()方法。</li>
</ul>
<p>一般来说，使用&quot;类名.class&quot;，这样做即简单安全又比较高效。因为在编译时就会受到检查，因此不需要置于try语句块中，并且它根除了对forName()方法的调用(forName()方法是一个耗时比较多的方法)，所以相对比较高效。</p>
<p>最后，分析一下这几个比较难懂的方法<code>getEnclosingClass()</code>、<code>getEnclosingConstructor()</code>、<code>getEnclosingMethod()</code>：</p>
<ul>
<li><code>getEnclosingClass()</code>：返回一个类，当前类(一般是成员类)在这个类(<strong>一般叫封闭类，相对于内部类的外部类或者说外面一层</strong>)中定义。</li>
<li><code>getEnclosingConstructor()</code>：返回构造器，当前类是在这个构造函数中定义。</li>
<li><code>getEnclosingClass()</code>：返回方法，当前类是在这个方法中定义。</li>
</ul>
<p><strong>我们在新建一个类的时候，这个类可以使另一个类中定义的成员类、构造方法中定义的内部类、方法中定义的内部类。可以通过当前的类反向获取定义当前的类的类、构造或者方法，这三种情况对应上面三个方法</strong>。举个例子：</p>
<p><code>getEnclosingClass()</code>方法使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Outter.Inner&gt; clazz = Outter.Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class&lt;?&gt; enclosingClass = clazz.getEnclosingClass();</span><br><span class="line">        System.out.println(enclosingClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Inner类是Outter类的成员类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.throwable.inherited.Main5$Outter</span><br></pre></td></tr></table></figure>
<p>在这里，Inner就是当前定义的类，它是Outter的静态成员类，或者说Outter是Inner的封闭类，通过Inner的Class的<code>getEnclosingClass()</code>方法获取到的就是Outter的Class实例。</p>
<p><code>getEnclosingConstructor()</code>方法使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Outter的无参数构造器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//构造中定义的内部类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;Inner&gt; innerClass = Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Class&lt;?&gt; enclosingClass = innerClass.getEnclosingClass();</span><br><span class="line">            System.out.println(enclosingClass.getName());</span><br><span class="line">            Constructor&lt;?&gt; enclosingConstructor = innerClass.getEnclosingConstructor();</span><br><span class="line">            System.out.println(enclosingConstructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.throwable.inherited.Main6$Outter</span><br><span class="line">org.throwable.inherited.Main6$Outter</span><br></pre></td></tr></table></figure>
<p>在这里，Inner是Outter的无参数构造里面定义的构造内部类，它也只能在Outter的无参数构造里面使用，通过Inner的Class的<code>getEnclosingConstructor()</code>方法获取到的就是Outter的无参数构造。</p>
<p><code>getEnclosingMethod()</code>方法使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        outter.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//方法print中定义的内部类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;Inner&gt; innerClass = Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Class&lt;?&gt; enclosingClass = innerClass.getEnclosingClass();</span><br><span class="line">            System.out.println(enclosingClass.getName());</span><br><span class="line">            Method enclosingMethod = innerClass.getEnclosingMethod();</span><br><span class="line">            System.out.println(enclosingMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.throwable.inherited.Main7$Outter</span><br><span class="line">print</span><br></pre></td></tr></table></figure>
<p>在这里，Inner是Outter的print方法里面定义的方法内部类，它也只能在Outter的print方法里面使用，通过Inner的Class的<code>getEnclosingMethod()</code>方法获取到的就是Outter的print方法。这种方式可能不常用，但是可以在某版本的spring-jdbc的<code>JdbcTemplate</code>的源码中看到类似的类定义逻辑。</p>
<p>前面介绍过<code>getXXX()</code>方法和<code>getDeclearedXXX()</code>方法有所区别，这里做个对比表格：</p>
<p><strong>Class中获取Field列表的方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class中的API</th>
<th style="text-align:center">获取所有的Field</th>
<th style="text-align:center">包括继承的Field</th>
<th style="text-align:center">包括私有的Field</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDeclaredField()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getField()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">getDeclaredFields()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getFields()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p><strong>Class中获取Method列表的方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class中的API</th>
<th style="text-align:center">获取所有的Method</th>
<th style="text-align:center">包括继承的Method</th>
<th style="text-align:center">包括私有的Method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDeclaredMethod()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getMethod()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">getDeclaredMethods()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getMethods()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p><strong>Class中获取Constructor列表的方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class中的API</th>
<th style="text-align:center">获取所有的Constructor</th>
<th style="text-align:center">包括私有的Constructor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDeclaredConstructor()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getConstructor()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">getDeclaredConstructors()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getConstructors()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<h2 id="Constructor类">Constructor类</h2>
<p><code>Constructor</code>用于描述一个类的构造函数。它除了能获取到构造的注解信息、参数的注解信息、参数的信息之外，还有一个很重要的作用是可以抑制修饰符进行实例化，而Class的实例化方法<code>newInstance</code>只能实例化修饰符为public的类。Constructor的主要方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;T&gt;</code> getDeclaringClass()</td>
<td style="text-align:center">获取当前构造的定义类</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">获取当前构造的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">获取当前构造的修饰符</td>
</tr>
<tr>
<td style="text-align:center">String toGenericString()</td>
<td style="text-align:center">返回描述此构造的字符串，其中包括类型参数的字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>TypeVariable&lt;Constructor&lt;T&gt;&gt;[]</code> getTypeParameters()</td>
<td style="text-align:center">获取类定义泛型参数的类型变量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getExceptionTypes()</td>
<td style="text-align:center">获取当前构造异常类型数组，如果不存在则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">获取当前构造异常类型数组的泛型类型，如果不存在则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">获取当前构造参数的泛型类型，如果不存在则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Annotation[][] getParameterAnnotations()</td>
<td style="text-align:center">获取当前构造参数的注解数组，这里是二维数组的原因是一个参数可以使用多个注解</td>
</tr>
<tr>
<td style="text-align:center">int getParameterCount()</td>
<td style="text-align:center">获取当前构造参数的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getParameterTypes()</td>
<td style="text-align:center">获取当前构造参数的Class数组</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">当前构造是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isVarArgs()</td>
<td style="text-align:center">当前构造是否使用不定参数</td>
</tr>
<tr>
<td style="text-align:center">T newInstance(Object…initargs)</td>
<td style="text-align:center">使用此构造对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</td>
</tr>
<tr>
<td style="text-align:center">Parameter[] getParameters()</td>
<td style="text-align:center">返回此构造对象的参数Parameter数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">抑制构造访问修饰符的权限判断</td>
</tr>
</tbody>
</table>
<p>下面我们举个例子说明使用构造实例化对象可以抑制修饰符访问权限控制的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Constructor&lt;Supper&gt; constructor = supperClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(Boolean.TRUE);</span><br><span class="line">        Supper supper = constructor.newInstance();</span><br><span class="line">        supper.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<p>这就是为什么一些IOC容器的实现框架中实例化类的时候优先依赖于无参数构造的原因，如果使用<code>Class#newInstance</code>方法，上面的代码调用逻辑会抛异常。</p>
<h2 id="Method类">Method类</h2>
<p>Method用于描述一个类的方法。它除了能获取方法的注解信息，还能获取方法参数、返回值的注解信息和其他信息。Method常用的方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getDeclaringClass()</td>
<td style="text-align:center">获取方法对应的Class</td>
</tr>
<tr>
<td style="text-align:center">Object getDefaultValue()</td>
<td style="text-align:center">获取方法上的注解成员的默认值</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getExceptionTypes()</td>
<td style="text-align:center">获取方法上的异常类型数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">获取方法上的异常泛型类型Type数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Parameter[] getParameters()</td>
<td style="text-align:center">返回方法的参数Parameter数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">int getParameterCount()</td>
<td style="text-align:center">返回方法的参数的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getParameterTypes()</td>
<td style="text-align:center">返回方法的参数的类型Class数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Annotation[][] getParameterAnnotations()</td>
<td style="text-align:center">返回方法的注解Annotation数组，这里使用二维数组的原因是一个参数可以使用多个注解</td>
</tr>
<tr>
<td style="text-align:center"><code>TypeVariable&lt;Method&gt;[]</code> getTypeParameters()</td>
<td style="text-align:center">返回方法的泛型参数的类型变量</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回方法参数的泛型类型Type数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getReturnType()</td>
<td style="text-align:center">返回方法的返回值的类型Class</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericReturnType()</td>
<td style="text-align:center">返回方法的返回值的泛型类型Type</td>
</tr>
<tr>
<td style="text-align:center">AnnotatedType getAnnotatedReturnType()</td>
<td style="text-align:center">获取方法返回值的注解类型实例AnnotatedType</td>
</tr>
<tr>
<td style="text-align:center">boolean isBridge()</td>
<td style="text-align:center">是否桥方法</td>
</tr>
<tr>
<td style="text-align:center">boolean isDefault()</td>
<td style="text-align:center">是否接口的默认方法</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isVarArgs()</td>
<td style="text-align:center">是否使用了不定参数</td>
</tr>
<tr>
<td style="text-align:center">String toGenericString()</td>
<td style="text-align:center">返回方法带有泛型字面量的描述字符串</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回方法的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">返回方法的修饰符</td>
</tr>
<tr>
<td style="text-align:center">Object invoke(Object obj, Object… args)</td>
<td style="text-align:center">对带有指定参数的指定对象调用由此方法对象表示的底层方法</td>
</tr>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">抑制方法访问修饰符的权限判断</td>
</tr>
</tbody>
</table>
<p>关注其中的<code>invoke(Object obj, Object... args)</code>方法，第一个是要调用这个方法的对象，剩下的方法的参数，返回值就是该方法执行的返回值。如果方法的修饰符不是public，在调用<code>invoke</code>方法前需要调用<code>setAccessible(boolean flag)</code>抑制方法访问修饰符的权限判断，否则会抛出异常。举个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Supper supper = supperClass.newInstance();</span><br><span class="line">        Method sayHello = supperClass.getDeclaredMethod(<span class="string">"sayHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHello.setAccessible(Boolean.TRUE);</span><br><span class="line">        sayHello.invoke(supper,<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<h2 id="Field类">Field类</h2>
<p><code>Field</code>类用来描述一个类里面的属性或者叫成员变量，通过Field可以获取属性的注解信息、泛型信息，获取和设置属性的值等等。Field的主要方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回该属性的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">返回该属性的修饰符</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getType()</td>
<td style="text-align:center">返回该属性的类型Class</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getParameterizedType()</td>
<td style="text-align:center">返回该属性的泛型类型Type</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">该属性是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isEnumConstant()</td>
<td style="text-align:center">该属性是否枚举类型的元素</td>
</tr>
<tr>
<td style="text-align:center">Object get(Object obj)</td>
<td style="text-align:center">通过对象实例获取该属性的值</td>
</tr>
<tr>
<td style="text-align:center">void set(Object obj,Object value)</td>
<td style="text-align:center">通过对象实例设置该属性的值</td>
</tr>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">抑制属性访问修饰符的权限判断</td>
</tr>
</tbody>
</table>
<p>这里忽略了注解以及Field实现了<code>FieldAccessor</code>接口中的<code>getBoolean</code>、<code>setBoolean</code>等方法。下面举个例子说明一下Field的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main12</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Supper supper = supperClass.newInstance();</span><br><span class="line">        Method sayHello = supperClass.getDeclaredMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">        sayHello.setAccessible(Boolean.TRUE);</span><br><span class="line">        Field name = supperClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        name.setAccessible(Boolean.TRUE);</span><br><span class="line">        name.set(supper,<span class="string">"throwable"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Field get--&gt;"</span> + name.get(supper));</span><br><span class="line">        sayHello.invoke(supper);</span><br><span class="line">        name.set(supper, <span class="string">"throwable-10086"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Field get--&gt;"</span> + name.get(supper));</span><br><span class="line">        sayHello.invoke(supper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field get--&gt;throwable</span><br><span class="line">throwable say hello!</span><br><span class="line">Field get--&gt;throwable-<span class="number">10086</span></span><br><span class="line">throwable-<span class="number">10086</span> say hello!</span><br></pre></td></tr></table></figure>
<h2 id="Parameter类">Parameter类</h2>
<p><code>Parameter</code>用于描述<code>Method</code>或者<code>Constructor</code>的参数，主要是用于获取参数的名称。因为在Java中没有形式参数的概念，也就是参数都是没有名称的。Jdk1.8新增了Parameter用来填补这个问题，使用javac编译器的时候加上<code>-parameters</code>参数的话，会在生成的.class文件中额外存储参数的元信息，这样会导致.class文件的大小增加。当你输入<code>javac -help</code>的时候，你会看到-parameters这个选项。获取Parameter的方法是Method或者Constructor的父类Executable的getParamaters方法。一般而言，Parameter是用于获取参数名称的后备方案，因为Jdk1.8之前没有这个类，并且即使使用了Jdk1.8如果javac编译器的时候没有加上<code>-parameters</code>参数的话，通过Parameter获取到的参数名称将会是&quot;arg0&quot;、“arg1”…&quot;argn&quot;类似的没有意义的参数名称。一般框架中使用其他方法解析方法或者构造器的参数名称，参考Spring的源码，具体是<code>LocalVariableTableParameterNameDiscoverer</code>，是使用ASM去解析和读取类文件字节码，提取参数名称。Parameter的主要方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回该参数的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">返回该参数的修饰符</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getType()</td>
<td style="text-align:center">返回该参数的类型Class</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getParameterizedType()</td>
<td style="text-align:center">返回该参数的泛型类型Type</td>
</tr>
<tr>
<td style="text-align:center">boolean isNamePresent()</td>
<td style="text-align:center">该参数的名称是否保存在class文件中，需要编译时加参数-parameters</td>
</tr>
<tr>
<td style="text-align:center">boolean isImplicit()</td>
<td style="text-align:center">该参数是否隐式声明</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">该参数是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isVarArgs()</td>
<td style="text-align:center">该参数是否不定参数</td>
</tr>
</tbody>
</table>
<p>这里举个例子，编译时候添加参数<code>-parameters</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method sayHello = supperClass.getDeclaredMethod(<span class="string">"sayHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHello.setAccessible(Boolean.TRUE);</span><br><span class="line">        Parameter[] parameters = sayHello.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">            System.out.println(<span class="string">"isNamePresent-&gt;"</span> + parameter.isNamePresent());</span><br><span class="line">            System.out.println(<span class="string">"isImplicit-&gt;"</span> + parameter.isImplicit());</span><br><span class="line">            System.out.println(<span class="string">"getName-&gt;"</span> + parameter.getName());</span><br><span class="line">            System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isNamePresent-&gt;<span class="keyword">true</span></span><br><span class="line">isImplicit-&gt;<span class="keyword">false</span></span><br><span class="line">getName-&gt;name</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure>
<p>如果不设置编译参数<code>-parameters</code>，会输出下面的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isNamePresent-&gt;<span class="keyword">false</span></span><br><span class="line">isImplicit-&gt;<span class="keyword">false</span></span><br><span class="line">getName-&gt;arg0</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>这篇文章开篇对反射的基本进行介绍，后面花大量篇幅列举了相关类库的API和API使用，掌握这些类库，才能轻松地进行反射编程。</p>
<p>(本文完 e-2018122)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/01/rabbitmq-extension-direct-reply-to/">
      RabbitMQ扩展之直接回复(Direct reply-to)
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月1日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：7分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-01T19:05:19+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文内容参考RabbitMQ官方文档<a href="https://www.rabbitmq.com/direct-reply-to.html" target="_blank" rel="noopener">Direct reply-to</a>。</p>
<h2 id="直接回复">直接回复</h2>
<p>直接回复(Direct reply-to)是一种可以避免声明回复队列并且实现类似于RPC功能的一种特性。RabbitMQ中允许使用客户端和RabbitMQ消息代理中间件实现RPC模式，典型的做法是：RPC客户端发送请求(消息)到一个持久化的已知服务端队列，RPC服务端消费该服务端队列的消息，然后使用消息属性中的<code>reply-to</code>属性对应的值作为客户端回复队列发送回复消息到RPC客户端。</p>
<p>客户端回复队列需要考虑创建问题。客户端可以为每个请求-响应声明一个一次性的队列，但是这样的做法是十分低效的，因为即使是非持久状态下的非镜像队列，其删除的代价是昂贵的，特别是在集群模式之下。另一个可选的做法是：客户端为回复创建一个持久化的长期存在的队列，这种情况下队列的管理可能变得复杂，因为客户端本身可能不是长期存在的。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-m-d-r/r-m-d-r-1.png" alt="r-m-d-r-1.png"></p>
<p>实际上，RabbitMQ提供了一个功能，允许RPC客户端直接从其RPC服务端接收回复，并且无需创建回复队列，依赖于RabbitMQ的消息中间件的功能，具体做法是：</p>
<p><strong>对于RPC客户端：</strong></p>
<ul>
<li>RPC客户端创建消费者的时候队列指定为伪队列<code>amq.rabbitmq.reply-to</code>，使用非手动ack模式(autoAck=true)进行消费，伪队列<code>amq.rabbitmq.reply-to</code>不需要显式声明，当然如果需要的话也可以显式声明。</li>
<li>发布消息的时候，消息属性中的<code>reply-to</code>属性需要指定为<code>amq.rabbitmq.reply-to</code>。</li>
</ul>
<p><strong>对于RPC服务端：</strong></p>
<ul>
<li>RPC服务端接收消息后感知消息属性中的<code>reply-to</code>属性存在，它应该通过默认的交换器(名称为&quot;&quot;)和<code>reply-to</code>属性作为路由键发送回复消息，那么该回复消息就会直接投递到RPC客户端的消费者中。</li>
<li>如果RPC服务端需要进行一些长时间的计算逻辑，可能需要探测RPC服务端是否存活，可以使用一个一次性使用的信道对<code>reply-to</code>属性做一次队列声明，如果声明成功，队列<code>amq.rabbitmq.reply-to</code>并不会创建，如果声明失败，那么说明客户端已经失去连接。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>RPC客户端在创建伪队列<code>amq.rabbitmq.reply-to</code>消费者的时候必须使用非手动ack模式(autoAck=true)。</li>
<li>使用此机制发送的回复消息通常不具有容错能力，如果发布原始请求的客户端随后断开连接，它们将被丢弃。</li>
<li>伪队列<code>amq.rabbitmq.reply-to</code>可以在<code>basic.consume</code>、<code>basic.publish</code>和消息属性<code>reply-to</code>中使用，实际上，它并不是一个真实存在的队列，RabbitMQ的Web管理器或者<code>rabbitmqctl list_queues</code>命令都无法展示该伪队列的相关属性或者信息。</li>
</ul>
<p>说实话，个人认为这种方式有个比较多的局限性：</p>
<ul>
<li>同一个应用里面，只能使用唯一一个伪队列<code>amq.rabbitmq.reply-to</code>消费回复消息，并且RabbitMQ的Web管理器或者<code>rabbitmqctl list_queues</code>命令都无法展示该伪队列的相关属性或者信息，也就是无法对它进行监控或者管理。</li>
<li>对于多应用同时接进去同一个RabbitMQ消息中间件代理，这些应用之间无法同时使用<code>amq.rabbitmq.reply-to</code>这个特性，因为有可能A客户端发送的消息被远程服务回调到另一个不同的B客户端。</li>
</ul>
<h2 id="直接回复特性使用">直接回复特性使用</h2>
<p>使用伪队列<code>amq.rabbitmq.reply-to</code>的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplyToRawMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAKE_QUEUE = <span class="string">"amq.rabbitmq.reply-to"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE = <span class="string">"rpc.queue"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_EXCHANGE = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			<span class="comment">// 服务端队列</span></span><br><span class="line">			channel.queueDeclare(RPC_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">			client(channel);</span><br><span class="line">			server(channel);</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 客户端消费 - no-ack,也就是autoAck = true</span></span><br><span class="line">		channel.basicConsume(FAKE_QUEUE, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">									   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">									   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(String.format(<span class="string">"[X-Client]\ndeliveryTag:%s\nexchange:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">						envelope.getDeliveryTag(), envelope.getExchange(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">						properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 客户端发送</span></span><br><span class="line">		AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">				.correlationId(<span class="string">"message-99999"</span>)</span><br><span class="line">				.replyTo(FAKE_QUEUE)</span><br><span class="line">				.build();</span><br><span class="line">		channel.basicPublish(DEFAULT_EXCHANGE, RPC_QUEUE, basicProperties, <span class="string">"Reply Message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 服务端消费</span></span><br><span class="line">		channel.basicConsume(RPC_QUEUE, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">									   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">									   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(String.format(<span class="string">"[X-Server]\ndeliveryTag:%s\nexchange:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">						envelope.getDeliveryTag(), envelope.getExchange(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">						properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">				<span class="comment">// 服务端应答-&gt;客户端</span></span><br><span class="line">				AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">						.correlationId(properties.getCorrelationId())</span><br><span class="line">						.build();</span><br><span class="line">				channel.basicPublish(DEFAULT_EXCHANGE, properties.getReplyTo(), basicProperties, body);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，可以直接创建一个真实的独占队列(生命周期跟客户端的连接绑定)作为回复队列，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplyToMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			<span class="comment">// 服务端队列</span></span><br><span class="line">			channel.queueDeclare(<span class="string">"rpc.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 客户端接收应答队列 - 排他队列,生命周期和连接绑定</span></span><br><span class="line">			AMQP.Queue.DeclareOk callback = channel.queueDeclare(<span class="string">""</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"建立排他应答队列:"</span> + callback.getQueue());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 客户端消费</span></span><br><span class="line">			channel.basicConsume(callback.getQueue(), <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">										   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">										   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">										   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">					System.out.println(String.format(<span class="string">"[X-Client]\ndeliveryTag:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">							envelope.getDeliveryTag(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">							properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 服务端消费</span></span><br><span class="line">			channel.basicConsume(<span class="string">"rpc.queue"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">										   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">										   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">										   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">					System.out.println(String.format(<span class="string">"[X-Server]\ndeliveryTag:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">							envelope.getDeliveryTag(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">							properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">					<span class="comment">// 服务端应答</span></span><br><span class="line">					AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">							.correlationId(properties.getCorrelationId())</span><br><span class="line">							.build();</span><br><span class="line">					channel.basicPublish(<span class="string">""</span>, properties.getReplyTo(), basicProperties, body);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端发送</span></span><br><span class="line">			AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">					.correlationId(<span class="string">"message-99999"</span>)</span><br><span class="line">					.replyTo(callback.getQueue())</span><br><span class="line">					.build();</span><br><span class="line">			channel.basicPublish(<span class="string">""</span>, <span class="string">"rpc.queue"</span>, basicProperties, <span class="string">"Reply Message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人想法">个人想法</h2>
<p>在实际项目中，我们经常被RabbitMQ消息发送是否成功这个问题困扰，一般情况下，我们认为调用<code>basic.publish</code>只要不抛出异常就是发送消息成功，例如一个代码模板如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		channel.basicPublish();</span><br><span class="line">		<span class="comment">// 发送成功</span></span><br><span class="line">		success = <span class="keyword">true</span>;</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">		<span class="comment">// 发送失败</span></span><br><span class="line">		log.error();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码模板在极大多数情况下是合适的，但是有些时候我们确实需要消息的接收方告知发送方已经收到消息，这个时候就需要用到消息的回复功能，个人认为可选的方案有：</p>
<ul>
<li>消息发布方基于伪队列<code>amq.rabbitmq.reply</code>进行消费，消息接收方回复到伪队列<code>amq.rabbitmq.reply</code>上。</li>
<li>消息发布方自定义独占队列进行消费，消息接收方回复到此独占队列。</li>
<li>消息发布方自定义持久化队列进行消费，消息接收方回复到此持久化队列。</li>
</ul>
<p>其实，<strong>在<code>AMQP.BasicProperties</code>的replyTo属性中指定需要回复的队列名只是RabbitMQ提出的一种规约或者建议，并不是强制实行的方案，实际上可以自行选择回复队列或者忽略replyTo属性</strong>。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/30/java-service-loader/">
      浅析JDK中ServiceLoader的源码
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：13分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-30T00:41:40+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年11月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>紧接着上一篇《通过源码浅析JDK中的资源加载》，ServiceLoader是SPI(Service Provider Interface)中的服务类加载的核心类，也就是，这篇文章先介绍ServiceLoader的使用方式，再分析它的源码。</p>
<h2 id="ServiceLoader的使用">ServiceLoader的使用</h2>
<p>这里先列举一个经典的例子，MySQL的Java驱动就是通过ServiceLoader加载的，先引入<code>mysql-connector-java</code>的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查看这个依赖的源码包下的META-INF目录，可见：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-s-l/r-s-l-1.png" alt="r-s-l-1"></p>
<p>我们接着查看java.lang.DriverManager，静态代码块里面有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    loadInitialDrivers();</span><br><span class="line">    println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，可以查看<code>loadInitialDrivers()</code>有如下的代码片段：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-s-l/r-s-l-2.png" alt="r-s-l-2"></p>
<p>java.lang.DriverManager是启动类加载器加载的基础类，但是它可以加载<code>rt.jar</code>包之外的类，上篇文章提到，这里打破了双亲委派模型，原因是：ServiceLoader中使用了线程上下文类加载器去加载类。这里JDBC加载的过程就是典型的SPI的使用，总结规律如下：</p>
<ul>
<li>1、需要定义一个接口。</li>
<li>2、接口提供商需要实现第1步中的接口。</li>
<li>3、接口提供商在META-INF/services目录下建立一个文本文件，文件名是第1步中定义的接口的全限定类名，文本内容是接口的实现类的全限定类名，每个不同的实现占独立的一行。</li>
<li>4、使用ServiceLoader加载接口类，获取接口的实现的实例迭代器。</li>
</ul>
<p>举个简单的实例，先定义一个接口和两个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayBye</span> <span class="keyword">implements</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Bye!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHello</span> <span class="keyword">implements</span> <span class="title">Say</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在项目的META-INF/services中添加文件如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-s-l/r-s-l-3.png" alt="r-s-l-3"></p>
<p>最后通过main函数验证：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-s-l/r-s-l-4.png" alt="r-s-l-4"></p>
<p>基于SPI或者说ServiceLoader加载接口实现这种方式也可以广泛使用在相对基础的组件中，因为这是一个成熟的规范。</p>
<h1>ServiceLoader源码分析</h1>
<p>上面通过一个经典例子和一个实例介绍了ServiceLoader的使用方式，接着我们深入分析ServiceLoader的源码。我们先看ServiceLoader的类签名和属性定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//需要加载的资源的路径的目录，固定是ClassPath下的META-INF/services/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line">    <span class="comment">// ServiceLoader需要正在需要加载的类或者接口</span></span><br><span class="line">    <span class="comment">// The class or interface representing the service being loaded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// ServiceLoader进行类加载的时候使用的类加载器引用</span></span><br><span class="line">    <span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    <span class="comment">// 权限控制上下文</span></span><br><span class="line">    <span class="comment">// The access control context taken when the ServiceLoader is created</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="comment">//基于实例的顺序缓存类的实现实例，其中Key为实现类的全限定类名</span></span><br><span class="line">    <span class="comment">// Cached providers, in instantiation order</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 当前的"懒查找"迭代器，这个是ServiceLoader的核心</span></span><br><span class="line">    <span class="comment">// The current lazy-lookup iterator</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂时忽略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceLoader实现了Iterable接口，这一点提示了等下我们在分析它源码的时候，需要重点分析<code>iterator()</code>方法的实现。ServiceLoader依赖于类加载器实例进行类加载，它的核心属性LazyIterator是就是用来实现<code>iterator()</code>方法的，下文再重点分析。接着，我们分析ServiceLoader的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//清空缓存</span></span><br><span class="line">    providers.clear();</span><br><span class="line">    <span class="comment">//构造LazyIterator实例</span></span><br><span class="line">    lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceLoader只有一个私有的构造函数，也就是它不能通过构造函数实例化，但是要实例化ServiceLoader必须依赖于它的静态方法调用私有构造去完成实例化操作，而实例化过程主要做了几步：</p>
<ul>
<li>1、判断传入的接口或者类的Class实例不能为null，否则会抛出异常。</li>
<li>2、如果传入的ClassLoader实例为null，则使用应用类加载器(Application ClassLoader)。</li>
<li>3、实例化访问控制上下文。</li>
<li>4、调用实例方法<code>reload()</code>，清空目标加载类的实现类实例的缓存并且构造LazyIterator实例。</li>
</ul>
<p>注意一点是实例方法<code>reload()</code>的修饰符是public，也就是可以主动调用去清空目标加载类的实现类实例的缓存和重新构造LazyIterator实例。接着看ServiceLoader提供的静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">loadInstalled</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">    ClassLoader prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = cl;</span><br><span class="line">        cl = cl.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的三个公共静态方法都是用于构造ServiceLoader实例，其中<code>load(Class&lt;S&gt; service, ClassLoader loader)</code>就是典型的静态工厂方法，直接调用ServiceLoader的私有构造器进行实例化，除了需要指定加载类的目标类型，还需要传入类加载器的实例。<code>load(Class&lt;S&gt; service)</code>实际上也是委托到<code>load(Class&lt;S&gt; service, ClassLoader loader)</code>，不过它使用的类加载器指定为线程上下文类加载器，一般情况下，线程上下文类加载器获取到的就是应用类加载器(系统类加载器)。<code>loadInstalled(Class&lt;S&gt; service)</code>方法又看出了&quot;双亲委派模型&quot;的影子，它指定类加载器为最顶层的启动类加载器，最后也是委托到<code>load(Class&lt;S&gt; service, ClassLoader loader)</code>。接着我们需要重点分析<code>ServiceLoader#iterator()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Iterator的匿名实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//目标类实现类实例缓存的Map的Entry的迭代器实例</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先从缓存中判断是否有下一个实例，否则通过懒加载迭代器LazyIterator去判断是否存在下一个实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果缓存中判断是否有下一个实例，如果有则从缓存中的值直接返回</span></span><br><span class="line">        <span class="comment">//否则通过懒加载迭代器LazyIterator获取下一个实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">            <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不支持移除操作，直接抛异常</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iterator()</code>内部仅仅是Iterator接口的匿名实现，<code>hasNext()</code>和<code>next()</code>方法都是优先判断缓存中是否已经存在实现类的实例，如果存在则直接从缓存中返回，否则调用懒加载迭代器LazyIterator的实例去获取，而LazyIterator本身也是一个Iterator接口的实现，它是ServiceLoader的一个私有内部类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIteratorimplements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        <span class="comment">//加载的资源的URL集合</span></span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//所有需要加载的实现类的全限定类名的集合</span></span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//下一个需要加载的实现类的全限定类名</span></span><br><span class="line">        String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">            <span class="keyword">this</span>.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果下一个需要加载的实现类的全限定类名不为null，则说明资源中存在内容</span></span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果加载的资源的URL集合为null则尝试进行加载</span></span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//资源的名称，META-INF/services + '需要加载的类的全限定类名'</span></span><br><span class="line">                    <span class="comment">//这样得到的刚好是需要加载的文件的资源名称</span></span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="comment">//这里其实ClassLoader实例应该不会为null</span></span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//从ClassPath加载资源</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从资源中解析出需要加载的所有实现类的全限定类名</span></span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取下一个需要加载的实现类的全限定类名</span></span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//反射构造Class&lt;S&gt;实例</span></span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里会做一次类型判断，也就是实现类必须是当前加载的类或者接口的派生类，否则抛出异常终止</span></span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//通过Class#newInstance()进行实例化，并且强制转化为对应的类型的实例</span></span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                <span class="comment">//添加缓存，Key为实现类的全限定类名，Value为实现类的实例</span></span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>LazyIterator</code>也是Iterator接口的实现，它的Lazy特性表明它总是在ServiceLoader的Iterator接口匿名实现<code>iterator()</code>执行<code>hasNext()</code>判断是否有下一个实现或者<code>next()</code>获取下一个实现类的实例的时候才会&quot;懒判断&quot;或者&quot;懒加载&quot;下一个实现类的实例。最后是加载资源文件后对资源文件的解析过程的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Iterator&lt;String&gt; <span class="title">parse</span><span class="params">(Class&lt;?&gt; service, URL u)</span> <span class="keyword">throws</span> ServiceConfigurationError</span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//存放文件中所有的实现类的全类名，每一行是一个元素</span></span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            r = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in, <span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error reading configuration file"</span>, x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) r.close();</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException y) &#123;</span><br><span class="line">                fail(service, <span class="string">"Error closing configuration file"</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的是ArrayList的迭代器实例</span></span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析资源文件中每一行的内容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parseLine</span><span class="params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="keyword">int</span> lc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      List&lt;String&gt; names)</span><span class="keyword">throws</span> IOException, ServiceConfigurationError</span>&#123;</span><br><span class="line">        <span class="comment">// 下一行没有内容，返回-1，便于上层可以跳出循环                 </span></span><br><span class="line">        String ln = r.readLine();</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在'#'字符，截取第一个'#'字符串之前的内容，'#'字符之后的属于注释内容</span></span><br><span class="line">        <span class="keyword">int</span> ci = ln.indexOf(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) ln = ln.substring(<span class="number">0</span>, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        <span class="keyword">int</span> n = ln.length();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不能存在空格字符' '和特殊字符'\t'</span></span><br><span class="line">            <span class="keyword">if</span> ((ln.indexOf(<span class="string">' '</span>) &gt;= <span class="number">0</span>) || (ln.indexOf(<span class="string">'\t'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                fail(service, u, lc, <span class="string">"Illegal configuration-file syntax"</span>);</span><br><span class="line">            <span class="keyword">int</span> cp = ln.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断第一个char是否一个合法的Java起始标识符</span></span><br><span class="line">            <span class="keyword">if</span> (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, <span class="string">"Illegal provider-class name: "</span> + ln);</span><br><span class="line">            <span class="comment">//判断所有其他字符串是否属于合法的Java标识符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="string">'.'</span>))</span><br><span class="line">                    fail(service, u, lc, <span class="string">"Illegal provider-class name: "</span> + ln);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果缓存中不存在加载出来的全类名或者已经加载的列表中不存在加载出来的全类名则添加进去加载的全类名列表中</span></span><br><span class="line">            <span class="keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整个资源文件的解析过程并不复杂，主要包括文件内容的字符合法性判断和缓存避免重复加载的判断。</p>
<h2 id="小结">小结</h2>
<p>SPI被广泛使用在第三方插件式类库的加载，最常见的如JDBC、JNDI、JCE(Java加密模块扩展)等类库。理解ServiceLoader的工作原理有助于编写扩展性良好的可插拔的类库。</p>
<p>(本文完 c-1-d e-20181014)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/30/java-resource-load/">
      通过源码浅析Java中的资源加载
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：4.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：16分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-02T10:20:27+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月2日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>最近在做一个基础组件项目刚好需要用到JDK中的资源加载，这里说到的资源包括类文件和其他静态资源，刚好需要重新补充一下类加载器和资源加载的相关知识，整理成一篇文章。</p>
<h2 id="什么是类加载器">什么是类加载器</h2>
<p>虚拟机设计团队把类加载阶段中的&quot;通过一个类的全限定名来获取描述此类的二进制字节流&quot;这个动作放到了Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，而实现这个动作的代码模块称为&quot;类加载器(ClassLoader)&quot;。</p>
<p>类加载器虽然只用于实现类加载的功能，但是它在Java程序中起到的作用不局限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立类在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。上面这句话直观来说就是：比较两个类是否&quot;相等&quot;，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这个两个类是来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那么这两个类必然&quot;不相等&quot;。这里说到的&quot;相等&quot;包括代表类的Class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，也包括使用<code>instanceOf</code>关键字做对象所属关系判定等情况。</p>
<p>类和加载它的类加载器确定类在Java虚拟机中的唯一性这个特点为后来出现的热更新类、热部署等技术提供了基础。</p>
<h2 id="双亲委派模型">双亲委派模型</h2>
<p>从Java虚拟机的角度来看，只有两种不同的类加载器：</p>
<ul>
<li>1、第一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++编程语言实现，是虚拟机的一部分。</li>
<li>2、另一种是其他的类加载器，这些类加载器都是由Java语言实现，独立于虚拟机之外，一般就是内部于JDK中，它们都继承自抽象类加载器java.lang.ClassLoader。</li>
</ul>
<p>JDK中提供几个系统级别的类加载器：</p>
<ul>
<li>1、启动类加载器(Bootstrap ClassLoader)：这个类加载器负责将存放在${JAVA_HONE}\lib目录中，或者被XbootstrapPath参数所指定的目录中，并且是虚拟机基于一定规则(如文件名称规则，如rt.jar)标识的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，开发者在编写自定义类加载器如果想委派到启动类加载器只需直接使用null替代即可。</li>
<li>2、扩展类加载器(Extension ClassLoader)：这个类加载器由sun.misc.Launcher的静态内部类ExtClassLoader实现，它负责加载${JAVA_HONE}\lib\ext目录中，或者通过java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用此类加载器。</li>
<li>3、应用程序类加载器(Application ClassLoader)：这个类加载器由sun.misc.Launcher的静态内部类AppClassLoader实现，但是由于这个类加载器的实例是ClassLoader中静态方法<code>getSystemClassLoader()</code>中的返回值，一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自实现的类加载器，一般情况下这个系统类加载器就是应用程序中默认使用的类加载器。</li>
<li>4、线程上下文类加载器(Thread Context ClassLoader)：这个在下一小节&quot;破坏双亲委派模型&quot;再分析。</li>
</ul>
<p>Java开发者开发出来的Java应用程序都是由上面四种类加载器相互配合进行类加载的，如果有必要还可以加入自定义的类加载器。其中，启动类加载器、扩展类加载器、应用程序类加载器和自定义类加载器之间存在着一定的关系：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-l/r-l-1.png" alt="r-l-1"></p>
<p>上图展示的类加载器之间的层次关系称为双亲委派模型(Parents Delegation Model)。双亲委派模型要求除了顶层的类加载器(Java中顶层的类加载器一般是Bootstrap ClassLoader)，其他的类加载器都应当有自己的父类加载器。这些类加载器之间的父子关系一般不会以继承(Inheritance)的关系来实现，而是通过组合(Composition)的关系实现。类加载器层次关系这一点可以通过下面的代码验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		ClassLoader classLoader = Main<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">		System.out.println(classLoader);</span><br><span class="line">		System.out.println(classLoader.getParent());</span><br><span class="line">		System.out.println(classLoader.getParent().getParent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果，最后的null说明是Bootstrap ClassLoader</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">4629104</span>a</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>双亲委派模型的工作机制：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的类加载器中，只有当父类加载器反馈自己无法完成当前的类加载请求的时候(也就是在它的搜索范围中没有找到所需要的类)，子类加载器才会尝试自己去加载类。<strong>不过这里有一点需要注意，每一个类加载器都会缓存已经加载过的类，也就是重复加载一个已经存在的类，那么就会从已经加载的缓存中加载，如果从当前类加载的缓存中判断类已经加载过，那么直接返回，否则会委派类加载请求到父类加载器。这个缓存机制在AppClassLoader和ExtensionClassLoader中都存在，至于BootstrapClassLoader未知。</strong></p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-l/r-l-2.png" alt="r-l-2"></p>
<p>双亲委派模型的优势：使用双亲委派模型来组织类加载器之间的关系，一个比较显著的优点是Java类随着加载它的类加载器一起具备了一种带有优先级的层次关系。例如<code>java.lang</code>包中的类库，它存放在<code>rt.jar</code>中，无论使用哪一个类加载加载<code>java.lang</code>包中的类，最终都是委派给处于模型顶层的启动类加载器进行加载，因此<code>java.lang</code>包中的类如<code>java.lang.Object</code>类在应用程序中的各类加载器环境中加载的都是同一个类。试想，如果可以使用用户自定义的ClassLoader去加载<code>java.lang.Object</code>，那么用户应用程序中就会出现多个<code>java.lang.Object</code>类，Java类型体系中最基础的类型也有多个，类型体系的基础行为无法保证，应用程序也会趋于混乱。如果尝试编写<code>rt.jar</code>中已经存在的同类名的类通过自定义的类加载进行加载，将会接收到虚拟机抛出的异常。</p>
<p>双亲委派模型的实现：类加载器双亲委派模型的实现提现在ClassLoader的源码中，主要是<code>ClassLoader#loadClass()</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//父加载器不为null，说明父加载器不是BootstrapClassLoader</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//父加载器为null，说明父加载器是BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//所有的父加载加载失败,则使用当前的类加载器进行类加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">//记录一些统计数据如加载耗时、计数等</span></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="破坏双亲委派模型">破坏双亲委派模型</h2>
<p>双亲委派模型在Java发展历史上出现了三次比较大&quot;被破坏&quot;的情况:</p>
<ul>
<li>
<p>1、ClassLoader在JDK1.0已经存在，JDK1.2为了引入双亲委派模型并且需要向前兼容，java.lang.ClassLoader类添加了一个新的protected的<code>findClass()</code>方法，在这之前，用户去继承java.lang.ClassLoader只能重写其<code>loadClass()</code>方法才能实现自己的目标。</p>
</li>
<li>
<p>2、双亲委派模型自身存在缺陷：双亲委派很好地解决了各个类加载器的基础类的加载的统一问题(越基础的类由越上层的类加载器加载)，这些所谓的基础类就是大多数情况下作为用户调用的基础类库和基础API，但是无法解决这些基础类需要回调用户的代码这一个问题，典型的例子就是JNDI。JNDI的类库代码是启动类加载器加载的，但是它需要调用独立厂商实现并且部署在应用的ClassPath的JNDI的服务接口提供者(SPI，即是Service Provider Interface)的代码，但是启动类加载器无法加载ClassPath下的类库。为了解决这个问题，Java设计团队引入了不优雅的设计：线程上下文类加载器(Thread Context ClassLoader)，这个类加载器可以通过java.lang.Thread类的<code>setContextClassLoader()</code>设置，这样子，JNDI服务就可以使用线程上下文类加载器去加载所需的SPI类库，但是父类加载器中请求子类加载器去加载类这一点已经打破了双亲委派模型。目前，JNDI、JDBC、JCE、JAXB和JBI等模块都是通过此方式实现。</p>
</li>
<li>
<p>3、基于用户对应用程序动态性的热切追求：如代码热替换(HotSwap)、热模块部署等，说白了就是希望应用程序能像我们的计算机外设那样可以热插拔，因此催生出<code>JSR-291</code>以及它的业界实现OSGi，而OSGi定制了自己的类加载规则，不再遵循双亲委派模型，因此它可以通过自定义的类加载器机制轻易实现模块的热部署。</p>
</li>
</ul>
<h1>JDK中提供的资源加载API</h1>
<p>前边花大量的篇幅去分析类加载器的预热知识，是因为JDK中的资源加载依赖于类加载器(其实类文件本来就是资源文件的一种，类加载的过程也是资源加载的过程)。这里先列举出JDK中目前常用的资源(Resource)加载的API，先看ClassLoader中提供的方法。</p>
<h2 id="ClassLoader提供的资源加载API">ClassLoader提供的资源加载API</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实例方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这个方法仅仅是调用getResource(String name)返回URL实例直接调用URL实例的openStream()方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这个方法是getResource(String name)方法的复数版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//2.静态方法</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">getSystemResource</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这个方法仅仅是调用getSystemResource(String name)返回URL实例直接调用URL实例的openStream()方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InputStream <span class="title">getSystemResourceAsStream</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//这个方法是getSystemResources(String name)方法的复数版本</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Enumeration&lt;URL&gt; <span class="title">getSystemResources</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure>
<p>总的来看，只有两个方法需要分析：<code>getResource(String name)</code>和<code>getSystemResource(String name)</code>。查看<code>getResource(String name)</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    URL url;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = parent.getResource(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = getBootstrapResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = findResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是否似曾相识?这里明显就是使用了类加载过程中类似的双亲委派模型进行资源加载，这个方法在API注释中描述通常用于加载数据资源如images、audio、text等等，资源名称需要使用路径分隔符’/’。<code>getResource(String name)</code>方法中查找的根路径我们可以通过下面方法验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ClassLoader classLoader = ResourceLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">		URL resource = classLoader.getResource(<span class="string">""</span>);</span><br><span class="line">		System.out.println(resource);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：file:/D:/Projects/rxjava-seed/target/classes/</span></span><br></pre></td></tr></table></figure>
<p>很明显输出的结果就是<strong>当前应用的ClassPath</strong>，总结来说：<code>ClassLoader#getResource(String name)</code>是基于用户应用程序的ClassPath搜索资源，资源名称必须使用路径分隔符’/‘去分隔目录，但是不能以’/'作为资源名的起始，也就是不能这样使用：<code>classLoader.getResource(&quot;/img/doge.jpg&quot;)</code>。接着我们再看一下<code>ClassLoader#getSystemResource(String name)</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">getSystemResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际上Application ClassLoader一般不会为null</span></span><br><span class="line">    ClassLoader system = getSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (system == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getBootstrapResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> system.getResource(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法优先使用应用程序类加载器进行资源加载，如果应用程序类加载器为null(其实这种情况很少见)，则使用启动类加载器进行资源加载。如果应用程序类加载器不为null的情况下，它实际上退化为<code>ClassLoader#getResource(String name)</code>方法。</p>
<p>总结一下：ClassLoader提供的资源加载的方法中的核心方法是<code>ClassLoader#getResource(String name)</code>，它是基于用户应用程序的ClassPath搜索资源，遵循&quot;资源加载的双亲委派模型&quot;，资源名称必须使用路径分隔符’/‘去分隔目录，但是不能以’/'作为资源名的起始字符，其他几个方法都是基于此方法进行衍生，添加复数操作等其他操作。<code>getResource(String name)</code>方法不会显示抛出异常，当资源搜索失败的时候，会返回null。</p>
<h2 id="Class提供的资源加载API">Class提供的资源加载API</h2>
<p>java.lang.Class中也提供了资源加载的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.net.<span class="function">URL <span class="title">getResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    name = resolveName(name);</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span> (cl==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A system class.</span></span><br><span class="line">        <span class="keyword">return</span> ClassLoader.getSystemResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl.getResource(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    name = resolveName(name);</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span> (cl==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A system class.</span></span><br><span class="line">        <span class="keyword">return</span> ClassLoader.getSystemResourceAsStream(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl.getResourceAsStream(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码来看，<code>Class#getResource(String name)</code>和<code>Class#getResourceAsStream(String name)</code>分别比<code>ClassLoader#getResource(String name)</code>和<code>ClassLoader#getResourceAsStream(String name)</code>只多了一步，就是搜索之前先进行资源名称的预处理<code>resolveName(name)</code>，我们重点看这个方法做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">resolveName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!name.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> (c.isArray()) &#123;</span><br><span class="line">            c = c.getComponentType();</span><br><span class="line">        &#125;</span><br><span class="line">        String baseName = c.getName();</span><br><span class="line">        <span class="keyword">int</span> index = baseName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">            name = baseName.substring(<span class="number">0</span>, index).replace(<span class="string">'.'</span>, <span class="string">'/'</span>)</span><br><span class="line">                    +<span class="string">"/"</span>+name;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         name = name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑相对比较简单：</p>
<ul>
<li>1、如果资源名称以’/‘开头，那么直接去掉’/’，这个时候的资源查找实际上退化为ClassPath中的资源查找。</li>
<li>2、如果资源名称不以’/‘开头，那么解析出当前类的实际类型(因为当前类有可能是数组)，取出类型的包路径，替换包路径中的’.‘为’/’，再拼接原来的资源名称。举个例子：&quot;club.throwable.Main.class&quot;中调用了<code>Main.class.getResource(&quot;doge.jpg&quot;)</code>，那么这个调用的处理资源名称的结果就是<code>club/throwable/doge.jpg</code>。</li>
</ul>
<p>小结：如果看过我之前写过的一篇URL和URI相关的文章就清楚，实际上<code>Class#getResource(String name)</code>和<code>Class#getResourceAsStream(String name)</code>的资源名称处理类似于相对URL的处理，而&quot;相对URL的处理&quot;的根路径就是应用程序的ClassPath。如果资源名称以’/‘开头，那么相当于从ClassPath中加载资源，如果资源名称不以’/'开头，那么相当于基于当前类的实际类型的包目录下加载资源。</p>
<p>实际上类似这样的资源加载方式在File类中也存在，这里就不再展开。</p>
<h2 id="小结">小结</h2>
<p>理解JDK中的资源加载方式有助于编写一些通用的基础组件，像Spring里面的ResourceLoader、ClassPathResource这里比较实用的工具也是基于JDK资源加载的方式编写出来。下一篇博文《浅析JDK中ServiceLoader的源码》中的主角ServiceLoader就是基于类加载器的功能实现，它也是SPI中的服务类加载的核心类。</p>
<p>说实话，类加载器的&quot;双亲委派模型&quot;和&quot;破坏双亲委派模型&quot;是常见的面试题相关内容，这里可以简单列举两个面试题：</p>
<ul>
<li>1、谈谈对类加载器的&quot;双亲委派模型&quot;的理解。</li>
<li>2、为什么要引入线程上下文类加载器(或者是对于问题1有打破这个模型的案例吗)?</li>
</ul>
<p>希望这篇文章能帮助你理解和解决这两个问题。</p>
<p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机第二版》</li>
<li>JavaSE-8源码</li>
</ul>
<p>(本文完 c-1-d e-20181014)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/30/rabbitmq-extension-consumer-priority/">
      RabbitMQ扩展之消费者优先级
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：690字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：2分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-30T00:25:37+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年11月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文来源于官方文档<a href="https://www.rabbitmq.com/consumer-priority.html" target="_blank" rel="noopener">Consumer Priorities</a>。</p>
<h2 id="消费者优先级">消费者优先级</h2>
<p>消费者优先级的机制：</p>
<ul>
<li>高优先级的消费者处于活跃状态的情况下优先接收和处理消息。</li>
<li>消息会流入到低优先级的活跃消费者仅当高优先级的消费者处于阻塞状态。</li>
</ul>
<p>正常情况下，所有订阅同一个队列的活跃消费者以循环的(round-robin)方式从队列中接收消息。当使用了消费者优先级，如果多个活跃消费者使用了相同的高优先级属性，那么消息投递也是以循环的方式进行(其实使用了相同的优先级类似于没有启用优先级)。</p>
<h3 id="活跃消费者的定义">活跃消费者的定义</h3>
<p>活跃的消费者就是可以在不用等待的情况下接收和处理消息的消费者，也就是消费者如果无法接收消息，那么它就是出于非活跃状态(或者说阻塞状态)，阻塞的常见原因有：</p>
<ul>
<li>使用了<code>basic.qos</code>之后，消费者在信道中未确认的预读取消息达到了上限。</li>
<li>网络阻塞。</li>
</ul>
<p>因此，对于每个存在的队列，必定至少出现下面三种情况的其中一种：</p>
<ul>
<li>队列没有活跃的消费者。</li>
<li>队列是空的。</li>
<li>队列正在忙于向消费者投递消息。</li>
</ul>
<p>消费者可能在一秒内多次在活跃和阻塞状态之间切换，只要消费处理速度足够快。<strong>RabbitMQ不会通过Web管理插件或者<code>rabbitmqctl</code>命令公开消费者当前是活跃还是阻塞状态</strong>，换言之，只能通过客户端感知。</p>
<p>启用消费者优先级的时候，RabbitMQ会优先投递消息到优先级属性比较高的消费者，但是如果所有优先级高的消费者都处于阻塞状态，RabbitMQ会把消息投递到活跃的优先级稍低的消费者，而不是一直等待优先级高的消费者解除阻塞，造成优先级低的消费者一直处于饥饿状态。</p>
<h3 id="使用消费者优先级特性">使用消费者优先级特性</h3>
<p><strong>在使用<code>basic.consume</code>方法可以设置参数<code>x-priority</code>的值为整数，数字越大则优先级越高，未设置则使用默认值0</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerPriorityMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			Map&lt;String, Object&gt; consumerArgs = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">			consumerArgs.put(<span class="string">"x-priority"</span>, <span class="number">10</span>);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>, <span class="keyword">true</span>, consumerArgs, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			&#125;);</span><br><span class="line">			consumerArgs.put(<span class="string">"x-priority"</span>, <span class="number">100</span>);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>, <span class="keyword">true</span>, consumerArgs, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子设置了两个消费者，后者的优先级为100，而前者的优先级为10。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/28/rabbitmq-extension-consumer-prefetch/">
      RabbitMQ扩展之消费者消息预读取
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月28日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.1k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：4分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-28T23:21:11+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年11月28日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文来源于官方文档<a href="https://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="noopener">Consumer Prefetch</a>。</p>
<h2 id="消费者消息预读取">消费者消息预读取</h2>
<p>消费者消息预读取是一个更加合理和高效的限制未确认消息数量的解决方式。</p>
<p>AMQP 0-9-1协议中定义了<code>basic.qos</code>方法用于限制信道或者连接上的未确认消息数量，这个消息数据量命名为<code>prefetch_count</code>。不幸的是，信道其实并不是限制未确认消息数量的理想范畴，因为单个信道有可能有多个消费者订阅多个不同的队列，所以信道和队列需要为发送的每个消息相互协调，以确保消息总数量不超过限制，造成了性能下降，单机性能出现瓶颈，在集群方案中耗时更加严重。</p>
<p><code>basic.qos</code>定义了两个属性：</p>
<ul>
<li>prefetch_count：预读取消息的数量。</li>
<li>global：是否全局的。</li>
</ul>
<p>在许多情况下，指定每个消费者的预读取消息数量更加合理。因此，RabbitMQ在<code>basic.qos</code>方法中重新定义了<code>global</code>标志的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">global的值</th>
<th style="text-align:left">prefetch_count在AMQP 0-9-1中的含义</th>
<th style="text-align:left">prefetch_count在RabbitMQ中的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">同一个信道上的消费者共享</td>
<td style="text-align:left">单独应用于信道上的每个新消费者</td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">所有消费者基于同一个连接共享</td>
<td style="text-align:left">同一个信道上的消费者共享</td>
</tr>
</tbody>
</table>
<p><code>basic.qos</code>方法在RabbitMQ的Java驱动中对应三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefetchSize = 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefetchSize = 0 , global = false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>prefetchSize：预读取的消息内容大小上限(包含)，可以简单理解为消息有效载荷字节数组的最大长度限制，0表示无上限。</li>
<li>prefetchCount：预读取的消息数量上限，0表示无上限。</li>
<li>global：false表示prefetchCount单独应用于信道上的每个新消费者，true表示prefetchCount在同一个信道上的消费者共享。</li>
</ul>
<h3 id="限制单个消费者">限制单个消费者</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicQosSingle</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			channel.basicQos(<span class="number">10</span>); <span class="comment">//基于消费者进行限制</span></span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此消费者最多只能有10条预读取的未确认的消息。</p>
<h3 id="独立限制多个消费者">独立限制多个消费者</h3>
<p>基于同一个信道对多个队列建立不同的消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicQosMulti</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			DefaultConsumer consumer1 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			DefaultConsumer consumer2 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			channel.basicQos(<span class="number">10</span>); <span class="comment">//基于消费者进行限制</span></span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>,consumer1);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.fanout"</span>,consumer2);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个费者最多只能有10条预读取的未确认的消息。</p>
<h3 id="基于共享限制多个消费者">基于共享限制多个消费者</h3>
<p>AMQP规范没有解释如果使用不同的<code>global</code>多次调用<code>basic.qos</code>会发生什么，RabbitMQ将此解释为意味着两个预取限制应该彼此独立地强制执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicQosShare</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			DefaultConsumer consumer1 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			DefaultConsumer consumer2 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			channel.basicQos(<span class="number">10</span>, <span class="keyword">false</span>); <span class="comment">//基于消费者进行限制</span></span><br><span class="line">			channel.basicQos(<span class="number">15</span>, <span class="keyword">true</span>); <span class="comment">//基于信道进行限制</span></span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>,consumer1);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.fanout"</span>,consumer2);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示：</p>
<ul>
<li>两个消费者consumer1和consumer2基于信道最多只能有15条未确认的预读取消息。</li>
<li>消费者consumer1和consumer2自身最多只能有10条未确认的预读取消息。</li>
</ul>
<p>也就是有双重限制，这种限制需要信道和队列之间协调，会耗费额外的性能。</p>
<h2 id="消息预读取的意义">消息预读取的意义</h2>
<p>消息预读取可以理解为RabbitMQ Broker把未确认的消息批量推送到RabbitMQ的Java客户端中，由客户端先缓存这些消息，然后投递到消费者中。试想，如果在推模式下，没有消息预读取功能，RabbitMQ Broker每次投递一条消息到客户端消费者中，这样就会产生大量的IO操作，导致性能下降，此外，消费者处理速度有可能比较快，容易产生消费者饥饿的情况。可以根据消费者实际的消费速度和消息发布的速度，对消费者的预读取未确认消息的上限进行配置，这样在大多数场景下可以提高消费者的性能。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/blog/archives/2018/">
            <section class="post prev white-box card-shadow " >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          2 / 3
        </p>
        
          <a class="next" rel="next" href="/blog/archives/2018/page/3/">
            <section class="post next white-box card-shadow ">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


	
</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>




	<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
	

	


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
