<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2019/2 | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 5px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      <div class='l_main'>
	
		
  <section class="post-list ">
    
      
        
          
        
          
        
          
        
          
        
      
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/17/java-concurrency-threadlocal-source-code/">
      ThreadLocal源码分析-黄金分割数的使用
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月17日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Concurrency/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Concurrency</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：27分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-23T23:25:45+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年6月23日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/g-t-2.png" alt=""></p>
<h2 id="前提">前提</h2>
<p>最近接触到的一个项目要兼容新老系统，最终采用了<code>ThreadLocal</code>(实际上用的是<code>InheritableThreadLocal</code>)用于在子线程获取父线程中共享的变量。问题是解决了，但是后来发现对<code>ThreadLocal</code>的理解不够深入，于是顺便把它的源码阅读理解了一遍。在谈到<code>ThreadLocal</code>之前先买个关子，先谈谈黄金分割数。本文在阅读<code>ThreadLocal</code>源码的时候是使用JDK8(1.8.0_181)。</p>
      
        
          <div class="button readmore">
            <a href="/2019/02/17/java-concurrency-threadlocal-source-code/" class="flat-box">
              <i class="fas fa-book-open fa-fw" aria-hidden="true"></i>
              阅读全文
            </a>
          </div>
        
      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/ThreadLocal/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> ThreadLocal</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/16/java-security-cipher/">
      JDK安全模块JCE核心Cipher使用详解
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：33分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-02-16T23:05:55+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年2月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JDK安全模块JCE核心Cipher使用详解</h1>
<h2 id="前提">前提</h2>
<p><code>javax.crypto.Cipher</code>，翻译为密码，其实叫做<strong>密码器</strong>更加合适。Cipher是JCA(Java Cryptographic Extension，Java加密扩展)的核心，提供基于多种加解密算法的加解密功能。在不了解Cipher之前，我们在完成一些需要加解密的模块的时候总是需要到处拷贝代码，甚至有些错误的用法也被无数次拷贝，踩坑之后又要拷贝补坑的代码。为什么不尝试理解Cipher然后合理地使用呢？</p>
<h2 id="Cipher初始化transformation-转换模式-的一些知识补充">Cipher初始化transformation(转换模式)的一些知识补充</h2>
<p>转换模式transformation一般由三个部分组成，格式是：<strong>算法/工作模式/填充模式(algorithm/mode/padding)</strong>。例如：DES/CBC/PKCS5Padding。</p>
<h3 id="算法">算法</h3>
<p>算法就是指具体加解密算法的名称英文字符串，例如&quot;SHA-256&quot;、&quot;RSA&quot;等，这里不对具体算法的实现原理做具体展开。</p>
<h3 id="工作模式">工作模式</h3>
<p>工作模式其实主要是针对分组密码。分组密码是将明文消息编码表示后的数字（简称明文数字）序列，划分成长度为n的组（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列。工作模式的出现主要基于下面原因：</p>
<ul>
<li>当需要加密的明文长度十分大(例如文件内容)，由于硬件或者性能原因需要分组加密。</li>
<li>多次使用相同的密钥对多个分组加密，会引发许多安全问题。</li>
</ul>
<p>从本质上讲，工作模式是一项增强密码算法或者使算法适应具体应用的技术，例如将分组密码应用于数据块组成的序列或者数据流。目前主要包括下面五种由NIST定义的工作模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">电子密码本(ECB)</td>
<td style="text-align:center">Electronic CodeBook</td>
<td style="text-align:center">用相同的密钥分别对明文分组独立加密</td>
<td style="text-align:center">单个数据的安全传输(例如一个加密密钥)</td>
</tr>
<tr>
<td style="text-align:center">密码分组链接(CBC)</td>
<td style="text-align:center">Cipher Block Chaining</td>
<td style="text-align:center">加密算法的输入是上一个密文组合下一个明文组的异或</td>
<td style="text-align:center">面向分组的通用传输或者认证</td>
</tr>
<tr>
<td style="text-align:center">密文反馈(CFB)</td>
<td style="text-align:center">Cipher FeedBack</td>
<td style="text-align:center">一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一单元的密文</td>
<td style="text-align:center">面向分组的通用传输或者认证</td>
</tr>
<tr>
<td style="text-align:center">输出反馈(OFB)</td>
<td style="text-align:center">Output FeedBack</td>
<td style="text-align:center">与CFB类似，只是加密算法的输入是上一次加密的输出，并且使用整个分组</td>
<td style="text-align:center">噪声信道上的数据流的传输(如卫星通信)</td>
</tr>
<tr>
<td style="text-align:center">计数器(CTR)</td>
<td style="text-align:center">Counter</td>
<td style="text-align:center">每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增</td>
<td style="text-align:center">面向分组的通用传输或者用于高速需求</td>
</tr>
</tbody>
</table>
<p>上面五种工作模式可以用于3DES和AES在内的任何分组密码，至于选择哪一种工作模式需要结合实际情况分析。</p>
<h3 id="填充模式">填充模式</h3>
<p>Padding指的是：块加密算法要求原文数据长度为固定块大小的整数倍，如果原文数据长度大于固定块大小，则需要在固定块填充数据直到整个块的数据是完整的。例如我们约定块的长度为128，但是需要加密的原文长度为129，那么需要分成两个加密块，第二个加密块需要填充127长度的数据，填充模式决定怎么填充数据。</p>
<p>对数据在加密时进行填充、解密时去除填充则是通信双方需要重点考虑的因素。对原文进行填充，主要基于以下原因：</p>
<ul>
<li>首先，考虑安全性。由于对原始数据进行了填充，使原文能够“伪装”在填充后的数据中，使得攻击者很难找到真正的原文位置。</li>
<li>其次，由于块加密算法要求原文数据长度为固定块大小的整数倍，如果加密原文不满足这个条件，则需要在加密前填充原文数据至固定块大小的整数倍。</li>
<li>另外，填充也为发送方与接收方提供了一种标准的形式以约束加密原文的大小。只有加解密双方知道填充方式，才可知道如何准确移去填充的数据并进行解密。</li>
</ul>
<p>常用的填充方式至少有5种，不同编程语言实现加解密时用到的填充多数来自于这些方式或它们的变种方式。以下五种填充模式摘抄自参考资料的论文：</p>
<p><strong>1.填充数据为填充字节序列的长度</strong>：</p>
<p>这种填充方式中，填充字符串由一个字节序列组成，每个字节填充该字节序列的长度。假定块长度为8，原文数据长度为9，则填充字节数 等于0x07；如果明文数据长度为8的整数倍，则填充字节数为0x08。填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</li>
<li>==========================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 08 08 08 08 08 08 08 08</li>
</ul>
<p><strong>2.填充数据为0x80后加0x00</strong>：</p>
<p>这种填充方式中，填充字符串的第一个字节数是0x80，后面的每个字节是0x00。假定块长度为8，原文数据长度为9或者为8的整数倍，则 填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00</li>
<li>==========================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00 00</li>
</ul>
<p><strong>3.填充数据的最后一个字节为填充字节序列的长度</strong>：</p>
<p>这种填充方式中，填充字符串的最后一个字节为该序列的长度，而前面的字节可以是0x00，也可以是随机的字节序列。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：</p>
<ul>
<li>原文数据1:FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07或FF FF FF FF FF FF FF FF FF 0A B0 0C 08 05 09 07</li>
<li>===============================================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 08或FF FF FF FF FF FF FF FF 80 06 AB EA 03 02 01 08</li>
</ul>
<p><strong>4.填充数据为空格</strong>：</p>
<p>这种填充方式中，填充字符串的每个字节为空格对应的字节数0x20。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20</li>
<li>===============================================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20 20</li>
</ul>
<p><strong>5.填充数据为0x00</strong>：</p>
<p>这种填充方式中，填充字符串的每个字节为0x00。假定块长度为8，原文数据长度为9或者8的整数倍，则填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00</li>
<li>===============================================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00</li>
</ul>
<h2 id="transformation小结">transformation小结</h2>
<p>SunJCE Provider支持的Cipher的部分详细信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">algorithm(算法)</th>
<th style="text-align:center">mode(工作模式)</th>
<th style="text-align:center">padding(填充模式)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AES</td>
<td style="text-align:center">EBC、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128等</td>
<td style="text-align:center">NoPadding、ISO10126Padding、PKCS5Padding</td>
</tr>
<tr>
<td style="text-align:center">AESWrap</td>
<td style="text-align:center">EBC</td>
<td style="text-align:center">NoPadding</td>
</tr>
<tr>
<td style="text-align:center">ARCFOUR</td>
<td style="text-align:center">EBC</td>
<td style="text-align:center">NoPadding</td>
</tr>
<tr>
<td style="text-align:center">Blowfish、DES、DESede、RC2</td>
<td style="text-align:center">EBC、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128等</td>
<td style="text-align:center">NoPadding、ISO10126Padding、PKCS5Padding</td>
</tr>
<tr>
<td style="text-align:center">DESedeWrap</td>
<td style="text-align:center">CBC</td>
<td style="text-align:center">NoPadding</td>
</tr>
<tr>
<td style="text-align:center">PBEWithMD5AndDES、PBEWithMD5AndTripleDES、PBEWithSHA1AndDESede、PBEWithSHA1AndRC2_40</td>
<td style="text-align:center">CBC</td>
<td style="text-align:center">PKCS5Padding</td>
</tr>
<tr>
<td style="text-align:center">RSA</td>
<td style="text-align:center">ECB、NONE</td>
<td style="text-align:center">NoPadding、PKCS1Padding等</td>
</tr>
</tbody>
</table>
<p>Java原生支持的Padding(Cipher)汇总如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">填充模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NoPadding</td>
<td style="text-align:center">不采用填充模式</td>
</tr>
<tr>
<td style="text-align:center">ISO10126Padding</td>
<td style="text-align:center">XML加密语法和处理文档中有详细描述</td>
</tr>
<tr>
<td style="text-align:center">OAEPPadding, OAEPWith&lt;digest&gt;And&lt;mgf&gt;Padding</td>
<td style="text-align:center">PKCS1中定义的最优非对称加密填充方案，digest代表消息摘要类型，mgf代表掩码生成函数，例如：OAEPWithMD5AndMGF1Padding或者OAEPWithSHA-512AndMGF1Padding</td>
</tr>
<tr>
<td style="text-align:center">PKCS1Padding</td>
<td style="text-align:center">PKCS1，RSA算法使用</td>
</tr>
<tr>
<td style="text-align:center">PKCS5Padding</td>
<td style="text-align:center">PKCS5，RSA算法使用</td>
</tr>
<tr>
<td style="text-align:center">SSL3Padding</td>
<td style="text-align:center">见SSL Protocol Version 3.0的定义</td>
</tr>
</tbody>
</table>
<p>其他Padding需要第三方Provider提供。</p>
<h2 id="Cipher的属性和方法">Cipher的属性和方法</h2>
<h3 id="Cipher的七个主要公有属性">Cipher的七个主要公有属性</h3>
<ul>
<li>1、ENCRYPT_MODE，整型值1，加密模式，用于Cipher的初始化。</li>
<li>2、DECRYPT_MODE，整型值2，解密模式，用于Cipher的初始化。</li>
<li>3、WRAP_MODE，整型值3，包装密钥模式，用于Cipher的初始化。</li>
<li>4、UNWRAP_MODE，整型值4，解包装密钥模式，用于Cipher的初始化。</li>
<li>5、PUBLIC_KEY，整型值1，解包装密钥模式下指定密钥类型为公钥。</li>
<li>6、PRIVATE_KEY，整型值2，解包装密钥模式下指定密钥类型为私钥。</li>
<li>7、SECRET_KEY，整型值3，解包装密钥模式下指定密钥类型为密钥，主要用于不是非对称加密的密钥(只有一个密钥，不包含私钥和公钥)。</li>
</ul>
<h3 id="getInstance方法">getInstance方法</h3>
<p>Cipher提供三个静态工厂方法<code>getInstance()</code>用于构建其实例，三个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cipher <span class="title">getInstance</span><span class="params">(String transformation)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> NoSuchAlgorithmException,</span></span><br><span class="line"><span class="function">                                       NoSuchPaddingException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cipher <span class="title">getInstance</span><span class="params">(String transformation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String provider)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> NoSuchAlgorithmException,</span></span><br><span class="line"><span class="function">                                       NoSuchProviderException,</span></span><br><span class="line"><span class="function">                                       NoSuchPaddingException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cipher <span class="title">getInstance</span><span class="params">(String transformation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Provider provider)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> NoSuchAlgorithmException,</span></span><br><span class="line"><span class="function">                                       NoSuchPaddingException</span></span><br></pre></td></tr></table></figure>
<p>其中transformation，这里称为<strong>转换(模式)</strong>，是核心参数，见前面一个小节的解析。另外，有两个工厂方法要求必须传入java.security.Provider的全类名或者实例，因为Cipher要从对应的提供商中获取指定转换模式的实现，第一个工厂方法只有单参数transformation，它会从现成所有的<code>java.security.Provider</code>中匹配取出第一个满足transformation的服务，从中实例化<code>CipherSpi</code>(<strong>要理解Cipher委托到内部持有的CipherSpi实例完成具体的加解密功能</strong>)。实际上Cipher实例的初始化必须依赖于转换模式和提供商。</p>
<h3 id="init方法">init方法</h3>
<p><code>init()</code>方法一共有八个变体方法，此方法主要用于初始化Cipher。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//额外参数是Key(密钥)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)和SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)和AlgorithmParameterSpec(算法参数透明定义)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameterSpec params)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)、AlgorithmParameterSpec(算法参数透明定义)和SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameterSpec params,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)、AlgorithmParameters(算法参数)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameters params)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)、AlgorithmParameters(算法参数)、SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameters params,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Certificate(证书)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Certificate certificate)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Certificate(证书)、SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Certificate certificate,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br></pre></td></tr></table></figure>
<p>opmode(操作模式)是必须参数，可选值是ENCRYPT_MODE、DECRYPT_MODE、WRAP_MODE和UNWRAP_MODE。Key类型参数如果不是非对称加密，对应的类型是SecretKey，如果是非对称加密，可以是PublicKey或者PrivateKey。SecureRandom是随机源，因为有些算法需要每次加密结果都不相同，这个时候需要依赖系统或者传入的随机源，一些要求每次加解密结果相同的算法如AES不能使用此参数。Certificate是带有密钥的证书实现。算法参数主要包括IV(initialization vector，初始化向量)等等。</p>
<h3 id="wrap方法和unwrap方法">wrap方法和unwrap方法</h3>
<p>wrap方法用于包装一个密钥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] wrap(Key key)</span><br><span class="line">                  <span class="keyword">throws</span> IllegalBlockSizeException,</span><br><span class="line">                         InvalidKeyException</span><br></pre></td></tr></table></figure>
<p>wrap方法使用的时候需要注意Cipher的opmode要初始化为WRAP_MODE。</p>
<p>unwrap方法用于解包装一个密钥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Key <span class="title">unwrap</span><span class="params">(<span class="keyword">byte</span>[] wrappedKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String wrappedKeyAlgorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> wrappedKeyType)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                        NoSuchAlgorithmException</span></span><br></pre></td></tr></table></figure>
<p>unwrap方法使用的时候需要注意Cipher的opmode要初始化为UNWRAP_MODE，在调用unwrap方法时候，需要指定之前包装密钥的算法和Key的类型。</p>
<p>其实wrap和unwrap是一个互逆的操作：</p>
<ul>
<li>wrap方法的作用是把原始的密钥通过某种加密算法包装为加密后的密钥，这样就可以避免在传递密钥的时候泄漏了密钥的明文。</li>
<li>unwrap方法的作用是把包装(加密)后的密钥解包装为原始的密钥，得到密钥的明文。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncryptUtils &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRECT = <span class="string">"passwrod"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">wrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.WRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKeySpec key = <span class="keyword">new</span> SecretKeySpec(keyString.getBytes(), <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.wrap(key);</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">unwrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = Hex.decodeHex(keyString);</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.UNWRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKey key = (SecretKey) cipher.unwrap(rawKey, <span class="string">"AES"</span>, Cipher.SECRET_KEY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String wrapKey = EncryptUtils.SINGLETON.wrap(<span class="string">"doge"</span>);</span><br><span class="line">        System.out.println(wrapKey);</span><br><span class="line">        System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是通过AES对密钥进行包装和解包装，调用main方法，输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">77050742188</span>d4b97a1d401db902b864d</span><br><span class="line">doge</span><br></pre></td></tr></table></figure>
<h3 id="update方法">update方法</h3>
<p>update方法有多个变体，其实意义相差无几：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] update(<span class="keyword">byte</span>[] input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] update(<span class="keyword">byte</span>[] input,</span><br><span class="line">                           <span class="keyword">int</span> inputOffset,</span><br><span class="line">                           <span class="keyword">int</span> inputLen)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> inputLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">byte</span>[] output)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> ShortBufferException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(ByteBuffer input,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ByteBuffer output)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> ShortBufferException</span></span><br></pre></td></tr></table></figure>
<p>update方法主要用于部分加密或者部分解密，至于加密或是解密取决于Cipher初始化时候的opmode。即使它有多个变体，但是套路是一样的：依赖于一个输入的缓冲区(带有需要被加密或者被解密的数据)、返回值或者参数是一个输出的缓冲区，一些额外的参数可以通过偏移量和长度控制加密或者解密操作的数据段。部分加密或者解密操作完毕后，必须要调用<code>Cipher#doFinal()</code>方法来结束加密或者解密操作。</p>
<h3 id="doFinal方法">doFinal方法</h3>
<p><code>doFinal()</code>方法也存在多个变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束多部分加密或者解密操作。</span></span><br><span class="line"><span class="comment"> * 此方法需要在update调用链执行完毕之后调用，返回的结果是加密或者解密结果的一部分。</span></span><br><span class="line"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] doFinal()</span><br><span class="line">                     <span class="keyword">throws</span> IllegalBlockSizeException,</span><br><span class="line">                            BadPaddingException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束多部分加密或者解密操作。</span></span><br><span class="line"><span class="comment"> * 此方法需要在update调用链执行完毕之后调用，传入的output作为缓冲区接收加密或者解密结果的一部分。</span></span><br><span class="line"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] output,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> outputOffset)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         ShortBufferException,</span></span><br><span class="line"><span class="function">                         BadPaddingException                         </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法接收需要加密或者解密的完整报文，返回处理结果</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input)</span></span></span><br><span class="line"><span class="function">                     <span class="keyword">throws</span> IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                            BadPaddingException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> inputLen)</span></span></span><br><span class="line"><span class="function">                     <span class="keyword">throws</span> IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                            BadPaddingException      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度，output用于接收加解密的结果</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">byte</span>[] output)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> ShortBufferException,</span></span><br><span class="line"><span class="function">                         IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         BadPaddingException                                                         </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * output用于接收加解密的结果，outputOffset用于设置output的起始位置</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">byte</span>[] output,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> outputOffset)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> ShortBufferException,</span></span><br><span class="line"><span class="function">                         IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         BadPaddingException </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数input为输入缓冲区，output为输出缓冲区</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(ByteBuffer input,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ByteBuffer output)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> ShortBufferException,</span></span><br><span class="line"><span class="function">                         IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         BadPaddingException</span></span><br></pre></td></tr></table></figure>
<p><code>doFinal()</code>主要功能是结束单部分或者多部分加密或者解密操作。单部分加密或者解密适用于需要处理的报文长度较短无需分块的情况，这个时候直接使用<code>byte[] doFinal(byte[] input)</code>方法即可。多部分加密或者解密适用于需要处理的报文长度长度较大，需要进行分块的情况，这个时候需要调用多次<code>update</code>方法变体进行部分块的加解密，最后调用<code>doFinal</code>方法变体进行部分加解密操作的结束。举个例子，例如处理块的大小为8，实际需要加密的报文长度为23，那么需要分三块进行加密，前面2块长度为8的报文需要调用update进行部分加密，部分加密的结果可以从update的返回值获取到，最后的7长度(其实一般会填充到长度为块长度8)的报文则调用doFinal进行加密，结束整个部分加密的操作。另外，值得注意的是只要Cipher正常调用完任一个<code>doFinal</code>变体方法(过程中不抛出异常)，那么Cipher会重置为初始化状态，可以继续使用，这个可复用的特性可以降低创建Cipher实例的性能损耗。</p>
<h3 id="updateADD方法">updateADD方法</h3>
<p>首先ADD的意思是Additional Authentication Data(额外的身份认证数据)。<code>updateADD()</code>也有三个方法变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAAD</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAAD</span><span class="params">(<span class="keyword">byte</span>[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAAD</span><span class="params">(ByteBuffer src)</span></span></span><br></pre></td></tr></table></figure>
<p>它的方法变体都只依赖一个输入缓冲区，带有额外的身份认证数据，一般使用在<code>GCM</code>或者<code>CCM</code>加解密算法中。如果使用此方法，它的调用必须在Cipher的<code>update</code>和<code>doFinal</code>变体方法之前调用，其实理解起来也很简单，身份验证必须在实际的加解密操作之前进行。目前，<code>updateADD</code>的资料比较少，笔者在生产环境找那个也尚未实践过，所以不做展开分析。</p>
<h3 id="其他方法">其他方法</h3>
<p>其他方法主要是Getter方法，用于获取Cipher的相关信息。</p>
<ul>
<li><code>public final Provider getProvider()</code>：获取Cipher的提供商。</li>
<li><code>public final String getAlgorithm()</code>：获取Cipher使用的算法名称。</li>
<li><code>public final int getBlockSize()</code>：分组加密中，每一组都有固定的长度，也称为块，此方法是返回块的大小（以字节为单位）。</li>
<li><code>public final int getOutputSize(int inputLen)</code>：根据给定的输入长度inputLen（以字节为单位），返回保存下一个update或doFinal操作结果所需的输出缓冲区长度（以字节为单位）。</li>
<li><code>public final byte[] getIV()</code>：返回Cipher中的初始化向量的字节数组。</li>
<li><code>public final AlgorithmParameters getParameters()</code>：返回Cipher使用的算法参数。</li>
<li><code>public final ExemptionMechanism getExemptionMechanism()</code>：返回Cipher使用的豁免(exemption)机制对象。</li>
<li><code>public static final int getMaxAllowedKeyLength(String transformation)</code>：根据所安装的JCE策略文件，返回指定转换的最大密钥长度。</li>
<li><code>public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation)</code>：根据JCE策略文件，返回Cipher指定transformation下最大的AlgorithmParameterSpec对象。</li>
</ul>
<h2 id="Cipher的工作流程">Cipher的工作流程</h2>
<p>下面画一个图来详细分析一下Cipher的工作流程：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/cipher-1.png" alt="cipher-1"></p>
<p>当然上图只分析了Cipher的使用过程，其实还有一个重要的步骤就是密钥的处理，但是密钥的处理和具体的算法使用是相关的，所以图中没有体现。再放一张官方描述Cipher加载的流程：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/cipher-2.png" alt="cipher-2"></p>
<p>主要过程包括：</p>
<ul>
<li>1、创建Cipher实例，这个时候会从平台中所有的提供商(Provider)中根据transformation匹配第一个可以使用的CipherSpi实例，&quot;算法/工作模式/填充模式&quot;必须完全匹配才能选中。</li>
</ul>
<blockquote>
<p>在${JAVA_HONE}/jre/lib/security中的java.security文件中可以看到默认加载的提供商。如果需要添加额外或者自实现的Provider，可以通过java.security.Security的静态方法addProvider添加。</p>
</blockquote>
<ul>
<li>2、通过Cipher实例的init方法初始化Cipher，主要参数是opmode和密钥。</li>
<li>3、根据初始化的方式和是否需要分组处理，选择合适的方法进行调用，一般以<code>doFinal()</code>方法作结得到返回结果。</li>
</ul>
<h2 id="Cipher的使用">Cipher的使用</h2>
<p>为了方便Cipher的使用，最好先引入<code>apache-codec</code>依赖，这样能简化Hex、Base64等操作。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大多数情况下，加密后的byte数组的中元素取值不在Unicode码点的范围内，表面上看到的就是乱码，实际上它们是有意义的，因此需要考虑把这种byte数组转换为非乱码的字符串以便传输，常见的方式有Hex(二进制转换为十六进制)、Base64等等。下面举例中没有针对异常类型进行处理统一外抛，切勿模仿，还有，所有的字符串转化为字节数组都没有指定字符编码，因此只能使用非中文的明文进行处理。</p>
<h3 id="加密模式">加密模式</h3>
<p>加密模式下，Cipher只能用于加密，主要由<code>init()</code>方法中的opmode决定。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">encryptByAes</span><span class="params">(String content, String password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//这里指定了算法为AES_128，工作模式为EBC，填充模式为NoPadding</span></span><br><span class="line">	Cipher cipher = Cipher.getInstance(<span class="string">"AES_128/ECB/NoPadding"</span>);</span><br><span class="line">	KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">	keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(password.getBytes()));</span><br><span class="line">	SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">	SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//基于加密模式和密钥初始化Cipher</span></span><br><span class="line">	cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">	<span class="comment">//单部分加密结束，重置Cipher</span></span><br><span class="line">	<span class="keyword">byte</span>[] bytes = cipher.doFinal(content.getBytes());</span><br><span class="line">	<span class="comment">//加密后的密文由二进制序列转化为十六进制序列，依赖apache-codec包</span></span><br><span class="line">	<span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实整个过程Cipher的使用都很简单，比较复杂的反而是密钥生成的过程。上面的例子需要注意，因为使用了填充模式为NoPadding，输入的需要加密的报文长度必须是16(128bit)的倍数。</p>
<h3 id="解密模式">解密模式</h3>
<p>解密模式的使用大致和加密模式是相同的，把处理过程逆转过来就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decryptByAes</span><span class="params">(String content, String password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//这里要把十六进制的序列转化回二进制的序列，依赖apache-codec包</span></span><br><span class="line">	<span class="keyword">byte</span>[] bytes = Hex.decodeHex(content);</span><br><span class="line">	<span class="comment">//这里指定了算法为AES_128，工作模式为EBC，填充模式为NoPadding</span></span><br><span class="line">	Cipher cipher = Cipher.getInstance(<span class="string">"AES_128/ECB/NoPadding"</span>);</span><br><span class="line">	KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">	keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(password.getBytes()));</span><br><span class="line">	SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">	SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//基于解密模式和密钥初始化Cipher</span></span><br><span class="line">	cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">	<span class="comment">//单部分加密结束，重置Cipher</span></span><br><span class="line">	<span class="keyword">byte</span>[] result = cipher.doFinal(bytes);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子需要注意，因为使用了填充模式为NoPadding，输入的需要加密的报文长度必须是16(128bit)的倍数。</p>
<h3 id="包装密钥模式和解包装密钥模式">包装密钥模式和解包装密钥模式</h3>
<p>密钥的包装和解包装模式是一对互逆的操作，主要作用是通过算法对密钥进行加解密，从而提高密钥泄漏的难度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncryptUtils &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRECT = <span class="string">"passwrod"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">wrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.WRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKeySpec key = <span class="keyword">new</span> SecretKeySpec(keyString.getBytes(), <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.wrap(key);</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">unwrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = Hex.decodeHex(keyString);</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.UNWRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKey key = (SecretKey) cipher.unwrap(rawKey, <span class="string">"AES"</span>, Cipher.SECRET_KEY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String wrapKey = EncryptUtils.SINGLETON.wrap(<span class="string">"doge"</span>);</span><br><span class="line">        System.out.println(wrapKey);</span><br><span class="line">        System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组-部分-加密和分组解密">分组(部分)加密和分组解密</h3>
<p>当一个需要加密的报文十分长的时候，我们可以考虑把报文切割成多个小段，然后针对每个小段进行加密，这就是分组加密。分组解密的过程类同，可以看作是分组加密的逆向过程。下面还是用AES算法为例举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> throwable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/15 1:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Part &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * SINGLETON</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SINGLETON;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"throwable"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cipher <span class="title">createCipher</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Cipher cipher = createCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(PASSWORD.getBytes()));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//基于加密模式和密钥初始化Cipher</span></span><br><span class="line">		cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">		<span class="keyword">byte</span>[] raw = content.getBytes();</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//[0,9]</span></span><br><span class="line">		<span class="keyword">byte</span>[] first = cipher.update(raw, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">		builder.append(Hex.encodeHexString(first));</span><br><span class="line">		<span class="comment">//[10,19]</span></span><br><span class="line">		<span class="keyword">byte</span>[] second = cipher.update(raw, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">		builder.append(Hex.encodeHexString(second));</span><br><span class="line">		<span class="comment">//[20,25]</span></span><br><span class="line">		<span class="keyword">byte</span>[] third = cipher.update(raw, <span class="number">20</span>, <span class="number">6</span>);</span><br><span class="line">		builder.append(Hex.encodeHexString(third));</span><br><span class="line">		<span class="comment">//多部分加密结束，得到最后一段加密的结果，重置Cipher</span></span><br><span class="line">		<span class="keyword">byte</span>[] bytes = cipher.doFinal();</span><br><span class="line">		String last = Hex.encodeHexString(bytes);</span><br><span class="line">		builder.append(last);</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] raw = Hex.decodeHex(content);</span><br><span class="line">		Cipher cipher = createCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(PASSWORD.getBytes()));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//基于解密模式和密钥初始化Cipher</span></span><br><span class="line">		cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//[0,14]</span></span><br><span class="line">		<span class="keyword">byte</span>[] first = cipher.update(raw, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(first));</span><br><span class="line">		<span class="comment">//[15,29]</span></span><br><span class="line">		<span class="keyword">byte</span>[] second = cipher.update(raw, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(second));</span><br><span class="line">		<span class="comment">//[30,31]</span></span><br><span class="line">		<span class="keyword">byte</span>[] third = cipher.update(raw, <span class="number">30</span>, <span class="number">2</span>);</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(third));</span><br><span class="line">		<span class="comment">//多部分解密结束，得到最后一段解密的结果，重置Cipher</span></span><br><span class="line">		<span class="keyword">byte</span>[] bytes = cipher.doFinal();</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(bytes));</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String raw = <span class="string">"abcdefghijklmnopqrstyuwxyz"</span>;</span><br><span class="line">		String e = Part.SINGLETON.encrypt(raw);</span><br><span class="line">		System.out.println(e);</span><br><span class="line">		System.out.println(Part.SINGLETON.decrypt(e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的分段下标已经在注释中给出，分段的规则由实际情况考虑，一般AES加解密报文不大的时候可以直接单部分加解密即可，这里仅仅是为了做展示。</p>
<h3 id="查看当前JDK中Cipher的所有提供商">查看当前JDK中Cipher的所有提供商</h3>
<p>我们可以直接查看当前的使用的JDK中Cipher的所有提供商和支持的加解密服务，简单写个main函数就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.Provider;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Provider[] providers = Security.getProviders();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != providers) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Provider provider : providers) &#123;</span><br><span class="line">				Set&lt;Provider.Service&gt; services = provider.getServices();</span><br><span class="line">				<span class="keyword">for</span> (Provider.Service service : services) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">"Cipher"</span>.equals(service.getType())) &#123;</span><br><span class="line">						System.out.println(String.format(<span class="string">"provider:%s,type:%s,algorithm:%s"</span>, service.getProvider(), service.getType(), service.getAlgorithm()));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者编写这篇文章的时候使用的JDK是JDK8的最后一个更新的版本8u181(1.8.0_181)，运行main函数输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:RSA</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:DES</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:DESede</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:DESedeWrap</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithMD5AndDES</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithMD5AndTripleDES</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithSHA1AndDESede</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithSHA1AndRC2_40</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithSHA1AndRC2_128</span><br><span class="line">.....输出内容太多忽略剩余部分</span><br></pre></td></tr></table></figure>
<h2 id="扩展">扩展</h2>
<p>因为Java原生支持的transformation是有限的，有些时候我们需要使用一些算法其他工作模式或者填充模式原生无法支持，这个时候我们需要引入第三方的Provider甚至自己实现Provider。常见的第三方Provider是bouncycastle(BC)，目前BC的最新依赖为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcprov-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举个例子，Java原生是不支持AESWRAP算法的，因此可以引入BC的依赖，再使用转换模式AESWRAP。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncryptUtils &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * SINGLETON</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SINGLETON;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET = <span class="string">"throwable"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装载BC提供商</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cipher <span class="title">createAesCipher</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cipher.getInstance(<span class="string">"AESWRAP"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">encryptByAes</span><span class="params">(String raw)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Cipher aesCipher = createAesCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AESWRAP"</span>);</span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRET.getBytes(CHARSET)));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AESWRAP"</span>);</span><br><span class="line">		aesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = aesCipher.doFinal(raw.getBytes(CHARSET));</span><br><span class="line">		<span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">decryptByAes</span><span class="params">(String raw)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = Hex.decodeHex(raw);</span><br><span class="line">		Cipher aesCipher = createAesCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AESWRAP"</span>);</span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRET.getBytes(CHARSET)));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AESWRAP"</span>);</span><br><span class="line">		aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(aesCipher.doFinal(bytes), CHARSET);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String raw = <span class="string">"throwable-a-doge"</span>;</span><br><span class="line">		String en = EncryptUtils.SINGLETON.encryptByAes(raw);</span><br><span class="line">		System.out.println(en);</span><br><span class="line">		String de = EncryptUtils.SINGLETON.decryptByAes(en);</span><br><span class="line">		System.out.println(de);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子需要注意，因为使用了AESWRAP算法，输入的需要加密的报文长度必须是8的倍数。</p>
<h2 id="小结">小结</h2>
<p>熟练掌握Cipher的用法、转换模式transformation的一些知识之后，影响我们编写加解密模块代码的主要因素就是加解密算法的原理或者使用，这些需要我们去学习专门的加解密算法相关的知识。另外，<strong>有些时候我们发现不同平台或者不同语言使用同一个加密算法不能相互解密加密</strong>，其实原因很简单，绝大部分原因是工作模式选取或者填充模式选取的不同导致的，排除掉这两点，剩下的可能性就是算法的实现不相同，依据这三点因素(或者说就是transformation这唯一的因素)去判断和寻找解决方案即可。关于加解密算法原理、工作模式等相关知识可以参考下面的资料。</p>
<p>参考资料：</p>
<ul>
<li>《密码编码学与网络安全-原理与实践(第六版)》</li>
<li>《信息安全原理与实践(第2版)》</li>
<li>《关于加密数据的填充方式的研究》</li>
<li>JDK8文档</li>
</ul>
<p>另外，一些特殊的方法例如<code>Ciper#updateADD()</code>暂时没遇到使用场景，这里就不写没实践过的Demo。</p>
<p>(本文完 e-a-20190216 c-7-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Security/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Security</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/16/java-archunit-research/">
      项目架构级别规约框架Archunit调研
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Framework/Archunit/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Framework&nbsp;/&nbsp;Archunit</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：14分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-02-16T22:44:09+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年2月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>项目架构级别规约框架Archunit调研</h1>
<h2 id="背景">背景</h2>
<p>最近在做一个新项目的时候引入了一个架构方面的需求，就是需要检查项目的编码规范、模块分类规范、类依赖规范等，刚好接触到，正好做个调研。</p>
<p>很多时候，我们会制定项目的规范，例如：</p>
<ul>
<li>硬性规定项目包结构中service层不能引用controller层的类(这个例子有点极端)。</li>
<li>硬性规定定义在controller包下的Controller类的类名称以&quot;Controller&quot;结尾，方法的入参类型命名以&quot;Request&quot;结尾，返回参数命名以&quot;Response&quot;结尾。</li>
<li>枚举类型必须放在common.constant包下，以类名称Enum结尾。</li>
</ul>
<p>还有很多其他可能需要定制的规范，最终可能会输出一个文档。但是，谁能保证所有参数开发的人员都会按照文档的规范进行开发？为了保证规范的实行，Archunit以单元测试的形式通过扫描类路径(甚至Jar)包下的所有类，通过单元测试的形式对各个规范进行代码编写，如果项目代码中有违背对应的单测规范，那么单元测试将会不通过，这样就可以从CI/CD层面彻底把控项项目架构和编码规范。</p>
<h2 id="简介">简介</h2>
<p><a href="https://www.archunit.org" target="_blank" rel="noopener">Archunit</a>是一个免费、简单、可扩展的类库，用于检查Java代码的体系结构。提供检查包和类的依赖关系、调用层次和切面的依赖关系、循环依赖检查等其他功能。它通过导入所有类的代码结构，基于Java字节码分析实现这一点。<strong>的主要关注点是使用任何普通的Java单元测试框架自动测试代码体系结构和编码规则</strong>。</p>
<h2 id="引入依赖">引入依赖</h2>
<p>一般来说，目前常用的测试框架是Junit4，需要引入Junit4和archunit：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.tngtech.archunit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>archunit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>junit4</code>中依赖到slf4j，因此最好在测试依赖中引入一个slf4j的实现，例如logback：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="如何使用">如何使用</h2>
<p>主要从下面的两个方面介绍一下的使用：</p>
<ul>
<li>指定参数进行类扫描。</li>
<li>内建规则定义。</li>
</ul>
<h3 id="指定参数进行类扫描">指定参数进行类扫描</h3>
<p>需要对代码或者依赖规则进行判断前提是要导入所有需要分析的类，类扫描导入依赖于<code>ClassFileImporter</code>，底层依赖于ASM字节码框架针对类文件的字节码进行解析，性能会比基于反射的类扫描框架高很多。<code>ClassFileImporter</code>的构造可选参数为<code>ImportOption(s)</code>，扫描规则可以通过<code>ImportOption</code>接口实现，默认提供可选的规则有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不包含测试类</span></span><br><span class="line">ImportOption.Predefined.DONT_INCLUDE_TESTS</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不包含Jar包里面的类</span></span><br><span class="line">ImportOption.Predefined.DONT_INCLUDE_JARS</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不包含Jar和Jrt包里面的类，JDK9的特性</span></span><br><span class="line">ImportOption.Predefined.DONT_INCLUDE_ARCHIVES</span><br></pre></td></tr></table></figure>
<p>举个例子，我们实现一个自定义的<code>ImportOption</code>实现，用于指定需要排除扫描的包路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DontIncludePackagesImportOption</span> <span class="keyword">implements</span> <span class="title">ImportOption</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Pattern&gt; EXCLUDED_PATTERN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DontIncludePackagesImportOption</span><span class="params">(String... packages)</span> </span>&#123;</span><br><span class="line">        EXCLUDED_PATTERN = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (String eachPackage : packages) &#123;</span><br><span class="line">            EXCLUDED_PATTERN.add(Pattern.compile(String.format(<span class="string">".*/%s/.*"</span>, eachPackage.replace(<span class="string">"/"</span>, <span class="string">"."</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(Location location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pattern pattern : EXCLUDED_PATTERN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (location.matches(pattern)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ImportOption</code>接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">includes</span><span class="params">(Location location)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，<code>Location</code>包含了路径信息、是否Jar文件等判断属性的元数据，方便使用正则表达式或者直接的逻辑判断。</p>
<p>接着我们可以通过上面实现的<code>DontIncludePackagesImportOption</code>去构造<code>ClassFileImporter</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ImportOptions importOptions = <span class="keyword">new</span> ImportOptions()</span><br><span class="line">        <span class="comment">// 不扫描jar包</span></span><br><span class="line">        .with(ImportOption.Predefined.DONT_INCLUDE_JARS)</span><br><span class="line">        <span class="comment">// 排除不扫描的包</span></span><br><span class="line">        .with(<span class="keyword">new</span> DontIncludePackagesImportOption(<span class="string">"com.sample..support"</span>));</span><br><span class="line">ClassFileImporter classFileImporter = <span class="keyword">new</span> ClassFileImporter(importOptions);</span><br></pre></td></tr></table></figure>
<p>得到<code>ClassFileImporter</code>实例后我们可以通过对应的方法导入项目中的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定类型导入单个类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClass <span class="title">importClass</span><span class="params">(Class&lt;?&gt; clazz)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 指定类型导入多个类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importClasses</span><span class="params">(Class&lt;?&gt;... classes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importClasses</span><span class="params">(Collection&lt;Class&lt;?&gt;&gt; classes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通过指定路径导入类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importUrl</span><span class="params">(URL url)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importUrls</span><span class="params">(Collection&lt;URL&gt; urls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importLocations</span><span class="params">(Collection&lt;Location&gt; locations)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通过类路径导入类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importClasspath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importClasspath</span><span class="params">(ImportOptions options)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通过文件路径导入类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPath</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPath</span><span class="params">(Path path)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPaths</span><span class="params">(String... paths)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPaths</span><span class="params">(Path... paths)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPaths</span><span class="params">(Collection&lt;Path&gt; paths)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通过Jar文件对象导入类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importJar</span><span class="params">(JarFile jar)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importJars</span><span class="params">(JarFile... jarFiles)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importJars</span><span class="params">(Iterable&lt;JarFile&gt; jarFiles)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通过包路径导入类 - 这个是比较常用的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPackages</span><span class="params">(Collection&lt;String&gt; packages)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPackages</span><span class="params">(String... packages)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPackagesOf</span><span class="params">(Class&lt;?&gt;... classes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JavaClasses <span class="title">importPackagesOf</span><span class="params">(Collection&lt;Class&lt;?&gt;&gt; classes)</span></span></span><br></pre></td></tr></table></figure>
<p>导入类的方法提供了多维度的参数，用起来会十分便捷。例如想导入<code>com.sample</code>包下面的所有类，只需要这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFileImporterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testImportBootstarpClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ImportOptions importOptions = <span class="keyword">new</span> ImportOptions()</span><br><span class="line">                <span class="comment">// 不扫描jar包</span></span><br><span class="line">                .with(ImportOption.Predefined.DONT_INCLUDE_JARS)</span><br><span class="line">                <span class="comment">// 排除不扫描的包</span></span><br><span class="line">                .with(<span class="keyword">new</span> DontIncludePackagesImportOption(<span class="string">"com.sample..support"</span>));</span><br><span class="line">        ClassFileImporter classFileImporter = <span class="keyword">new</span> ClassFileImporter(importOptions);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        JavaClasses javaClasses = classFileImporter.importPackages(<span class="string">"com.sample"</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(String.format(<span class="string">"Found %d classes,cost %d ms"</span>, javaClasses.size(), end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的<code>JavaClasses</code>是<code>JavaClass</code>的集合，可以简单类比为反射中<code>Class</code>的集合，后面使用的代码规则和依赖规则判断都是强依赖于<code>JavaClasses</code>或者<code>JavaClass</code>。</p>
<h3 id="内建规则定义">内建规则定义</h3>
<p>类扫描和类导入完成之后，我们需要定检查规则，然后应用于所有导入的类，这样子就能完成对所有的类进行规则的过滤 - 或者说把规则应用于所有类并且进行断言。</p>
<p>规则定义依赖于<code>ArchRuleDefinition</code>类，创建出来的规则是<code>ArchRule</code>实例，规则实例的创建过程一般使用<code>ArchRuleDefinition</code>类的流式方法，这些流式方法定义上符合人类思考的思维逻辑，上手比较简单，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.noClasses()</span><br><span class="line">    <span class="comment">// 在service包下的所有类</span></span><br><span class="line">    .that().resideInAPackage(<span class="string">"..service.."</span>)</span><br><span class="line">    <span class="comment">// 不能调用controller包下的任意类</span></span><br><span class="line">    .should().accessClassesThat().resideInAPackage(<span class="string">"..controller.."</span>)</span><br><span class="line">    <span class="comment">// 断言描述 - 不满足规则的时候打印出来的原因</span></span><br><span class="line">    .because(<span class="string">"不能在service包中调用controller中的类"</span>);</span><br><span class="line">    <span class="comment">// 对所有的JavaClasses进行判断</span></span><br><span class="line">archRule.check(classes);</span><br></pre></td></tr></table></figure>
<p>上面展示了自定义新的<code>ArchRule</code>的例子，中已经为我们内置了一些常用的<code>ArchRule</code>实现，它们位于<code>GeneralCodingRules</code>中：</p>
<ul>
<li>NO_CLASSES_SHOULD_ACCESS_STANDARD_STREAMS：不能调用System.out、System.err或者(Exception.)printStackTrace。</li>
<li>NO_CLASSES_SHOULD_THROW_GENERIC_EXCEPTIONS：类不能直接抛出通用异常Throwable、Exception或者RuntimeException。</li>
<li>NO_CLASSES_SHOULD_USE_JAVA_UTIL_LOGGING：不能使用<code>java.util.logging</code>包路径下的日志组件。</li>
</ul>
<p>更多内建的<code>ArchRule</code>或者通用的内置规则使用，可以参考<a href="https://github.com/TNG/ArchUnit-Examples" target="_blank" rel="noopener">官方例子</a>。</p>
<h2 id="基本使用例子">基本使用例子</h2>
<p>基本使用例子，主要从一些常见的编码规范或者项目规范编写规则对项目所有类进行检查。</p>
<h3 id="包依赖关系检查">包依赖关系检查</h3>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-1.png" alt="j-a-r-u-1"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.noClasses()</span><br><span class="line">    .that().resideInAPackage(<span class="string">"..com.source.."</span>)</span><br><span class="line">    .should().dependOnClassesThat().resideInAPackage(<span class="string">"..com.target.."</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-2.png" alt="j-a-r-u-2"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.classes()</span><br><span class="line">    .that().resideInAPackage(<span class="string">"..com.foo.."</span>)</span><br><span class="line">    .should().onlyAccessClassesThat().resideInAnyPackage(<span class="string">"..com.source.."</span>, <span class="string">"..com.foo.."</span>);</span><br></pre></td></tr></table></figure>
<h3 id="类依赖关系检查">类依赖关系检查</h3>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-3.png" alt="j-a-r-u-3"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.classes()</span><br><span class="line">    .that().haveNameMatching(<span class="string">".*Bar"</span>)</span><br><span class="line">    .should().onlyBeAccessed().byClassesThat().haveSimpleName(<span class="string">"Bar"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="类包含于包的关系检查">类包含于包的关系检查</h3>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-4.png" alt="j-a-r-u-4"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.classes()</span><br><span class="line">    .that().haveSimpleNameStartingWith(<span class="string">"Foo"</span>)</span><br><span class="line">    .should().resideInAPackage(<span class="string">"com.foo"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="继承关系检查">继承关系检查</h3>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-5.png" alt="j-a-r-u-5"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.classes()</span><br><span class="line">    .that().implement(Collection<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    .should().haveSimpleNameEndingWith("Connection");</span><br></pre></td></tr></table></figure>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-6.png" alt="j-a-r-u-6"></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.classes()</span><br><span class="line">    .that().areAssignableTo(EntityManager<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    .should().onlyBeAccessed().byAnyPackage("..persistence..");</span><br></pre></td></tr></table></figure>
<h3 id="注解检查">注解检查</h3>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-a-r-u-7.png" alt="j-a-r-u-7"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArchRule archRule = ArchRuleDefinition.classes()</span><br><span class="line">    .that().areAssignableTo(EntityManager<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">should</span>().<span class="title">onlyBeAccessed</span>().<span class="title">byClassesThat</span>().<span class="title">areAnnotatedWith</span>(<span class="title">Transactional</span>.<span class="title">class</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="逻辑层调用关系检查">逻辑层调用关系检查</h3>
<p>例如项目结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- com.myapp.controller</span><br><span class="line">    SomeControllerOne<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    <span class="title">SomeControllerTwo</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">- <span class="title">com</span>.<span class="title">myapp</span>.<span class="title">service</span></span></span><br><span class="line"><span class="class">    <span class="title">SomeServiceOne</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    <span class="title">SomeServiceTwo</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">- <span class="title">com</span>.<span class="title">myapp</span>.<span class="title">persistence</span></span></span><br><span class="line"><span class="class">    <span class="title">SomePersistenceManager</span></span></span><br></pre></td></tr></table></figure>
<p>例如我们规定：</p>
<ul>
<li>包路径<code>com.myapp.controller</code>中的类不能被其他层级包引用。</li>
<li>包路径<code>com.myapp.service</code>中的类只能被<code>com.myapp.controller</code>中的类引用。</li>
<li>包路径<code>com.myapp.persistence</code>中的类只能被<code>com.myapp.service</code>中的类引用。</li>
</ul>
<p>编写规则如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">layeredArchitecture()</span><br><span class="line">    .layer(<span class="string">"Controller"</span>).definedBy(<span class="string">"..controller.."</span>)</span><br><span class="line">    .layer(<span class="string">"Service"</span>).definedBy(<span class="string">"..service.."</span>)</span><br><span class="line">    .layer(<span class="string">"Persistence"</span>).definedBy(<span class="string">"..persistence.."</span>)</span><br><span class="line"></span><br><span class="line">    .whereLayer(<span class="string">"Controller"</span>).mayNotBeAccessedByAnyLayer()</span><br><span class="line">    .whereLayer(<span class="string">"Service"</span>).mayOnlyBeAccessedByLayers(<span class="string">"Controller"</span>)</span><br><span class="line">    .whereLayer(<span class="string">"Persistence"</span>).mayOnlyBeAccessedByLayers(<span class="string">"Service"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="循环依赖关系检查">循环依赖关系检查</h3>
<p>例如项目结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- com.myapp.moduleone</span><br><span class="line">    ClassOneInModuleOne<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    <span class="title">ClassTwoInModuleOne</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">- <span class="title">com</span>.<span class="title">myapp</span>.<span class="title">moduletwo</span></span></span><br><span class="line"><span class="class">    <span class="title">ClassOneInModuleTwo</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    <span class="title">ClassTwoInModuleTwo</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">- <span class="title">com</span>.<span class="title">myapp</span>.<span class="title">modulethree</span></span></span><br><span class="line"><span class="class">    <span class="title">ClassOneInModuleThree</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">    <span class="title">ClassTwoInModuleThree</span>.<span class="title">class</span></span></span><br></pre></td></tr></table></figure>
<p>例如我们规定：<code>com.myapp.moduleone</code>、<code>com.myapp.moduletwo</code>和<code>com.myapp.modulethree</code>三个包路径中的类不能形成一个循环依赖缓，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassOneInModuleOne -&gt; ClassOneInModuleTwo -&gt; ClassOneInModuleThree -&gt; ClassOneInModuleOne</span><br></pre></td></tr></table></figure>
<p>编写规则如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slices().matching(<span class="string">"com.myapp.(*).."</span>).should().beFreeOfCycles()</span><br></pre></td></tr></table></figure>
<h2 id="核心API">核心API</h2>
<p>把API分为三层，最重要的是&quot;Core&quot;层、&quot;Lang&quot;层和&quot;Library&quot;层。</p>
<h3 id="Core层API">Core层API</h3>
<p>ArchUnit的Core层API大部分类似于Java原生反射API，例如<code>JavaMethod</code>和<code>JavaField</code>对应于原生反射中的<code>Method</code>和<code>Field</code>，它们提供了诸如<code>getName()</code>、<code>getMethods()</code>、<code>getType()</code>和<code>getParameters()</code>等方法。</p>
<p>此外ArchUnit扩展一些API用于描述依赖代码之间关系，例如<code>JavaMethodCall</code>， <code>JavaConstructorCall</code>或<code>JavaFieldAccess</code>。还提供了例如Java类与其他Java类之间的导入访问关系的API如<code>JavaClass#getAccessesFromSelf()</code>。</p>
<p>而需要导入类路径下或者Jar包中已经编译好的Java类，ArchUnit提供了<code>ClassFileImporter</code>完成此功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaClasses classes = <span class="keyword">new</span> ClassFileImporter().importPackages(<span class="string">"com.mycompany.myapp"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Lang层API">Lang层API</h3>
<p>Core层的API十分强大，提供了需要关于Java程序静态结构的信息，但是直接使用Core层的API对于单元测试会缺乏表现力，特别表现在架构规则方面。</p>
<p>出于这个原因，ArchUnit提供了Lang层的API，它提供了一种强大的语法来以抽象的方式表达规则。Lang层的API大多数是采用流式编程方式定义方法，例如指定包定义和调用关系的规则如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArchRule rule =</span><br><span class="line">    classes()</span><br><span class="line">         <span class="comment">// 定义在service包下的所欲类</span></span><br><span class="line">        .that().resideInAPackage(<span class="string">"..service.."</span>)</span><br><span class="line">         <span class="comment">// 只能被controller包或者service包中的类访问</span></span><br><span class="line">        .should().onlyBeAccessed().byAnyPackage(<span class="string">"..controller.."</span>, <span class="string">"..service.."</span>);</span><br></pre></td></tr></table></figure>
<p>编写好规则后就可以基于导入所有编译好的类进行扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaClasses classes = <span class="keyword">new</span> ClassFileImporter().importPackage(<span class="string">"com.myapp"</span>);</span><br><span class="line">ArchRule rule = <span class="comment">// 定义的规则</span></span><br><span class="line">rule.check(classes);</span><br></pre></td></tr></table></figure>
<h3 id="Library层API">Library层API</h3>
<p>Library层API通过静态工厂方法提供了更多复杂而强大的预定义规则，入口类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.tngtech.archunit.library.Architectures</span><br></pre></td></tr></table></figure>
<p>目前，这只能为分层架构提供方便的检查，但将来可能会扩展为六边形架构\管道和过滤器，业务逻辑和技术基础架构的分离等样式。</p>
<p>还有其他几个相对强大的功能：</p>
<ul>
<li>代码切片功能，入口是<code>com.tngtech.archunit.library.dependencies.SlicesRuleDefinition</code>。</li>
<li>一般编码规则，入口是<code>com.tngtech.archunit.library.GeneralCodingRules</code>。</li>
<li>PlantUML组件支持，功能位于包路径<code>com.tngtech.archunit.library.plantuml</code>下。</li>
</ul>
<h2 id="编写复杂的规则">编写复杂的规则</h2>
<p>一般来说，内建的规则不一定能够满足一些复杂的规范校验规则，因此需要编写自定义的规则。这里仅仅举一个前文提到的相对复杂的规则：</p>
<ul>
<li>定义在controller包下的Controller类的类名称以&quot;Controller&quot;结尾，方法的入参类型命名以&quot;Request&quot;结尾，返回参数命名以&quot;Response&quot;结尾。</li>
</ul>
<p>官方提供的自定义规则的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DescribedPredicate&lt;JavaClass&gt; haveAFieldAnnotatedWithPayload =</span><br><span class="line">    <span class="keyword">new</span> DescribedPredicate&lt;JavaClass&gt;(<span class="string">"have a field annotated with @Payload"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(JavaClass input)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> someFieldAnnotatedWithPayload = <span class="comment">// iterate fields and check for @Payload</span></span><br><span class="line">            <span class="keyword">return</span> someFieldAnnotatedWithPayload;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">ArchCondition&lt;JavaClass&gt; onlyBeAccessedBySecuredMethods =</span><br><span class="line">    <span class="keyword">new</span> ArchCondition&lt;JavaClass&gt;(<span class="string">"only be accessed by @Secured methods"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(JavaClass item, ConditionEvents events)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (JavaMethodCall call : item.getMethodCallsToSelf()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!call.getOrigin().isAnnotatedWith(Secured<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                    String message = String.format(</span><br><span class="line">                        <span class="string">"Method %s is not @Secured"</span>, call.getOrigin().getFullName());</span><br><span class="line">                    events.add(SimpleConditionEvent.violated(call, message));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">classes().that(haveAFieldAnnotatedWithPayload).should(onlyBeAccessedBySecuredMethods);</span><br></pre></td></tr></table></figure>
<p>我们只需要模仿它的实现即可，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArchunitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controller_class_rule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		JavaClasses classes = <span class="keyword">new</span> ClassFileImporter().importPackages(<span class="string">"club.throwable"</span>);</span><br><span class="line">		DescribedPredicate&lt;JavaClass&gt; predicate =</span><br><span class="line">				<span class="keyword">new</span> DescribedPredicate&lt;JavaClass&gt;(<span class="string">"定义在club.throwable.controller包下的所有类"</span>) &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(JavaClass input)</span> </span>&#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span> != input.getPackageName() &amp;&amp; input.getPackageName().contains(<span class="string">"club.throwable.controller"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">		ArchCondition&lt;JavaClass&gt; condition1 = <span class="keyword">new</span> ArchCondition&lt;JavaClass&gt;(<span class="string">"类名称以Controller结尾"</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(JavaClass javaClass, ConditionEvents conditionEvents)</span> </span>&#123;</span><br><span class="line">				String name = javaClass.getName();</span><br><span class="line">				<span class="keyword">if</span> (!name.endsWith(<span class="string">"Controller"</span>)) &#123;</span><br><span class="line">					conditionEvents.add(SimpleConditionEvent.violated(javaClass, String.format(<span class="string">"当前控制器类[%s]命名不以\"Controller\"结尾"</span>, name)));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		ArchCondition&lt;JavaClass&gt; condition2 = <span class="keyword">new</span> ArchCondition&lt;JavaClass&gt;(<span class="string">"方法的入参类型命名以\"Request\"结尾，返回参数命名以\"Response\"结尾"</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(JavaClass javaClass, ConditionEvents conditionEvents)</span> </span>&#123;</span><br><span class="line">				Set&lt;JavaMethod&gt; javaMethods = javaClass.getMethods();</span><br><span class="line">				String className = javaClass.getName();</span><br><span class="line">				<span class="comment">// 其实这里要做严谨一点需要考虑是否使用了泛型参数，这里暂时简化了</span></span><br><span class="line">				<span class="keyword">for</span> (JavaMethod javaMethod : javaMethods) &#123;</span><br><span class="line">					Method method = javaMethod.reflect();</span><br><span class="line">					Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">					<span class="keyword">for</span> (Class parameterType : parameterTypes) &#123;</span><br><span class="line">						<span class="keyword">if</span> (!parameterType.getName().endsWith(<span class="string">"Request"</span>)) &#123;</span><br><span class="line">							conditionEvents.add(SimpleConditionEvent.violated(method,</span><br><span class="line">									String.format(<span class="string">"当前控制器类[%s]的[%s]方法入参不以\"Request\"结尾"</span>, className, method.getName())));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">					<span class="keyword">if</span> (!returnType.getName().endsWith(<span class="string">"Response"</span>)) &#123;</span><br><span class="line">						conditionEvents.add(SimpleConditionEvent.violated(method,</span><br><span class="line">								String.format(<span class="string">"当前控制器类[%s]的[%s]方法返回参数不以\"Response\"结尾"</span>, className, method.getName())));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		ArchRuleDefinition.classes()</span><br><span class="line">				.that(predicate)</span><br><span class="line">				.should(condition1)</span><br><span class="line">				.andShould(condition2)</span><br><span class="line">				.because(<span class="string">"定义在controller包下的Controller类的类名称以\"Controller\"结尾，方法的入参类型命名以\"Request\"结尾，返回参数命名以\"Response\"结尾"</span>)</span><br><span class="line">				.check(classes);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为导入了所有需要的编译好的类的静态属性，基本上是可以编写所有能够想出来的规约，更多的内容或者实现可以自行摸索。</p>
<h2 id="小结">小结</h2>
<p>通过最近的一个项目引入了Archunit，并且进行了一些编码规范和架构规范的规约，起到了十分明显的效果。之前口头或者书面文档的规范可以通过单元测试直接控制，项目构建的时候强制必须执行单元测试，只有所有单测通过才能构建和打包(禁止使用<code>-Dmaven.test.skip=true</code>参数)，起到了十分明显的成效。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.archunit.org/userguide/html/000_Index.html" target="_blank" rel="noopener">User Guide</a></li>
</ul>
<p>(e-a-2019216 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Framework/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Framework</a>
        
          <a href="/blog/tags/Archunit/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Archunit</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/16/java-reference/">
      深入理解JDK中的Reference原理和源码实现
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：9.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：41分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-02-16T14:51:54+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年2月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入理解JDK中的Reference原理和源码实现</h1>
<h2 id="前提">前提</h2>
<p>这篇文章主要基于JDK11的源码和最近翻看的《深入理解Java虚拟机-2nd》一书的部分内容，对JDK11中的Reference(引用)做一些总结。值得注意的是，通过笔者对比一下JDK11和JDK8对于<code>java.lang.ref</code>包的相关实现，发现代码变化比较大，<strong>因此本文的源码分析可能并不适合于JDK11之外的JDK版本</strong>。</p>
<h2 id="Reference的简介和分类">Reference的简介和分类</h2>
<p>在JDK1.2之前，Java中的引用的定义是十分传统的：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。在这种定义之下，一个对象只有被引用和没有被引用两种状态。</p>
<p>实际上，我们更希望存在这样的一类对象：当内存空间还足够的时候，这些对象能够保留在内存空间中；如果当内存空间在进行了垃圾收集之后还是非常紧张，则可以抛弃这些对象。基于这种特性，可以满足很多系统的缓存功能的使用场景。</p>
<p><code>java.lang.ref</code>包是JDK1.2引入的，包结构和类分布如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- java.lang.ref</span><br><span class="line">  - Cleaner<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">Finalizer</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">FinalizerHistogram</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">FinalReference</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">PhantomReference</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">Reference</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">ReferenceQueue</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">SoftReference</span>.<span class="title">classs</span></span></span><br><span class="line"><span class="class">  - <span class="title">WeakReference</span>.<span class="title">class</span></span></span><br></pre></td></tr></table></figure>
<p>引入此包的作用是对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种类型的引用，还有一种比较特殊的引用是析构引用(Final Reference)，它是一种特化的虚引用。四种引用的强度按照下面的次序依次减弱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrongReference &gt; SoftReference &gt; WeakReference &gt; PhantomReference</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<ul>
<li>强引用没有对应的类型表示，也就是说强引用是普遍存在的，如<code>Object object = new Object();</code>。</li>
<li>软引用、弱引用和虚引用都是<code>java.lang.ref.Reference</code>的直接子类。</li>
<li>直到JDK11为止，只存在四种引用，这些引用是由JVM创建，因此直接继承<code>java.lang.ref.Reference</code>创建自定义的引用类型是无效的，但是可以直接继承已经存在的引用类型，如<code>java.lang.ref.Cleaner</code>就是继承自<code>java.lang.ref.PhantomReference</code>。</li>
<li>特殊的<code>java.lang.ref.Reference</code>的子类<code>java.lang.ref.FinalReference</code>和<code>Object#finalize()</code>有关，<code>java.lang.ref.Finalizer</code>是<code>java.lang.ref.FinalReference</code>子类，下文会详细分析这些内容。</li>
</ul>
<h2 id="Reference">Reference</h2>
<p><code>Reference</code>就是引用，对JVM的垃圾收集活动敏感(当然，强引用可能对垃圾收集活动是不敏感的)，<code>Reference</code>的继承关系或者实现是由JDK定制，引用实例是由JVM创建，所以自行继承<code>Reference</code>实现自定义的引用类型是无意义的，但是可以继承已经存在的引用类型，如<code>SoftReference</code>等。<code>Reference</code>类文件的注释也比较简短，但是方法和变量的注释十分详细，特别是用图表表明了状态跃迁的过程，这里先看类文件头注释：</p>
<blockquote>
<p>Abstract base class for reference objects.  This class defines the operations common to all reference objects.  Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.</p>
</blockquote>
<p>翻译一下大意是：<code>Reference</code>是所有引用对象的基类。这个类定义了所有引用对象的通用操作。因为引用对象是与垃圾收集器紧密协作而实现的，所以这个类可能不能直接子类化。</p>
<h3 id="Reference的状态集合">Reference的状态集合</h3>
<p><code>Reference</code>源码中并不存在一个成员变量用于描述<code>Reference</code>的状态，它是通过组合判断referent、discovered、queue、next成员的存在性或者顺序&quot;拼凑出&quot;对应的状态，注释中描述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">一个引用对象可以同时存在两种状态：</span><br><span class="line">- 第一组状态：<span class="string">"active"</span>, <span class="string">"pending"</span>, or <span class="string">"inactive"</span></span><br><span class="line">- 第二组状态：<span class="string">"registered"</span>, <span class="string">"enqueued"</span>, <span class="string">"dequeued"</span>, or <span class="string">"unregistered"</span></span><br><span class="line"></span><br><span class="line">Active：</span><br><span class="line"></span><br><span class="line">当前引用实例处于Active状态，会收到垃圾收集器的特殊处理。在垃圾收集器检测到referent的可达性已更改为适当状态之后的某个时间，垃圾收集器会<span class="string">"通知"</span>当前引用实例改变其状态为<span class="string">"pending"</span>或者<span class="string">"inactive"</span>。此时的判断条件是：referent != <span class="keyword">null</span>; discovered = <span class="keyword">null</span>或者实例位于GC的discovered列表中。</span><br><span class="line"></span><br><span class="line">Pending：</span><br><span class="line"></span><br><span class="line">当前的引用实例是pending-Reference列表的一个元素，等待被ReferenceHandler线程处理。pending-Reference列表通过应用实例的discovered字段进行关联。此时的判断条件是：referent = <span class="keyword">null</span>; discovered = pending-Reference列表中的下一个元素</span><br><span class="line"></span><br><span class="line">Inactive：</span><br><span class="line"></span><br><span class="line">当前的引用实例处于非Active和非Pending状态。此时的判断条件是：referent = <span class="keyword">null</span> (同时discovered = <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">Registered：</span><br><span class="line"></span><br><span class="line">当前的引用实例创建的时候关联到一个引用队列实例，但是引用实例暂未加入到队列中。此时的判断条件是：queue = 传入的ReferenceQueue实例</span><br><span class="line"></span><br><span class="line">Enqueued：</span><br><span class="line"></span><br><span class="line">当前的引用实例已经添加到和它关联的引用队列中但是尚未移除(remove)，也就是调用了ReferenceQueue.enqueued()后的Reference实例就会处于这个状态。此时的判断条件是：queue = ReferenceQueue.ENQUEUE; next = 引用列表中的下一个引用实例，或者如果当前引用实例是引用列表中的最后一个元素，则它会进入Inactive状态</span><br><span class="line"></span><br><span class="line">Dequeued：</span><br><span class="line"></span><br><span class="line">当前的引用实例曾经添加到和它关联的引用队列中并且已经移除(remove)。此时的判断条件是：queue = ReferenceQueue.NULL; next = 当前的引用实例</span><br><span class="line"></span><br><span class="line">Unregistered：</span><br><span class="line"></span><br><span class="line">当前的引用实例不存在关联的引用队列，也就是创建引用实例的时候传入的queue为<span class="keyword">null</span>。此时的判断条件是：queue = ReferenceQueue.NULL</span><br></pre></td></tr></table></figure>
<p>状态跃迁的时序图如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">* Initial states:</span><br><span class="line">*   [active/registered]</span><br><span class="line">*   [active/unregistered] [<span class="number">1</span>]</span><br><span class="line">*</span><br><span class="line">* Transitions:</span><br><span class="line">*                            clear</span><br><span class="line">*   [active/registered]     -------&gt;   [inactive/registered]</span><br><span class="line">*          |                                 |</span><br><span class="line">*          |                                 | enqueue [<span class="number">2</span>]</span><br><span class="line">*          | GC              enqueue [<span class="number">2</span>]     |</span><br><span class="line">*          |                -----------------|</span><br><span class="line">*          |                                 |</span><br><span class="line">*          v                                 |</span><br><span class="line">*   [pending/registered]    ---              v</span><br><span class="line">*          |                   | ReferenceHandler</span><br><span class="line">*          | enqueue [<span class="number">2</span>]       |---&gt;   [inactive/enqueued]</span><br><span class="line">*          v                   |             |</span><br><span class="line">*   [pending/enqueued]      ---              |</span><br><span class="line">*          |                                 | poll/remove</span><br><span class="line">*          | poll/remove                     |</span><br><span class="line">*          |                                 |</span><br><span class="line">*          v            ReferenceHandler     v</span><br><span class="line">*   [pending/dequeued]      ------&gt;    [inactive/dequeued]</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*                           clear/enqueue/GC [<span class="number">3</span>]</span><br><span class="line">*   [active/unregistered]   ------</span><br><span class="line">*          |                      |</span><br><span class="line">*          | GC                   |</span><br><span class="line">*          |                      |--&gt; [inactive/unregistered]</span><br><span class="line">*          v                      |</span><br><span class="line">*   [pending/unregistered]  ------</span><br><span class="line">*                           ReferenceHandler</span><br><span class="line">*</span><br><span class="line">* Terminal states:</span><br><span class="line">*   [inactive/dequeued]</span><br><span class="line">*   [inactive/unregistered]</span><br><span class="line">*</span><br><span class="line">* <span class="function">Unreachable <span class="title">states</span> <span class="params">(because enqueue also clears)</span>:</span></span><br><span class="line"><span class="function">*   [active/enqeued]</span></span><br><span class="line"><span class="function">*   [active/dequeued]</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* [1] Unregistered is not permitted <span class="keyword">for</span> FinalReferences.</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* [2] These transitions are not possible <span class="keyword">for</span> FinalReferences, making</span></span><br><span class="line"><span class="function">* [pending/enqueued] and [pending/dequeued] unreachable, and</span></span><br><span class="line"><span class="function">* [inactive/registered] terminal.</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* [3] The garbage collector may directly transition a Reference</span></span><br><span class="line"><span class="function">* from [active/unregistered] to [inactive/unregistered],</span></span><br><span class="line"><span class="function">* bypassing the pending-Reference list.</span></span><br></pre></td></tr></table></figure>
<p>注释中还强调了几点：</p>
<ul>
<li>初始化状态：<code>[active/registered]</code>和<code>[active/unregistered](这种情况只限于FinalReferences)</code>。</li>
<li>终结状态：<code>[inactive/dequeued]</code>和<code>[inactive/unregistered]</code>。</li>
<li>不可能出现的状态：<code>[active/enqeued]</code>和<code>[active/dequeued]</code>。</li>
</ul>
<p>上面的图看起来可能比较抽象，<code>ReferenceHandler</code>其实是<code>Reference</code>中静态代码块中初始化的线程实例，主要作用是：处理pending状态的引用实例，使它们入队列并走向<code>[inactive/dequeued]</code>状态。另外，上面的线框图是分两部分，其中上半部分是使用了<code>ReferenceQueue</code>，后半部分是没有使用<code>ReferenceQueue</code>(或者说使用了<code>ReferenceQueue.NULL</code>)。这里尝试用PPT画一下简化的状态跃迁图：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-d-k-r-1.png" alt="j-d-k-r-1"></p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-d-k-r-2.png" alt="j-d-k-r-2"></p>
<h3 id="Reference源码分析">Reference源码分析</h3>
<p>先看<code>Reference</code>的构造函数和成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> T referent;</span><br><span class="line">   <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line">   <span class="keyword">volatile</span> Reference next;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Reference&lt;T&gt; discovered;</span><br><span class="line"></span><br><span class="line">   Reference(T referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造描述</strong>：</p>
<p>构造函数依赖于一个泛型的referent成员以及一个<code>ReferenceQueue&lt;? super T&gt;</code>的队列，如果<code>ReferenceQueue</code>实例为null，则使用<code>ReferenceQueue.NULL</code>。</p>
<p><strong>成员变量描述</strong>：</p>
<ul>
<li>referent：<code>Reference</code>保存的引用指向的对象，下面直接称为referent。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC特殊处理的对象</span></span><br><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>queue：<code>Reference</code>对象关联的队列，也就是引用队列，对象如果即将被垃圾收集器回收，此队列作为通知的回调队列，也就是当<code>Reference</code>实例持有的对象referent要被回收的时候，<code>Reference</code>实例会被放入引用队列，那么程序执行的时候可以从引用队列得到或者监控相应的<code>Reference</code>实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The queue this reference gets enqueued to by GC notification or by</span></span><br><span class="line"><span class="comment"> * calling enqueue().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When registered: the queue with which this reference is registered.</span></span><br><span class="line"><span class="comment"> *        enqueued: ReferenceQueue.ENQUEUE</span></span><br><span class="line"><span class="comment"> *        dequeued: ReferenceQueue.NULL</span></span><br><span class="line"><span class="comment"> *    unregistered: ReferenceQueue.NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br></pre></td></tr></table></figure>
<ul>
<li>next：下一个<code>Reference</code>实例的引用，<code>Reference</code>实例通过此构造单向的链表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The link in a ReferenceQueue's list of Reference objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When registered: null</span></span><br><span class="line"><span class="comment"> *        enqueued: next element in queue (or this if last)</span></span><br><span class="line"><span class="comment"> *        dequeued: this (marking FinalReferences as inactive)</span></span><br><span class="line"><span class="comment"> *    unregistered: null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">volatile</span> Reference next;</span><br></pre></td></tr></table></figure>
<ul>
<li>discovered：注意这个属性由transient修饰，基于状态表示不同链表中的下一个待处理的对象，主要是pending-reference列表的下一个元素，通过JVM直接调用赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When active:  next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">*     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">*     otherwise:   NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br></pre></td></tr></table></figure>
<p><strong>实例方法(和ReferenceHandler线程不相关的方法)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取持有的referent实例</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.referent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把持有的referent实例置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否处于enqeued状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnqueued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队参数，同时会把referent置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖clone方法并且抛出异常，也就是禁止clone</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保给定的引用实例是强可达的</span></span><br><span class="line"><span class="meta">@ForceInline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reachabilityFence</span><span class="params">(Object ref)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReferenceHandler线程">ReferenceHandler线程</h3>
<p>ReferenceHandler线程是由<code>Reference</code>静态代码块中建立并且运行的线程，它的运行方法中依赖了比较多的本地(native)方法，ReferenceHandler线程的主要功能是处理pending链表中的引用对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferenceHandler直接继承于Thread覆盖了run方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态工具方法用于确保对应的类型已经初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 确保Cleaner这个类已经初始化</span></span><br><span class="line">        <span class="comment">// pre-load and initialize Cleaner class so that we don't</span></span><br><span class="line">        <span class="comment">// get into trouble later in the run loop if there's</span></span><br><span class="line">        <span class="comment">// memory shortage while loading/initializing it lazily.</span></span><br><span class="line">        ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(g, <span class="keyword">null</span>, name, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意run方法是一个死循环执行processPendingReferences</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            processPendingReferences();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原子获取(后)并且清理VM中的pending引用链表</span></span><br><span class="line"><span class="comment"> * Atomically get and clear (set to null) the VM's pending-Reference list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Reference&lt;Object&gt; <span class="title">getAndClearReferencePendingList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检验VM中的pending引用对象链表是否有剩余元素</span></span><br><span class="line"><span class="comment"> * Test whether the VM's pending-Reference list contains any entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">hasReferencePendingList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待直到pending引用对象链表不为null，此方法阻塞的具体实现又VM实现</span></span><br><span class="line"><span class="comment"> * Wait until the VM's pending-Reference list may be non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">waitForReferencePendingList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁对象，用于控制等待pending对象时候的加锁和开始处理这些对象时候的解锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object processPendingLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 正在处理pending对象的时候，这个变量会更新为true，处理完毕或者初始化状态为false，用于避免重复处理或者重复等待</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> processPendingActive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是死循环中的核心方法，功能是处理pending链表中的引用元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Only the singleton reference processing thread calls</span></span><br><span class="line">    <span class="comment">// waitForReferencePendingList() and getAndClearReferencePendingList().</span></span><br><span class="line">    <span class="comment">// These are separate operations to avoid a race with other threads</span></span><br><span class="line">    <span class="comment">// that are calling waitForReferenceProcessing().</span></span><br><span class="line">    <span class="comment">// （1）等待</span></span><br><span class="line">    waitForReferencePendingList();</span><br><span class="line">    Reference&lt;Object&gt; pendingList;</span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        <span class="comment">// （2）获取并清理，标记处理中状态</span></span><br><span class="line">        pendingList = getAndClearReferencePendingList();</span><br><span class="line">        processPendingActive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// （3）通过discovered(下一个元素)遍历pending链表进行处理</span></span><br><span class="line">    <span class="keyword">while</span> (pendingList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Reference&lt;Object&gt; ref = pendingList;</span><br><span class="line">        pendingList = ref.discovered;</span><br><span class="line">        ref.discovered = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果是Cleaner类型执行执行clean方法并且对锁对象processPendingLock进行唤醒所有阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">            ((Cleaner)ref).clean();</span><br><span class="line">            <span class="comment">// Notify any waiters that progress has been made.</span></span><br><span class="line">            <span class="comment">// This improves latency for nio.Bits waiters, which</span></span><br><span class="line">            <span class="comment">// are the only important ones.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">                processPendingLock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非Cleaner类型并且引用队列不为ReferenceQueue.NULL则进行入队操作</span></span><br><span class="line">            ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = ref.queue;</span><br><span class="line">            <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// （4）当次循环结束之前再次唤醒锁对象processPendingLock上阻塞的所有线程</span></span><br><span class="line">    <span class="comment">// Notify any waiters of completion of current round.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        processPendingActive = <span class="keyword">false</span>;</span><br><span class="line">        processPendingLock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReferenceHandler线程启动的静态代码块如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadGroup继承当前执行线程(一般是主线程)的线程组</span></span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="comment">// 创建线程实例，命名为Reference Handler，配置最高优先级和后台运行(守护线程)，然后启动</span></span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">    <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">     * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">    <span class="comment">// 注意这里覆盖了全局的jdk.internal.misc.JavaLangRefAccess实现</span></span><br><span class="line">    <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">    SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForReferenceProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Reference.waitForReferenceProcessing();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Finalizer.runFinalization();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果正在处理pending链表中的引用对象或者监测到VM中的pending链表中还有剩余元素则基于锁对象processPendingLock进行等待</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">waitForReferenceProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processPendingActive || hasReferencePendingList()) &#123;</span><br><span class="line">            <span class="comment">// Wait for progress, not necessarily completion.</span></span><br><span class="line">            processPendingLock.wait();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于ReferenceHandler线程是<code>Reference</code>的静态代码创建的，所以只要<code>Reference</code>这个父类被初始化，该线程就会创建和运行，由于它是守护线程，除非JVM进程终结，否则它会一直在后台运行(注意它的<code>run()</code>方法里面使用了死循环)。</p>
<h2 id="ReferenceQueue">ReferenceQueue</h2>
<p>JDK中对<code>ReferenceQueue</code>的文档描述是比较少的，类文件只有一句简单的注释：</p>
<blockquote>
<p>Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.</p>
</blockquote>
<p>翻译一下大意为：引用队列，垃圾收集器在检测到适当的可达性更改后将已注册的引用对象追加到该队列。</p>
<p>从源码上看，实际上<code>ReferenceQueue</code>只是名义上的引用队列，它只保存了<code>Reference</code>链表的头(<strong>head</strong>)节点，并且提供了出队、入队和移除等操作，而<code>Reference</code>实际上本身提供单向链表的功能，<strong>也就是<code>Reference</code>通过成员属性next构建单向链表，而链表的操作是委托给<code>ReferenceQueue</code>完成，这里的逻辑有点绕</strong>。<code>ReferenceQueue</code>的源码比较少，这里全量贴出标注一下注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceQueue</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类Null类继承自ReferenceQueue，覆盖了enqueue方法返回false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Null</span> <span class="keyword">extends</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;?&gt; r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ReferenceQueue.NULL和ReferenceQueue.ENQUEUED都是内部类Null的新实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; NULL = <span class="keyword">new</span> Null();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class="keyword">new</span> Null();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类，作为锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="comment">// 锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="comment">// 引用链表的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? extends T&gt; head;</span><br><span class="line">    <span class="comment">// 引用队列长度，入队则增加1，出队则减少1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueLength = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作，只会被Reference实例调用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// Check that since getting the lock this reference hasn't already been</span></span><br><span class="line">            <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">            <span class="comment">// 如果引用实例持有的队列为ReferenceQueue.NULL或者ReferenceQueue.ENQUEUED则入队失败返回false</span></span><br><span class="line">            ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">            <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Self-loop end, so if a FinalReference it remains inactive.</span></span><br><span class="line">            <span class="comment">// 如果链表没有元素，则此引用实例直接作为头节点，否则把前一个引用实例作为下一个节点</span></span><br><span class="line">            r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">            <span class="comment">// 当前实例更新为头节点，也就是每一个新入队的引用实例都是作为头节点，已有的引用实例会作为后继节点</span></span><br><span class="line">            head = r;</span><br><span class="line">            <span class="comment">// 队列长度增加1</span></span><br><span class="line">            queueLength++;</span><br><span class="line">            <span class="comment">// Update r.queue *after* adding to list, to avoid race</span></span><br><span class="line">            <span class="comment">// with concurrent enqueued checks and fast-path poll().</span></span><br><span class="line">            <span class="comment">// Volatiles ensure ordering.</span></span><br><span class="line">            <span class="comment">// 当前引用实例已经入队，那么它本身持有的引用队列实例置为ReferenceQueue.ENQUEUED</span></span><br><span class="line">            r.queue = ENQUEUED;</span><br><span class="line">            <span class="comment">// 特殊处理FinalReference，VM进行计数</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用队列的poll操作，此方法必须在加锁情况下调用</span></span><br><span class="line">    <span class="keyword">private</span> Reference&lt;? extends T&gt; reallyPoll() &#123;       <span class="comment">/* Must hold lock */</span></span><br><span class="line">        Reference&lt;? extends T&gt; r = head;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.queue = NULL;</span><br><span class="line">            <span class="comment">// Update r.queue *before* removing from list, to avoid</span></span><br><span class="line">            <span class="comment">// race with concurrent enqueued checks and fast-path</span></span><br><span class="line">            <span class="comment">// poll().  Volatiles ensure ordering.</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Reference&lt;? extends T&gt; rn = r.next;</span><br><span class="line">            <span class="comment">// Handle self-looped next as end of list designator.</span></span><br><span class="line">            <span class="comment">// 更新next节点为头节点，如果next节点为自身，说明已经走过一次出队，则返回null</span></span><br><span class="line">            head = (rn == r) ? <span class="keyword">null</span> : rn;</span><br><span class="line">            <span class="comment">// Self-loop next rather than setting to null, so if a</span></span><br><span class="line">            <span class="comment">// FinalReference it remains inactive.</span></span><br><span class="line">            <span class="comment">// 当前头节点变更为环状队列，考虑到FinalReference尚为inactive和避免重复出队的问题</span></span><br><span class="line">            r.next = r;</span><br><span class="line">            <span class="comment">// 队列长度减少1</span></span><br><span class="line">            queueLength--;</span><br><span class="line">            <span class="comment">// 特殊处理FinalReference，VM进行计数</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                VM.addFinalRefCount(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的公有poll操作，主要是加锁后调用reallyPoll</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> reallyPoll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除引用队列中的下一个引用元素，实际上也是依赖于reallyPoll的Object提供的阻塞机制</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; remove(<span class="keyword">long</span> timeout)</span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">long</span> start = (timeout == <span class="number">0</span>) ? <span class="number">0</span> : System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                lock.wait(timeout);</span><br><span class="line">                r = reallyPoll();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="keyword">if</span> (timeout != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">                    timeout -= (end - start) / <span class="number">1000_000</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    start = end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// remove，超时时间为0，实际上就是lock.wait(0)就是永久阻塞直至唤醒</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; remove() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// foreach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Reference&lt;? extends T&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Reference&lt;? extends T&gt; r = head; r != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            action.accept(r);</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Reference&lt;? extends T&gt; rn = r.next;</span><br><span class="line">            <span class="keyword">if</span> (rn == r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.queue == ENQUEUED) &#123;</span><br><span class="line">                    <span class="comment">// still enqueued -&gt; we reached end of chain</span></span><br><span class="line">                    r = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// already dequeued: r.queue == NULL; -&gt;</span></span><br><span class="line">                    <span class="comment">// restart from head when overtaken by queue poller(s)</span></span><br><span class="line">                    r = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// next in chain</span></span><br><span class="line">                r = rn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReferenceQueue</code>的源码十分简单，还是重新提一下，它只存储了<code>Reference</code>链表的头节点，真正的<code>Reference</code>链表的所有节点是存储在<code>Reference</code>实例本身，通过属性next拼接的，<code>ReferenceQueue</code>提供了对<code>Reference</code>链表的入队、poll、remove等操作。</p>
<h2 id="判断对象的可达性和对象是否存活">判断对象的可达性和对象是否存活</h2>
<p>判断对象的可达性和对象是否存活是两个比较困难的问题，笔者C语言学得比较烂，否则会重点翻看一下JVM的实现，目前只能参考一些资料来说明这个问题。</p>
<h3 id="可达性算法">可达性算法</h3>
<p>主流商用语言包括Java都是使用可达性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路是通过一系列的称为&quot;GC Roots&quot;(GC根集)的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC根集没有任何引用链相连(从图论的角度看，也就是从GC根集到这个对象是不可达的)时，则证明此对象是不可用的。不可用的对象&quot;<strong>有机会</strong>&quot;被判定为可以回收的对象。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-d-k-r-3.png" alt="j-d-k-r-3"></p>
<p>在Java语言中，可以作为GC根集的对象包括下面几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li>
<li>方法区中常量引用的对象(在JDK1.8之后不存在方法区，也就是有可能是metaspace中常量引用的对象)。</li>
<li>本地方法栈中JNI(即一般常说的Native方法)引用的对象。</li>
</ul>
<h3 id="finalize函数">finalize函数</h3>
<p>即使在可达性分析算法中判定为不可达的对象，也并非一定会判定为可以被回收的&quot;死亡&quot;对象。一个对象判定为&quot;死亡&quot;至少需要经历<strong>两次标记</strong>的过程。</p>
<p><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。JVM会把以下两种情况认为对象没有必要执行<code>finalize()</code>方法：</p>
<ul>
<li>对象没有覆盖继承自Object类的<code>finalize()</code>方法。</li>
<li>对象的<code>finalize()</code>方法已经被JVM调用过。</li>
</ul>
<p>如果一个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个叫<code>F-Queue</code>的队列之中，并且稍后由一个优先级低的Finalizer线程去取该队列的元素，&quot;尝试执行&quot;元素的<code>finalize()</code>方法。这里之所以叫尝试执行是因为JVM会保证触发满足条件的对象的<code>finalize()</code>方法，但是并不承诺会等待它执行结束，这是因为：如果一个对象在执行<code>finalize()</code>方法耗时较长，甚至发生了死循环，将会导致<code>F-Queue</code>的队列中的其他元素永远处于等待状态，<strong>极端情况下有可能导致整个内存回收系统崩溃</strong>。</p>
<p><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，因为稍后的GC将会对<code>F-Queue</code>队列中的对象进行<strong>第二次小规模的标记</strong>，如果对象在<code>finalize()</code>方法执行过程中成功拯救自己–也就是对象自身重新与引用链的任何一个对象建立关联即可，最常见的就是把自身(this关键字)赋值给某个类变量或者对象的成员属性，那么在第二次小规模的标记时候将会把&quot;自我拯救&quot;成功的对象移出&quot;即将回收&quot;的集合。如果对象在<code>finalize()</code>方法执行过程中没有&quot;逃逸&quot;，那么它最终就会被回收。参考《深入理解Java虚拟机-2nd》的&quot;对象自我拯救的例子&quot;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> FinalizeEscapeGc SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Yes,I am still alive :)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGc();</span><br><span class="line"></span><br><span class="line">		SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"No,I am not alive :("</span>);</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 下面的这段代码和上面的一致</span></span><br><span class="line">		SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"No,I am not alive :("</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.finalize();</span><br><span class="line">		System.out.println(<span class="string">"FinalizeEscapeGc finalize invoke..."</span>);</span><br><span class="line">		FinalizeEscapeGc.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">FinalizeEscapeGc finalize invoke...</span><br><span class="line">Yes,I am still alive :)</span><br><span class="line">No,I am not alive :(</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>finalize()</code>方法的错误使用有可能是内存回收系统崩溃的根源，一般情况下谨慎思考是否真的需要覆盖此方法。</li>
<li>任意一个对象只能通过<code>finalize()</code>方法自我拯救一次。</li>
</ul>
<h3 id="Finalizer守护线程">Finalizer守护线程</h3>
<p>前面提到的<code>Finalizer</code>守护线程和<code>F-Queue</code>队列其实在JDK中有具体的实现类<code>java.lang.ref.Finalizer</code>。<code>F-Queue</code>队列只是《深入理解Java虚拟机-2nd》中的一个名词描述，实际上笔者没有找到相关的资料，这里我们通过分析JDK和JVM相关的源码去理解这个<code>F-Queue</code>队列吧。先看<code>java.lang.ref.Finalizer</code>的源码，代码比较少全量贴出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalizer</span> <span class="keyword">extends</span> <span class="title">FinalReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123; <span class="comment">/* Package-private; must be in</span></span><br><span class="line"><span class="comment">                                                          same package as the Reference</span></span><br><span class="line"><span class="comment">                                                          class */</span></span><br><span class="line">    <span class="comment">// Finalizer关联的ReferenceQueue，其实Finalizer是一个特殊的Reference实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Head of doubly linked list of Finalizers awaiting finalization. */</span></span><br><span class="line">    <span class="comment">// 等待finalization的所有Finalizer实例链表的头节点，这里称此链表为unfinalized链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Finalizer unfinalized = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock guarding access to unfinalized list. */</span></span><br><span class="line">    <span class="comment">// unfinalized链表的锁，静态final，全局的锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中间变量，分别记录unfinalized链表中当前执行元素的下一个节点和前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Finalizer next, prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Finalizer</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(finalizee, queue);</span><br><span class="line">        <span class="comment">// push onto unfinalized</span></span><br><span class="line">        <span class="comment">// 这里主要是更新unfinalized链表的头节点，新增的元素总是会变成头节点</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unfinalized != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.next = unfinalized;</span><br><span class="line">                unfinalized.prev = <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unfinalized = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ReferenceQueue&lt;Object&gt; <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoked by VM */</span> 这个方法由JVM激活，也就是链表的元素入队是由JVM控制的，见下文分析</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Finalizer(finalizee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 当前元素已经处理过，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.next == <span class="keyword">this</span>)      <span class="comment">// already finalized</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// unlink from unfinalized</span></span><br><span class="line">            <span class="comment">// 下面的逻辑是当前需要执行的元素从链表中移除，并且更新prev和next的值，相当于重建链表的部分节点</span></span><br><span class="line">            <span class="keyword">if</span> (unfinalized == <span class="keyword">this</span>)</span><br><span class="line">                unfinalized = <span class="keyword">this</span>.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>.prev.next = <span class="keyword">this</span>.next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.next != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.next.prev = <span class="keyword">this</span>.prev;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">this</span>;           <span class="comment">// mark as finalized</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取对象执行一次finalize方法</span></span><br><span class="line">            Object finalizee = <span class="keyword">this</span>.get();</span><br><span class="line">            <span class="keyword">if</span> (finalizee != <span class="keyword">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">                jla.invokeFinalize(finalizee);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clear stack slot containing this variable, to decrease</span></span><br><span class="line">                <span class="comment">// the chances of false retention with a conservative GC</span></span><br><span class="line">                <span class="comment">// 清空变量引用从而减少保守GC导致变量保留的可能性</span></span><br><span class="line">                finalizee = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">        <span class="comment">// 执行完毕会做一次情况防止重复执行</span></span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a privileged secondary finalizer thread in the system thread</span></span><br><span class="line"><span class="comment">     * group for the given Runnable, and wait for it to complete.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is used by runFinalization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It could have been implemented by offloading the work to the</span></span><br><span class="line"><span class="comment">     * regular finalizer thread and waiting for that thread to finish.</span></span><br><span class="line"><span class="comment">     * The advantage of creating a fresh thread, however, is that it insulates</span></span><br><span class="line"><span class="comment">     * invokers of that method from a stalled or deadlocked finalizer thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 这里其实不用畏惧注释太多，它只是一个候选方法，新建一个线程直接调用包裹在Runnable的runFinalization方法，主要是提供给主动调用的上层方法调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkSecondaryFinalizer</span><span class="params">(<span class="keyword">final</span> Runnable proc)</span> </span>&#123;</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">                    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">                         tgn != <span class="keyword">null</span>;</span><br><span class="line">                         tg = tgn, tgn = tg.getParent());</span><br><span class="line">                    Thread sft = <span class="keyword">new</span> Thread(tg, proc, <span class="string">"Secondary finalizer"</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                    sft.start();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sft.join();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Called by Runtime.runFinalization() */</span></span><br><span class="line">    <span class="comment">// 这个方法是给Runtime.runFinalization()委托调用的，其实就是主动取出queue的元素强制调用其finalize方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (VM.initLevel() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        forkSecondaryFinalizer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// in case of recursive call to run()</span></span><br><span class="line">                <span class="keyword">if</span> (running)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class="line">                running = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (Finalizer f; (f = (Finalizer)queue.poll()) != <span class="keyword">null</span>;)</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正的Finalizer线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running;</span><br><span class="line">        FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g, <span class="keyword">null</span>, <span class="string">"Finalizer"</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// in case of recursive call to run()</span></span><br><span class="line">            <span class="keyword">if</span> (running)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finalizer thread starts before System.initializeSystemClass</span></span><br><span class="line">            <span class="comment">// is called.  Wait until JavaLangAccess is available</span></span><br><span class="line">            <span class="keyword">while</span> (VM.initLevel() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// delay until VM completes initialization</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    VM.awaitInitLevel(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">// ignore and continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class="line">            running = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 注意这里是死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 注意这里是调用`Reference#remove()`的永久阻塞版本，只有`Reference#enqueue()`被调用才会解除阻塞</span></span><br><span class="line">                    <span class="comment">// `Reference#remove()`解除阻塞说明元素已经完成入队，由ReferenceHandler线程完成</span></span><br><span class="line">                    Finalizer f = (Finalizer)queue.remove();</span><br><span class="line">                    <span class="comment">// 实际上就是调用对象的finalize方法</span></span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">// ignore and continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">             tgn != <span class="keyword">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        <span class="comment">// 静态代码块中声明线程，优先级是最高优先级-2，守护线程，实际上这里优先级不一定会生效</span></span><br><span class="line">        Thread finalizer = <span class="keyword">new</span> FinalizerThread(tg);</span><br><span class="line">        finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span><br><span class="line">        finalizer.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        finalizer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的注释已经很明显标注出来，这里小结一下内容。</p>
<ul>
<li><code>Finalizer</code>是<code>FinalReference</code>的子类，而<code>FinalReference</code>是<code>Reference</code>的实现，所以它的工作原理和其他引用类似，对象的状态更变和由ReferenceHandler线程密切相关。</li>
<li><code>Finalizer</code>内部维护了一个链表，每当JVM调用静态注册方法就会新建一个<code>Finalizer</code>实例加入到链表的头节点中，头节点元素为unfinalized，这里称此链表为unfinalized链表。</li>
<li><code>Finalizer</code>线程由<code>Finalizer</code>静态代码块构建并且运行，它是守护线程，优先级是最高优先级-2，它的作用就是提取unfinalized链表的元素并且执行元素对象的<code>finalize()</code>方法，过程中还会涉及到线程的阻塞、唤醒，以及unfinalized链表的重建等工作。</li>
</ul>
<p>由于静态方法<code>Finalizer#register(Object finalizee)</code>是由JVM调用的，所以我们必须要分析一些JVM的源码，参考的是OpenJDK主分支的代码，文件是<code>instanceKlass.cpp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">instanceOop <span class="title">InstanceKlass::register_finalizer</span><span class="params">(instanceOop i, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (TraceFinalizerRegistration) &#123;</span><br><span class="line">    tty-&gt;<span class="built_in">print</span>(<span class="string">"Registered "</span>);</span><br><span class="line">    i-&gt;print_value_on(tty);</span><br><span class="line">    tty-&gt;print_cr(<span class="string">" ("</span> INTPTR_FORMAT <span class="string">") as finalizable"</span>, p2i(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">instanceHandle <span class="title">h_i</span><span class="params">(THREAD, i)</span></span>;</span><br><span class="line">  <span class="comment">// Pass the handle as argument, JavaCalls::call expects oop as jobjects</span></span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  <span class="function">JavaCallArguments <span class="title">args</span><span class="params">(h_i)</span></span>;</span><br><span class="line">  <span class="comment">// 这里Universe::finalizer_register_method()获取到的就是Finalizer#register方法句柄</span></span><br><span class="line">  <span class="function">methodHandle <span class="title">mh</span> <span class="params">(THREAD, Universe::finalizer_register_method())</span></span>;</span><br><span class="line">  JavaCalls::call(&amp;result, mh, &amp;args, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> h_i();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用的是<code>javaCalls.cpp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaCalls::call</span><span class="params">(JavaValue* result, <span class="keyword">const</span> methodHandle&amp; method, JavaCallArguments* args, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if we need to wrap a potential OS exception handler around thread</span></span><br><span class="line">  <span class="comment">// This is used for e.g. Win32 structured exception handlers</span></span><br><span class="line">  assert(THREAD-&gt;is_Java_thread(), <span class="string">"only JavaThreads can make JavaCalls"</span>);</span><br><span class="line">  <span class="comment">// Need to wrap each and every time, since there might be native code down the</span></span><br><span class="line">  <span class="comment">// stack that has installed its own exception handlers</span></span><br><span class="line">  os::os_exception_wrapper(call_helper, result, method, args, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来看就是把创建对象过程中，如果有必要注册<code>Finalizer</code>(一般是覆盖了<code>finalize()</code>方法)，则基于当前线程通过<code>Finalizer#register(Object finalizee)</code>把当前新建的实例注册到<code>Finalizer</code>自身维护的链表中(如果没理解错，所谓的<code>F-Queue</code>就是这个链表了)，等待后台<code>Finalizer</code>线程轮询并且执行链表中对象的<code>finalize()</code>方法。</p>
<h2 id="各类引用以及它们的使用场景">各类引用以及它们的使用场景</h2>
<p>这里提到的各类引用目前就是四种：强引用(StrongReference)、软引用(SoftReference)、弱引用(WeakReference)和虚引用(PhantomReference)。其实还有特殊的引用类型<code>FinalReference</code>，它是包私有的，并且只有一个子类型<code>Finalizer</code>。</p>
<h3 id="StrongReference">StrongReference</h3>
<p>StrongReference也就是强引用，它是使用最普遍的一种引用，<code>java.lang.ref</code>包下没有强引用对应的类型。一个比较明确的强引用定义就是：所有和GC Root之间存在引用链的对象都具备强引用。举个简单例子：形如<code>Object o = new Object();</code>在方法体中使用new关键字声明的对象一般就是强引用。如果一个对象具备强引用，垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会出现回收具有强引用的对象来解决内存不足的情况。当然，如果有共享的成员变量在方法退出之前置为null，相当于断绝成员变量和GC Root的引用链，在合适的时机是有利于GC后具备强引用的对象的回收，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object shareValue = XXX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    shareValue = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来有人过度信奉类似上面的这个实践，出现了一条比较诡异的编码实践：强引用使用完毕后都要置为null方便对象回收。但是实际上，这个实践并不是在任何场景都是合理的。</p>
<h3 id="SoftReference">SoftReference</h3>
<p>SoftReference也就是软引用，它是用来描述一些&quot;还有用但是非必须&quot;的对象。对于软引用关联着的对象，在JVM应用即将发生内存溢出异常之前，将会把这些软引用关联的对象列进去回收对象范围之中进行第二次回收。如果这次回收之后还是没有足够的内存，才会抛出内存溢出异常。简单来说就是：</p>
<ul>
<li>如果内存空间足够，垃圾回收器就不会回收软引用关联着的对象。</li>
<li>如果内存空间不足，垃圾回收器在将要抛出内存溢出异常之前会回收软引用关联着的对象。</li>
</ul>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VM参数：-Xmx4m -Xms4m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ReferenceQueue&lt;SoftReferenceObject&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">		SoftReferenceObject object = <span class="keyword">new</span> SoftReferenceObject();</span><br><span class="line">		SoftReference&lt;SoftReferenceObject&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(object, queue);</span><br><span class="line">		object = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		System.out.println(reference.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">120_000</span>];</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"SoftReferenceObject"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行后输出结果</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>上面的例子故意把JVM的启动的最大Heap内存和初始Heap内存设置为4MB，使用这个对象初始化一个比较大的整型数组并且关系到一个软引用对象中，GC之后，发现软引用关联的对象被回收了。</p>
<h3 id="WeakReference">WeakReference</h3>
<p>WeakReference也就是弱引用，弱引用和软引用类似，它是用来描述&quot;非必须&quot;的对象的，它的强度比软引用要更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，简言之就是：一旦发生GC必定回收被弱引用关联的对象，不管当前的内存是否足够。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ReferenceQueue&lt;WeakReferenceObject&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">		WeakReferenceObject object = <span class="keyword">new</span> WeakReferenceObject();</span><br><span class="line">		System.out.println(object);</span><br><span class="line">		WeakReference&lt;WeakReferenceObject&gt; reference = <span class="keyword">new</span> WeakReference&lt;&gt;(object, queue);</span><br><span class="line">		object = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		System.out.println(reference.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"WeakReferenceObject"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行后输出结果</span></span><br><span class="line">WeakReferenceObject</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中没有设定JVM的堆内存，因此不存在内存不足的情况，可见弱引用关联的对象在GC之后被回收了。弱引用适合用来做对内存敏感的缓存，很常用的<code>WeakHashMap</code>就是基于弱引用实现的。</p>
<h3 id="PhantomReference">PhantomReference</h3>
<p>PhantomReference也就是虚引用，也叫幽灵引用或者幻影引用，它是所有引用类型中最弱的一种。一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例(<code>PhantomReference</code>覆盖了<code>Reference#get()</code>并且总是返回null)。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个<strong>系统通知</strong>。<code>PhantomReference</code>有两个比较常用的子类是<code>java.lang.ref.Cleaner</code>和<code>jdk.internal.ref.Cleaner</code>，其中前者提供的功能是开发者用于在引用对象回收的时候触发一个动作(<code>java.lang.ref.Cleaner$Cleanable</code>)，后者用于<code>DirectByteBuffer</code>对象回收的时候对于堆外内存的回收，可以翻看前面描述<code>java.lang.ref.Reference#processPendingReferences()</code>源码的时候，ReferenceHandler线程会对pending链表中的<code>jdk.internal.ref.Cleaner</code>类型引用对象调用其<code>clean()</code>方法。<code>PhantomReference</code>本身使用场景比较少，这里举一下<code>java.lang.ref.Cleaner</code>注释中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (CleaningExample o = <span class="keyword">new</span> CleaningExample(<span class="number">11</span>))&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		CleaningExample o2 = <span class="keyword">new</span> CleaningExample(<span class="number">22</span>);</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CleaningExample</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Cleaner cleaner = Cleaner.create();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CleaningExample</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">		state = <span class="keyword">new</span> State(s);</span><br><span class="line">		cleanable = cleaner.register(<span class="keyword">this</span>, state);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.s = s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"State runnable in action.State value = "</span> + s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		cleanable.clean();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，沙面的代码执行完毕只会输出&quot;State runnable in action.State value = 11&quot;，并没有输出&quot;State runnable in action.State value = 22&quot;，这是因为无法预测强引用对象被回收的时机。<code>java.lang.ref.Cleaner</code>主要是用于预防实现了<code>AutoCloseable</code>接口的实例忘记调用<code>close()</code>方法在对象被垃圾收集器回收的时候(内存回收)做一个兜底的清理工作，在JDK9之后，<code>java.lang.ref.Cleaner</code>主要是为了替代已经标识为过期的<code>Object#finalize()</code>方法。</p>
<p>扩展阅读：可以注意阅读一下《Effective Java 3rd》的第8小节，摘抄部分内容如下：终结方法（Finalizer）是不可预知的，很多时候是危险的，而且一般情况下是不必要的。…在Java 9中，终结方法已经被遗弃了，但它们仍被Java类库使用，相应用来替代终结方法的是清理方法（cleaner）。比起终结方法，清理方法相对安全点，但仍是不可以预知的，运行慢的，而且一般情况下是不必要的。</p>
<p>JDK9中有很多原来使用覆盖<code>Object#finalize()</code>方法的清理工作实现都替换为<code>java.lang.ref.Cleaner</code>，但是仍然不鼓励使用这种方式。</p>
<h2 id="Reference和ReferenceQueue配合使用">Reference和ReferenceQueue配合使用</h2>
<p>前面基本介绍完了所有类型引用以及相关的源码，但是尚未提供例子说明<code>Reference</code>和<code>ReferenceQueue</code>是怎么配合使用的。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ReferenceQueue&lt;WeakReferenceObject&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">		WeakReferenceObject object = <span class="keyword">new</span> WeakReferenceObject();</span><br><span class="line">		WeakReference&lt;WeakReferenceObject&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(object, queue);</span><br><span class="line">		System.out.println(weakReference);</span><br><span class="line">		object = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Reference&lt;? extends WeakReferenceObject&gt; reference = queue.poll();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == reference) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(reference);</span><br><span class="line">				System.out.println(reference.get());</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"WeakReferenceObject"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ref.WeakReference@<span class="number">6537</span>cf78</span><br><span class="line">java.lang.ref.WeakReference@<span class="number">6537</span>cf78</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>可见轮询<code>ReferenceQueue</code>实例得到的弱引用实例和创建的是一致的，只是它持有的关联的对象已经被回收，得到null。上面的<code>ReferenceQueue#poll()</code>方法也可以替换为<code>ReferenceQueue#remove()</code>，这样子就不用写在死循环中，因为<code>ReferenceQueue#remove()</code>会阻塞到有元素可以出队。通过轮询绑定到<code>Reference</code>实例的<code>ReferenceQueue</code>实例，就可以得知<code>Reference</code>实例当前的状态并且判断它关联的我们真正关注的对象是否被回收。</p>
<h2 id="小结">小结</h2>
<ul>
<li><code>Reference</code>是<strong>非强引用</strong>的其他三种引用的共同父类。</li>
<li><code>ReferenceQueue</code>只存储了引用链表的头节点，提供了引用链表的操作，实际上，引用链表是<code>Reference</code>实例内部变量存储的。</li>
<li>ReferenceHandler守护线程线程由<code>Reference</code>的静态代码块创建和运行，作用是处理pending链表的引用元素使之状态变更，伴随着<code>ReferenceQueue</code>的相关操作。</li>
<li>Finalizer守护线程是由<code>Finalizer</code>类的静态代码块创建和运行的，作用是处理<code>Finalizer</code>类内部维护的F-Queue链表(链表元素入队操作由JVM实现)的元素调用关联对象的<code>finalize()</code>方法。</li>
<li>ReferenceHandler守护线程线和Finalizer守护线程共同协作才能使引用类型对象内存回收系统的工作能够正常进行。</li>
</ul>
<p><strong>四种引用类型的总结</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">引用类型</th>
<th style="text-align:center">被垃圾收集器回收的时机</th>
<th style="text-align:center">主要用途</th>
<th style="text-align:center">生存周期</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">直到内存溢出也不会回收</td>
<td style="text-align:center">普遍对象的状态</td>
<td style="text-align:center">从创建到JVM实例终止运行</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">垃圾回收并且内存不足时</td>
<td style="text-align:center">有用但非必须的对象缓存</td>
<td style="text-align:center">从创建到垃圾回收并且内存不足时</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">垃圾回收时</td>
<td style="text-align:center">非必须的对象缓存</td>
<td style="text-align:center">上一次垃圾回收结束到下一次垃圾回收开始</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">-</td>
<td style="text-align:center">关联的对象被垃圾收集器回收时候得到一个系统通知</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>参考资料：</p>
<ul>
<li>JDK11部分源码。</li>
<li>《深入理解Java虚拟机-2nd》- 这本书算是国内书籍写得比较良心的一本了，不过有很多小的问题或者笔误之处，需要自行发现和修正。</li>
</ul>
<p>(过年比较懒，很久没发文 e-a-20190215 c-14-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reference/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reference</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


	
</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>




	<!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
	

	


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
