<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Category: Middleware | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 10px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/03/30/quartz-doc-translation-lesson-3/">
      第三章：Job和JobDetail的更多细节
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年3月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/Quartz/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;Quartz</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：10分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-03-30T01:51:04+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年3月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>第三章：Job和JobDetail的更多细节</h1>
<p>正如你在<a href="../quartz-doc-translation-lesson-2">第二章：Quartz API、调度任务以及触发器</a>看到的，org.quartz.Job很容易实现，在接口中只有一个<code>execute</code>方法。本节主要关注：Job的特点、Job接口的execute方法以及JobDetail。</p>
<p>你定义了一个实现Job接口的类，这个类仅仅表明该Job需要完成什么类型的任务，除此之外，Quartz还需要知道该Job实例所包含的属性；这将由JobDetail类来完成。</p>
<p>JobDetail实例是通过JobBuilder类创建的，导入该类下的所有静态方法，会让你编码时有DSL的感觉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.*;</span><br></pre></td></tr></table></figure>
<p>让我们先看看Job的特征（nature）以及Job实例的生命期。不妨先回头看看<a href="../quartz-doc-translation-lesson-1">第一章：使用Quartz</a>中的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define the job and tie it to our HelloJob class</span></span><br><span class="line"> JobDetail job = newJob(HelloJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">     .withIdentity("myJob", "group1") // name "myJob", group "group1"</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Trigger the job to run now, and then every 40 seconds</span></span><br><span class="line"> Trigger trigger = newTrigger()</span><br><span class="line">     .withIdentity(<span class="string">"myTrigger"</span>, <span class="string">"group1"</span>)</span><br><span class="line">     .startNow()</span><br><span class="line">     .withSchedule(simpleSchedule()</span><br><span class="line">         .withIntervalInSeconds(<span class="number">40</span>)</span><br><span class="line">         .repeatForever())            </span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Tell quartz to schedule the job using our trigger</span></span><br><span class="line"> sched.scheduleJob(job, trigger);</span><br></pre></td></tr></table></figure>
<p>现在这样定义下面这样的一个调度任务类“HelloJob”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HelloJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> JobExecutionException</span>&#123;</span><br><span class="line">     System.err.println(<span class="string">"Hello!  HelloJob is executing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们传给Scheduler一个JobDetail实例，因为我们在创建JobDetail时，将要执行的Job的类名(类型)传给了JobDetail，所以Scheduler就知道了要执行何种类型的Job；每次当Scheduler执行Job时，在调用其<code>execute(…)</code>方法之前会<strong>创建该类的一个新的实例</strong>；执行完毕，对该实例的引用就被丢弃了，实例会被垃圾回收；这种执行策略带来的一个后果是，<strong>Job必须有一个无参的构造函数</strong>（当使用默认的JobFactory时）；另一个后果是，在Job类中，不应该定义有状态的数据属性，因为在Job的多次执行中，这些属性的值不会保留。</p>
<p>译者注：这里又一次强调了Job是无状态的。另外，可以实现自定义的JobFactory来改变获取Job实例的方式，例如从Spring的IOC容器中获取，这样就不用每次新建一个Job实例再执行。</p>
<p>那么如何给Job实例增加属性或配置呢？如何在Job的多次执行中，跟踪Job的状态呢？答案就是:JobDataMap，JobDetail对象的一部分。</p>
<h2 id="JobDataMap">JobDataMap</h2>
<p>JobDataMap中可以包含不限量的（序列化的）数据对象，在Job实例执行的时候，可以使用其中的数据；JobDataMap是java.util.Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。</p>
<p>将Job加入到Scheduler之前，在构建JobDetail时，可以将数据放入JobDataMap，如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define the job and tie it to our DumbJob class</span></span><br><span class="line"> JobDetail job = newJob(DumbJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">     .withIdentity("myJob", "group1") // name "myJob", group "group1"</span><br><span class="line">     .usingJobData(<span class="string">"jobSays"</span>, <span class="string">"Hello World!"</span>)</span><br><span class="line">     .usingJobData(<span class="string">"myFloatValue"</span>, <span class="number">3.141f</span>)</span><br><span class="line">     .build();</span><br></pre></td></tr></table></figure>
<p>在Job的执行过程中，可以从JobDataMap中取出数据，如下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumbJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DumbJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> JobExecutionException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      JobKey key = context.getJobDetail().getKey();</span><br><span class="line"></span><br><span class="line">      JobDataMap dataMap = context.getJobDetail().getJobDataMap();</span><br><span class="line"></span><br><span class="line">      String jobSays = dataMap.getString(<span class="string">"jobSays"</span>);</span><br><span class="line">      <span class="keyword">float</span> myFloatValue = dataMap.getFloat(<span class="string">"myFloatValue"</span>);</span><br><span class="line"></span><br><span class="line">      System.err.println(<span class="string">"Instance "</span> + key + <span class="string">" of DumbJob says: "</span> + jobSays + <span class="string">", and val is: "</span> + myFloatValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>**如果您使用具备持久化特性的JobStore（在本教程的JobStore部分中进行了讨论），您应该谨慎决定放置在JobDataMap中的内容，因为其中的对象将被序列化，因此它们容易出现类版本问题。**显然，标准的Java类型应该是非常安全的，但除此之外，任何时候有人改变你已经序列化了实例的类的定义时，都必须注意不要打破兼容性。另外，你可以强制要求JDBC-JobStore和JobDataMap只允许在JobDataMap中存储基本类型和字符串类型，这样可以避免后续的序列化问题。</p>
<p>如果你在Job的实现类中，为JobDataMap中存储的数据的key增加set方法（如在上面示例中，增加setJobSays(String val)方法），那么Quartz的默认JobFactory实现在Job被实例化的时候会自动调用这些set方法，这样你就不需要在<code>execute()</code>方法中显式地从JobDataMap中取数据了。</p>
<p>如果你有一个存储在调度器中的调度任务，供多个触发器定期/重复使用，但每次独立触发，则希望为作业提供不同的数据输入，可以为触发器定义与之关联的JobDataMap。</p>
<p>在Job执行时，JobExecutionContext中的JobDataMap为我们提供了很多的便利。它是JobDetail中的JobDataMap和Trigger中的JobDataMap的数据并集，但是如果存在相同的数据，则后添加者会覆盖之前添加的Key相同的值（毕竟就是一个java.util.Map的实例）。</p>
<p>以下是在作业执行期间从JobExecutionContext的合并JobDataMap获取数据的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumbJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DumbJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> JobExecutionException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      JobKey key = context.getJobDetail().getKey();</span><br><span class="line"></span><br><span class="line">      JobDataMap dataMap = context.getMergedJobDataMap();  <span class="comment">// Note the difference from the previous example</span></span><br><span class="line"></span><br><span class="line">      String jobSays = dataMap.getString(<span class="string">"jobSays"</span>);</span><br><span class="line">      <span class="keyword">float</span> myFloatValue = dataMap.getFloat(<span class="string">"myFloatValue"</span>);</span><br><span class="line">      ArrayList state = (ArrayList)dataMap.get(<span class="string">"myStateData"</span>);</span><br><span class="line">      state.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">      System.err.println(<span class="string">"Instance "</span> + key + <span class="string">" of DumbJob says: "</span> + jobSays + <span class="string">", and val is: "</span> + myFloatValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果你希望使用JobFactory实现数据的自动“注入”功能，则示例代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DumbJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  String jobSays;</span><br><span class="line">  <span class="keyword">float</span> myFloatValue;</span><br><span class="line">  ArrayList state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DumbJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> JobExecutionException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    JobKey key = context.getJobDetail().getKey();</span><br><span class="line"></span><br><span class="line">    JobDataMap dataMap = context.getMergedJobDataMap();  <span class="comment">// Note the difference from the previous example</span></span><br><span class="line"></span><br><span class="line">    state.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">    System.err.println(<span class="string">"Instance "</span> + key + <span class="string">" of DumbJob says: "</span> + jobSays + <span class="string">", and val is: "</span> + myFloatValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobSays</span><span class="params">(String jobSays)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.jobSays = jobSays;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyFloatValue</span><span class="params">(<span class="keyword">float</span> myFloatValue)</span> </span>&#123;</span><br><span class="line">    myFloatValue = myFloatValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(ArrayList state)</span> </span>&#123;</span><br><span class="line">    state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会注意到该类的整体代码更长，但<code>execute()</code>方法中的代码更简洁清晰。而且，虽然代码更多了，但如果你的IDE可以自动生成Setter方法，你就不需要写代码调用相应的方法从JobDataMap中获取数据了，所以你实际需要编写的代码更少了。当前，如何选择，由你决定。</p>
<h2 id="Job实例">Job实例</h2>
<p>很多使用者对于Job实例到底由什么构成感到很迷惑。我们将尝试在这里解释一下，并且在下面的部分中解释关于调度任务状态和并发性相关内容。</p>
<p>您可以创建一个单独的Job类，并通过创建JobDetails的多个实例（每个实例具有自己的属性集和JobDataMap），最后，将所有的Job实例都添加加到Scheduler中。</p>
<p>例如，你可以创建一个实现Job接口的类，名为“SalesReportJob”。该Job需要一个参数（通过JobDataMap传入）指定销售报告应该基于的销售人员的名称。然后，你可以创建多个Job实例（JobDetails），比如“SalesReportForJoe”、“SalesReportForMike”，将“joe”和“mike”作为JobDataMap的数据传给对应的Job实例。</p>
<p>当触发器触发时，它所关联的JobDetail（实例定义）将被加载，并且它引用的作业类将通过Scheduler上配置的JobFactory实例化。默认的JobFactory只是在作业类上调用<code>newInstance()</code>，然后尝试调用该类的匹配JobDataMap中的键的名称的setter方法。你可能希望创建自己的JobFactory实现来完成诸如让应用程序的IoC或DI容器生成/初始化Job实例等事情。</p>
<p>在Quartz的描述语言中，我们将每个存储的JobDetail称为“Job定义”或“JobDetail实例”，并将每个正在执行的作业称为“Job实例”或“Job定义的实例”。通常，如果我们只使用“Job”这个词，我们就是指一个命名定义，或者JobDetail。当我们指的是实现工作界面的类时，我们通常使用术语“Job类”。</p>
<h2 id="Job的状态和并发性">Job的状态和并发性</h2>
<p>关于Job状态数据（也就是JobDataMap）和并发性还有一些内容需要补充。有几个注释可以添加到你的Job类中，这些注解会影响Job的状态和并发性。</p>
<p>@DisallowConcurrentExecution是一个注解，可以添加到Job类中，告诉Quartz不要同时执行给定Job定义（指给定Job类）的多个实例。<br>
注意这里的措词。拿前一小节的例子来说，如果“SalesReportJob”类上有该注解，则同一时刻仅允许执行一个“SalesReportForJoe”实例，但可以并发地执行“SalesReportForMike”类的一个实例。所以该限制是针对JobDetail的，而不是Job类。但是我们认为（在设计Quartz的时候）应该将该注解放在Job类上，因为Job类的改变经常会导致其行为发生变化。</p>
<p>@PersistJobDataAfterExecution是一个注解，可以添加到Job类中，告诉Quartz在<code>execute()</code>方法成功完成后（不抛出异常）更新JobDetail的JobDataMap的存储副本数据，使得该Job（即JobDetail）在下一次执行的时候，JobDataMap中是更新后的数据，而不是更新前的旧数据。像 @DisallowConcurrentExecution注解一样，尽管注解是加在Job类上的，但其限制作用是针对Job实例的，而不是Job类的。由Job类来承载该注解，是因为此注解的功能会影响类的编码方式（例如，‘有状态’需要被执行方法内的代码明确’理解’–&gt; 这里原文是e.g. the ‘statefulness’ will need to be explicitly ‘understood’ by the code within the execute method）。</p>
<p>如果你使用了<code>@PersistJobDataAfterExecution</code>注解，我们强烈建议你同时使用<code>@DisallowConcurrentExecution</code>注解，因为当同一个Job（JobDetail）的两个实例被并发执行时，由于竞争，JobDataMap中存储的数据很可能是不确定的。</p>
<h2 id="Job的其他属性">Job的其他属性</h2>
<p>通过JobDetail对象，可以给Job实例配置的其它属性有：</p>
<ul>
<li>Durability：持久化特性，布尔值。如果一个Job是非持久的，当没有活跃的Trigger与之关联的时候，会被自动地从Scheduler中删除。也就是说，非持久的Job的生命期是由Trigger的存在与否决定的。</li>
<li>RequestsRecovery - 请求恢复特性，布尔值。如果一个Job是可恢复的，并且在其执行的时候，Scheduler发强制关闭（hard shutdown)（比如运行的进程崩溃了或者服务器宕机了），则当Scheduler重新启动的时候，该Job会被重新执行。此时，该Job的<code>JobExecutionContext.isRecovering()</code>返回true。</li>
</ul>
<p>这两个属性在JobBuilder中都有相应的设置方法。</p>
<h2 id="JobExecutionException">JobExecutionException</h2>
<p>最后，我们需要通知你关于该<code>Job.execute(..)</code>方法的一些细节。唯一可以从execute方法抛出的异常（包括RuntimeExceptions）是JobExecutionException。因此，通常应该用“try-catch”块来包装<code>execute</code>方法的全部内容。你还应该花一些时间查看JobExecutionException的文档，因为你的Job可以使用该异常告诉Scheduler，你希望如何来处理发生的异常。</p>
<p>原文链接：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-03.html" target="_blank" rel="noopener">tutorial-lesson-03</a></p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/Quartz/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Quartz</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/03/30/quartz-doc-translation-lesson-1/">
      第一章：使用Quartz
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年3月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/Quartz/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;Quartz</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：395字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：1分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-03-30T01:49:36+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年3月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>第一章：使用Quartz</h1>
<h2 id="内容">内容</h2>
<p>在使用此调度器(Scheduler)之前，它需要被实例化(谁猜到这一点了? &lt;-- 这里估计是官方的调皮)。为了实例化调度器，你需要用到SchedulerFactory。一些Quartz的使用者可能会在JNDI存储中保留SchedulerFactory的实例，其他使用者可能会觉得直接初始化会更加简单（例如下面的示例）。</p>
<p>一旦调度器完成了实例化，就可以启动(start)、暂停(stand-by)、停止(shutdown)。注意：一旦调度器被停止，它就不能够重新启动，除非重新实例化另一个调度器实例。所有的触发器(Trigger)不会触发任务(也就是任务不会执行)，除非调度器已经启动。但是如果调度器(虽然已经启动)处于暂停状态，所有的触发器也不会触发任务。</p>
<p>下面是一个代码片段，实例化并启动一个调度器，调度执行一个任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SchedulerFactory schedFact = <span class="keyword">new</span> org.quartz.impl.StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line"> Scheduler sched = schedFact.getScheduler();</span><br><span class="line"></span><br><span class="line"> sched.start();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// define the job and tie it to our HelloJob class</span></span><br><span class="line"> JobDetail job = newJob(HelloJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">     .withIdentity("myJob", "group1")</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Trigger the job to run now, and then every 40 seconds</span></span><br><span class="line"> Trigger trigger = newTrigger()</span><br><span class="line">     .withIdentity(<span class="string">"myTrigger"</span>, <span class="string">"group1"</span>)</span><br><span class="line">     .startNow()</span><br><span class="line">     .withSchedule(simpleSchedule()</span><br><span class="line">         .withIntervalInSeconds(<span class="number">40</span>)</span><br><span class="line">         .repeatForever())</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Tell quartz to schedule the job using our trigger</span></span><br><span class="line"> sched.scheduleJob(job, trigger);</span><br></pre></td></tr></table></figure>
<p>正如你所见，使用Quartz是十分简单的。在下一节<a href="../quartz-doc-translation-lesson-2">第二章：Quartz API、调度任务以及触发器</a>中我们将会概述一下调度任务、触发器以及Quartz的API，以便你可以更全面地了解这个例子。</p>
<p>原文链接：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-01.html" target="_blank" rel="noopener">tutorial-lesson-01</a></p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/Quartz/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Quartz</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/03/30/quartz-doc-translation-lesson-2/">
      第二章：Quartz API、调度任务以及触发器
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年3月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/Quartz/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;Quartz</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：6分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-03-30T01:49:20+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年3月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>第二章：Quartz API、调度任务以及触发器</h1>
<h2 id="Quartz-API">Quartz API</h2>
<p>下面是Quartz API中的关键接口：</p>
<ul>
<li>Scheduler：与调度器交互的主要API(实际上这个就是调度器)。</li>
<li>Job：org.quartz.Job，希望由调度器执行的组件，是一个接口，也就是我们使用的时候被调度的任务需要实现此接口。</li>
<li>JobDetail：org.quartz.JobDetail，调度任务详情，用于定义调度任务。</li>
<li>Trigger：org.quartz.Trigger，也就是触发器，它是一个定义了给定调度任务将被执行的时间表的组件。</li>
<li>JobBuilder：org.quartz.JobBuilder，用于定义或者构建JobDetail实例。</li>
<li>TriggerBuilder：org.quartz.TriggerBuilder，用于定义或者构建Trigger实例。</li>
</ul>
<p>其实Job就是使用者需要实现的调度任务接口，它以JobDetail的形式存放在Quartz管理的内存或者表里面。</p>
<p>Scheduler的生命期，从SchedulerFactory创建它的实例时开始，到Scheduler的实例调用shutdown()方法时结束。Scheduler被创建后，可以添加、删除和查询JobDetail和Trigger，以及执行其它们与调度相关的操作（如暂停Trigger）。但是，Scheduler只有在调用start()方法后，才会真正地触发Trigger（Trigger运作之后才能fire具体的Job），见<a href="../quartz-doc-translation-lesson-1">第一章：使用Quartz</a>。</p>
<p>Quartz提供的“Builder”类，可以认为是一种领域特定语言（DSL，Domain Specific Language)。其实这些Builder就是流式的API。上一章你已经看过相应的例子，这里再贴出来一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define the job and tie it to our HelloJob class</span></span><br><span class="line"> JobDetail job = newJob(HelloJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">     .withIdentity("myJob", "group1") // name "myJob", group "group1"</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Trigger the job to run now, and then every 40 seconds</span></span><br><span class="line"> Trigger trigger = newTrigger()</span><br><span class="line">     .withIdentity(<span class="string">"myTrigger"</span>, <span class="string">"group1"</span>)</span><br><span class="line">     .startNow()</span><br><span class="line">     .withSchedule(simpleSchedule()</span><br><span class="line">         .withIntervalInSeconds(<span class="number">40</span>)</span><br><span class="line">         .repeatForever())            </span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Tell quartz to schedule the job using our trigger</span></span><br><span class="line"> sched.scheduleJob(job, trigger);</span><br></pre></td></tr></table></figure>
<p>定义JobDetail的代码使用的是从JobBuilder静态导入的方法。同样，定义Trigger的代码使用的是从TriggerBuilder静态导入的方法 。 另外，也导入了SimpleSchedulerBuilder类的静态方法。DSL的静态导入可以通过以下导入语句来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.CronScheduleBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.CalendarIntervalScheduleBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.DateBuilder.*;</span><br></pre></td></tr></table></figure>
<p>SchedulerBuilder接口的各种实现类，可以定义不同类型的调度计划（schedule）；DateBuilder类包含很多方法，可以很方便地构造表示不同时间点的java.util.Date实例（如定义下一个小时为偶数的时间点，如果当前时间为9:43:27，则定义的时间为10:00:00）。</p>
<p>其实就是SchedulerBuilder是策略接口，它的子类提供了多种不同类型的调度计划的实现，DateBuilder内部的多数方法依赖于Calendar，它主要功能是用来快速定义一个具体的时刻，因为有时候Cron表达式可能不满足特定的场景，这个时候DateBuilder可以派上用场。</p>
<h2 id="Jobs-and-Triggers">Jobs and Triggers</h2>
<p>一个调度任务就是一个实现了org.quartz.Job接口(只有一个简单的接口方法execute)的类：</p>
<p><strong>The Job Interface</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.quartz;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> JobExecutionException</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>当Job的一个Trigger被触发（稍后会讲到）时，<code>execute()</code>方法由Scheduler的一个工作线程调用。传递给<code>execute()</code>方法的JobExecutionContext对象中保存着该Job运行时的一些信息 ，执行Job的Scheduler的引用，触发Job的Trigger的引用，JobDetail对象引用，以及一些其它信息（如果使用了Spring的话，可以传入Spring的上下文对象ApplicationContext）。</p>
<p>JobDetail对象是在将Job加入Scheduler时，由客户端程序（你的程序）创建的。它包含Job的各种属性设置，以及用于存储Job实例状态信息的JobDataMap。本节是对Job实例的简单介绍，更多的细节将在下一节讲到。</p>
<p>Trigger用于触发Job的执行。当你准备调度一个Job时，你创建一个Trigger的实例，然后设置调度相关的属性。Trigger也有一个相关联的JobDataMap，用于给Job传递一些触发相关的参数。Quartz自带了各种不同类型的Trigger，最常用的主要是SimpleTrigger(间隔一定时间(重复)执行)和CronTrigger(基于Cron表达式构建调度计划)。</p>
<p>SimpleTrigger主要用于一次性执行的Job（只在某个特定的时间点执行一次），或者Job在特定的时间点执行，重复执行N次，每次执行间隔T个时间单位。CronTrigger在基于日历的调度上非常有用，如“每个星期五的正午”，或者“每月的第十天的上午10:15”等。</p>
<p>为什么既有Job，又有Trigger呢？很多任务调度器并不区分Job和Trigger。有些调度器只是简单地通过一个执行时间和一些Job标识符来定义一个Job；其它的一些调度器将Quartz中描述的Job和Trigger对象合二为一。在开发Quartz的时候，我们认为将触发器和要调度的任务分离是合理的。在我们看来，这可以带来很多好处。</p>
<p>例如，<strong>Job被创建后，可以保存在Scheduler中，与Trigger是独立的，同一个Job可以有多个Trigger；这种松耦合的另一个好处是，当与Scheduler中的Job关联的Trigger都过期时，可以配置Job稍后被重新调度，而不用重新定义Job；还有，可以修改或者替换Trigger，而不用重新定义与之关联的Job。</strong></p>
<p>译者注：上面这段内容十分重要，在Quartz中，调度任务和触发器是独立分离的，并且可以总结出一点：Quartz中Job是无状态的，有状态的是Trigger。因此我们在做一个调度任务查询列表展示的时候应该展示的是<strong>触发器的状态</strong>，而不应该是调度任务的状态；至于调度任务是否执行成功，只能通过添加监听器或者查看日志去判断或者说调度任务的运行状态应该交由开发者去监控和管理。</p>
<h2 id="Identities">Identities</h2>
<p>Identities其实就是调度任务和触发器的身份标识。当Job和Trigger注册到Quartz的调度器中的时候需要定义相应的识别标记(其实就是JobKey和TriggerKey)。调度任务和触发器（JobKey和TriggerKey）的识别标记中允许使用“分组(group)”，这对于组织你的工作和触发诸如“报告工作”和“维护工作”等类别是有用的。作业或触发器的键的名称部分必须在组内是惟一的—换句话说，作业或触发器的完整键（或标识符）是名称（name）和组别（group）的复合。这里可以先这样理解，JobKey(name和group)是JobDetail的联合主键，TriggerKey(name和group)是Trigger的联合主键。</p>
<p>你现在对调度任务和触发器有了大致的了解，你可以在<a href="../quartz-doc-translation-lesson-3">第三章：Job和JobDetail的更多细节</a>和<a href="../quartz-doc-translation-lesson-4">第四章：关于Trigger的更多细节</a>了解到更多关于它们的使用方式。</p>
<p>原文链接：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-02.html" target="_blank" rel="noopener">tutorial-lesson-02</a></p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/Quartz/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Quartz</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/03/30/quartz-doc-translation-entry/">
      Quartz官方文档翻译
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年3月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/Quartz/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;Quartz</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：345字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：1分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-03-30T11:29:44+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年3月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>Quartz官方文档翻译</h1>
<p>2018年5月的时候，因为要理解Quartz的相关东西，当时翻阅过它的文档顺便把它翻译了出来，已经忘记了这个事，好在存档还在硬盘上。其中有部分章节为了节省时间使用了机翻然后人工润色，目前阅读起来应该没有障碍。</p>
<p>这段时间太忙(996，快ICU了)，先对基础教程部分重新排版和二次润色，剩下的其他文档有空再补一下。</p>
<p>术语：</p>
<ul>
<li>Scheduler：调度器。</li>
<li>SchedulerFactory：调度器工厂。</li>
<li>Trigger：触发器。</li>
<li>Job：(调度)任务或者作业，在Quartz中体现为JobDetail。</li>
</ul>
<p>在后面的翻译中，因为个人习惯，可能会中英互用，映射关系为：</p>
<ul>
<li>Scheduler === 调度器</li>
<li>SchedulerFactory === 调度器工厂</li>
<li>Trigger === 触发器</li>
<li>Job、JobDetail === (调度)任务</li>
<li>fire === 触发</li>
</ul>
<h2 id="基础篇">基础篇</h2>
<ul>
<li><a href="../quartz-doc-translation-lesson-1">第一章：使用Quartz</a></li>
<li><a href="../quartz-doc-translation-lesson-2">第二章：Quartz API、调度任务以及触发器</a></li>
<li><a href="../quartz-doc-translation-lesson-3">第三章：Job和JobDetail的更多细节</a></li>
<li><a href="../quartz-doc-translation-lesson-4">第四章：关于Trigger的更多细节</a></li>
<li><a href="../quartz-doc-translation-lesson-5">第五章：SimpleTrigger</a></li>
<li><a href="../quartz-doc-translation-lesson-6">第六章：CronTrigger</a></li>
<li><a href="../quartz-doc-translation-lesson-7">第七章：Trigger监听器和Job监听器</a></li>
<li><a href="../quartz-doc-translation-lesson-8">第八章：Scheduler监听器</a></li>
<li><a href="../quartz-doc-translation-lesson-9">第九章：JobStores</a></li>
<li><a href="../quartz-doc-translation-lesson-10">第十章：配置、资源的使用以及SchedulerFactory</a></li>
<li><a href="../quartz-doc-translation-lesson-11">第十一章：高级(企业级)特性</a></li>
<li><a href="../quartz-doc-translation-lesson-12">第十二章：其他特性</a></li>
</ul>
<h2 id="特别教程">特别教程</h2>
<ul>
<li><a href="../quartz-doc-translation-cron-trigger">特别教程-CronTrigger教程</a></li>
</ul>
<h2 id="其他">其他</h2>
<p>to be continue…</p>
<p>(e-a-20170526 c-14-d r-a-20180330)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/Quartz/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Quartz</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/18/rabbitmq-extension-exchange-binding/">
      RabbitMQ扩展之交换器间的绑定
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月18日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：583字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：2分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-18T23:40:44+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月18日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>RabbitMQ扩展之交换器间的绑定</h1>
<h2 id="概要">概要</h2>
<p>AMQP-0-9-1中提供了<code>queue.bind</code>方法用于绑定一个队列到一个交换器，然后发送消息的时候，数据流总是先通过交换器(source)最终到达目标队列中(destination)。RabbitMQ实现了扩展，为交换器提供了一个<code>exchange.bind</code>方法用于绑定一个交换器到另一个交换器。交换器之间的绑定和队列与交换器的绑定在语义上是相同的：单向的、使用路由键和多种交换器类型。这一点允许使用者创建更丰富的路由拓扑。<code>exchange.bind</code>方法中的source和destination反映了消息的流向：从源(source)交换器到目标(destination)交换器。</p>
<p>像<code>queue.bind</code>方法一样，可以在相同的绑定端点上创建多个不同的交换器绑定，例如：</p>
<ul>
<li><code>exchange-source -&gt; exchange-destination-1 -&gt; queue-1</code>。</li>
<li><code>exchange-source -&gt; exchange-destination-2 -&gt; queue-2</code>。</li>
<li><code>exchange-source -&gt; exchange-destination-3 -&gt; queue-3</code>。</li>
</ul>
<p>RabbitMQ在消息传递期间检测并消除循环，并确保在任何路由拓扑上传递给定路由的每个队列，每个队列将只接收该消息的一个副本。</p>
<p>使用了auto-delete参数声明的交换器只有它关联的所有绑定关系都移除(不管是交换器之间的绑定还是交换器和队列的绑定)，它自身才会被删除。举个例子：</p>
<ul>
<li><code>exchange-source -&gt; exchange-destination -&gt; queue-1</code>。</li>
</ul>
<p>如果<code>exchange-source</code>被删除或者解除与<code>exchange-destination</code>的绑定关系同时<code>exchange-destination</code>和<code>queue-1</code>解除绑定，而<code>exchange-destination</code>使用了auto-delete参数声明，那么<code>exchange-destination</code>就会被删除。</p>
<p>RabbitMQ中还提供了一个<code>exchange.unbind</code>方法进行交换器之间绑定关系的解除。</p>
<h2 id="编码实现">编码实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeBindingMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			channel.exchangeDeclare(<span class="string">"exchange.source"</span>, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">			channel.exchangeDeclare(<span class="string">"exchange.destination"</span>, BuiltinExchangeType.DIRECT, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">			channel.queueDeclare(<span class="string">"exchange.binding.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">			channel.exchangeBind(<span class="string">"exchange.destination"</span>, <span class="string">"exchange.source"</span>, <span class="string">"exchange.routingKey"</span>);</span><br><span class="line">			channel.queueBind(<span class="string">"exchange.binding.queue"</span>, <span class="string">"exchange.destination"</span>, <span class="string">"exchange.routingKey"</span>);</span><br><span class="line">			channel.basicPublish(<span class="string">"exchange.source"</span>, <span class="string">"exchange.routingKey"</span>, MessageProperties.BASIC, <span class="string">"message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">			channel.exchangeUnbind(<span class="string">"exchange.destination"</span>, <span class="string">"exchange.source"</span>, <span class="string">"exchange.routingKey"</span>);</span><br><span class="line"><span class="comment">//			channel.exchangeDelete("exchange.source");</span></span><br><span class="line">			channel.queueUnbind(<span class="string">"exchange.binding.queue"</span>, <span class="string">"exchange.destination"</span>, <span class="string">"exchange.routingKey"</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在解除<code>exchange.source</code>和<code>exchange.destination</code>、<code>exchange.binding.queue</code>和<code>exchange.destination</code>之间的绑定后，<code>exchange.destination</code>会自动删除。</p>
<p>(本文完 e-a-20181218 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/zookeeper-curator-usage/">
      Zookeeper客户端Curator使用详解
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/Zookeeper/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;Zookeeper</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：12.8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：58分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T15:39:39+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>Zookeeper客户端Curator使用详解</h1>
<h2 id="前提">前提</h2>
<p>因为最近项目需要使用Zookeeper这个中间件，提前了解一下它的客户端Curator的使用。</p>
<h2 id="简介">简介</h2>
<p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。Patrixck Hunt（Zookeeper）以一句“Guava is to Java that Curator to Zookeeper”给Curator予高度评价。</p>
<p><strong>引子和趣闻：</strong><br>
Zookeeper名字的由来是比较有趣的，下面的片段摘抄自《从PAXOS到ZOOKEEPER分布式一致性原理与实践》一书：<br>
Zookeeper最早起源于雅虎的研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型的系统需要依赖一个类似的系统进行分布式协调，但是这些系统往往存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架。在立项初期，考虑到很多项目都是用动物的名字来命名的(例如著名的Pig项目)，雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家Raghu Ramakrishnan开玩笑说：再这样下去，我们这儿就变成动物园了。此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而Zookeeper正好用来进行分布式环境的协调——于是，Zookeeper的名字由此诞生了。</p>
<p>Curator无疑是Zookeeper客户端中的瑞士军刀，它译作&quot;馆长&quot;或者’‘管理者’’，不知道是不是开发小组有意而为之，笔者猜测有可能这样命名的原因是说明Curator就是Zookeeper的馆长(脑洞有点大：Curator就是动物园的园长)。<br>
Curator包含了几个包：</p>
<ul>
<li><strong>curator-framework</strong>：对zookeeper的底层api的一些封装。</li>
<li><strong>curator-client</strong>：提供一些客户端的操作，例如重试策略等。</li>
<li><strong>curator-recipes</strong>：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等。</li>
</ul>
<p>Maven依赖(使用curator的版本：2.12.0，对应Zookeeper的版本为：3.4.x，<strong>如果跨版本会有兼容性问题，很有可能导致节点操作失败</strong>)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>Curator的基本Api</h1>
<h2 id="创建会话">创建会话</h2>
<h3 id="1-使用静态工程方法创建客户端">1.使用静态工程方法创建客户端</h3>
<p>一个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework client =</span><br><span class="line">CuratorFrameworkFactory.newClient(</span><br><span class="line">						connectionInfo,</span><br><span class="line">						<span class="number">5000</span>,</span><br><span class="line">						<span class="number">3000</span>,</span><br><span class="line">						retryPolicy);</span><br></pre></td></tr></table></figure>
<p>newClient静态工厂方法包含四个主要参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">connectionString</td>
<td style="text-align:center">服务器列表，格式host1:port1,host2:port2,…</td>
</tr>
<tr>
<td style="text-align:left">retryPolicy</td>
<td style="text-align:center">重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口</td>
</tr>
<tr>
<td style="text-align:left">sessionTimeoutMs</td>
<td style="text-align:center">会话超时时间，单位毫秒，默认60000ms</td>
</tr>
<tr>
<td style="text-align:left">connectionTimeoutMs</td>
<td style="text-align:center">连接创建超时时间，单位毫秒，默认60000ms</td>
</tr>
</tbody>
</table>
<h3 id="2-使用Fluent风格的Api创建会话">2.使用Fluent风格的Api创建会话</h3>
<p>核心参数变为流式设置，一个列子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework client =</span><br><span class="line">CuratorFrameworkFactory.builder()</span><br><span class="line">		.connectString(connectionInfo)</span><br><span class="line">		.sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">		.connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">		.retryPolicy(retryPolicy)</span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure>
<h3 id="3-创建包含隔离命名空间的会话">3.创建包含隔离命名空间的会话</h3>
<p>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（<strong>NameSpace</strong>），即指定一个Zookeeper的根路径（官方术语：<em><strong>为Zookeeper添加“Chroot”特性</strong></em>）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">		CuratorFramework client =</span><br><span class="line">		CuratorFrameworkFactory.builder()</span><br><span class="line">				.connectString(connectionInfo)</span><br><span class="line">				.sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">				.connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">				.retryPolicy(retryPolicy)</span><br><span class="line">				.namespace(<span class="string">"base"</span>)</span><br><span class="line">				.build();</span><br></pre></td></tr></table></figure>
<h2 id="启动客户端">启动客户端</h2>
<p>当创建会话成功，得到client的实例然后可以直接调用其start( )方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure>
<h2 id="数据节点操作">数据节点操作</h2>
<h3 id="创建数据节点">创建数据节点</h3>
<p><strong>Zookeeper的节点创建模式</strong>：</p>
<ul>
<li>PERSISTENT：持久化</li>
<li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li>
<li>EPHEMERAL：临时</li>
<li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li>
</ul>
<p><strong>创建一个节点，初始内容为空</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：如果没有设置节点属性，节点创建模式默认为持久化节点，内容默认为空</p>
<p><strong>创建一个节点，附带初始化内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(&quot;path&quot;,&quot;init&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p><strong>创建一个节点，指定创建模式（临时节点），内容为空</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;,&quot;init&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.create()</span><br><span class="line">      .creatingParentContainersIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .forPath(<span class="string">"path"</span>,<span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>这个creatingParentContainersIfNeeded()接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出NoNodeException，使用creatingParentContainersIfNeeded()之后Curator能够自动递归创建所有所需的父节点。</p>
<h3 id="删除数据节点">删除数据节点</h3>
<p><strong>删除一个节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意，此方法只能删除<strong>叶子节点</strong>，否则会抛出异常。</p>
<p><strong>删除一个节点，并且递归删除其所有的子节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().deletingChildrenIfNeeded().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>删除一个节点，强制指定版本进行删除</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().withVersion(10086).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>删除一个节点，强制保证删除</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>guaranteed()接口是一个保障措施，只要客户端会话有效，那么Curator会在后台持续进行删除操作，直到删除节点成功。</p>
<p>**注意：**上面的多个流式接口是可以自由组合的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().deletingChildrenIfNeeded().withVersion(10086).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="读取数据节点数据">读取数据节点数据</h3>
<p><strong>读取一个节点的数据内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getData().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意，此方法返的返回值是byte[ ];</p>
<p><strong>读取一个节点的数据内容，同时获取到该节点的stat</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stat stat &#x3D; new Stat();</span><br><span class="line">client.getData().storingStatIn(stat).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="更新数据节点数据">更新数据节点数据</h3>
<p><strong>更新一个节点的数据内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.setData().forPath(&quot;path&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p>注意：该接口会返回一个Stat实例</p>
<p><strong>更新一个节点的数据内容，强制指定版本进行更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.setData().withVersion(10086).forPath(&quot;path&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="检查节点是否存在">检查节点是否存在</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.checkExists().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：该方法返回一个Stat实例，用于检查ZNode是否存在的操作. 可以调用额外的方法(监控或者后台处理)并在最后调用<code>forPath()</code>指定要操作的ZNode</p>
<h3 id="获取某个节点的所有子节点路径">获取某个节点的所有子节点路径</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getChildren().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：该方法的返回值为List<String>,获得ZNode的子节点Path列表。 可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的父ZNode</p>
<h3 id="事务">事务</h3>
<p>CuratorFramework的实例包含inTransaction( )接口方法，调用此方法开启一个ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交。一个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client.inTransaction().check().forPath(<span class="string">"path"</span>)</span><br><span class="line">      .and()</span><br><span class="line">      .create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes())</span><br><span class="line">      .and()</span><br><span class="line">      .setData().withVersion(<span class="number">10086</span>).forPath(<span class="string">"path"</span>,<span class="string">"data2"</span>.getBytes())</span><br><span class="line">      .and()</span><br><span class="line">      .commit();</span><br></pre></td></tr></table></figure>
<h3 id="异步接口">异步接口</h3>
<p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator提供异步接口，引入了<strong>BackgroundCallback</strong>接口用于处理异步接口调用之后服务端返回的结果信息。<strong>BackgroundCallback</strong>接口中一个重要的回调值为CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p>
<p><strong>CuratorEventType</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">事件类型</th>
<th style="text-align:center">对应CuratorFramework实例的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:center">#create()</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">#delete()</td>
</tr>
<tr>
<td style="text-align:center">EXISTS</td>
<td style="text-align:center">#checkExists()</td>
</tr>
<tr>
<td style="text-align:center">GET_DATA</td>
<td style="text-align:center">#getData()</td>
</tr>
<tr>
<td style="text-align:center">SET_DATA</td>
<td style="text-align:center">#setData()</td>
</tr>
<tr>
<td style="text-align:center">CHILDREN</td>
<td style="text-align:center">#getChildren()</td>
</tr>
<tr>
<td style="text-align:center">SYNC</td>
<td style="text-align:center">#sync(String,Object)</td>
</tr>
<tr>
<td style="text-align:center">GET_ACL</td>
<td style="text-align:center">#getACL()</td>
</tr>
<tr>
<td style="text-align:center">SET_ACL</td>
<td style="text-align:center">#setACL()</td>
</tr>
<tr>
<td style="text-align:center">WATCHED</td>
<td style="text-align:center">#Watcher(Watcher)</td>
</tr>
<tr>
<td style="text-align:center">CLOSING</td>
<td style="text-align:center">#close()</td>
</tr>
</tbody>
</table>
<p><strong>响应码(#getResultCode())</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">响应码</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">OK，即调用成功</td>
</tr>
<tr>
<td style="text-align:center">-4</td>
<td style="text-align:center">ConnectionLoss，即客户端与服务端断开连接</td>
</tr>
<tr>
<td style="text-align:center">-110</td>
<td style="text-align:center">NodeExists，即节点已经存在</td>
</tr>
<tr>
<td style="text-align:center">-112</td>
<td style="text-align:center">SessionExpired，即会话过期</td>
</tr>
</tbody>
</table>
<p>一个异步创建节点的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">client.create()</span><br><span class="line">      .creatingParentsIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .inBackground((curatorFramework, curatorEvent) -&gt; &#123;      System.out.println(String.format(<span class="string">"eventType:%s,resultCode:%s"</span>,curatorEvent.getType(),curatorEvent.getResultCode()));</span><br><span class="line">      &#125;,executor)</span><br><span class="line">      .forPath(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<p>注意：如果#inBackground()方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</p>
<h2 id="Curator食谱-高级特性">Curator食谱(高级特性)</h2>
<p><strong>提醒：首先你必须添加curator-recipes依赖，下文仅仅对recipes一些特性的使用进行解释和举例，不打算进行源码级别的探讨</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>重要提醒：强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，curator-recipes下的所有Api将会失效或者过期，尽管后面所有的例子都没有使用到ConnectionStateListener。</strong></p>
<h3 id="缓存">缓存</h3>
<p>Zookeeper原生支持通过注册Watcher来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。Cache是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator提供了三种Watcher(Cache)来监听结点的变化。</p>
<h4 id="Path-Cache">Path Cache</h4>
<p>Path Cache用来监控一个ZNode的子节点. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过PathChildrenCacheListener通知。</p>
<p>实际使用时会涉及到四个类：</p>
<ul>
<li>PathChildrenCache</li>
<li>PathChildrenCacheEvent</li>
<li>PathChildrenCacheListener</li>
<li>ChildData</li>
</ul>
<p>通过下面的构造函数创建Path Cache:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span></span><br></pre></td></tr></table></figure>
<p>想使用cache，必须调用它的<code>start</code>方法，使用完后调用<code>close</code>方法。 可以设置StartMode来实现启动的模式，</p>
<p>StartMode有下面几种：</p>
<ol>
<li>NORMAL：正常初始化。</li>
<li>BUILD_INITIAL_CACHE：在调用<code>start()</code>之前会调用<code>rebuild()</code>。</li>
<li>POST_INITIALIZED_EVENT： 当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件</li>
</ol>
<p><code>public void addListener(PathChildrenCacheListener listener)</code>可以增加listener监听缓存的变化。</p>
<p><code>getCurrentData()</code>方法返回一个<code>List&lt;ChildData&gt;</code>对象，可以遍历所有的子节点。</p>
<p><strong>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/pathCache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		client.start();</span><br><span class="line">		PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(client, PATH, <span class="keyword">true</span>);</span><br><span class="line">		cache.start();</span><br><span class="line">		PathChildrenCacheListener cacheListener = (client1, event) -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">"事件类型："</span> + event.getType());</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != event.getData()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"节点数据："</span> + event.getData().getPath() + <span class="string">" = "</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		cache.getListenable().addListener(cacheListener);</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(<span class="string">"/example/pathCache/test01"</span>, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(<span class="string">"/example/pathCache/test02"</span>, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		client.setData().forPath(<span class="string">"/example/pathCache/test01"</span>, <span class="string">"01_V2"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (ChildData data : cache.getCurrentData()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"getCurrentData:"</span> + data.getPath() + <span class="string">" = "</span> + <span class="keyword">new</span> String(data.getData()));</span><br><span class="line">		&#125;</span><br><span class="line">		client.delete().forPath(<span class="string">"/example/pathCache/test01"</span>);</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		client.delete().forPath(<span class="string">"/example/pathCache/test02"</span>);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		client.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**如果new PathChildrenCache(client, PATH, true)中的参数cacheData值设置为false，则示例中的event.getData().getData()、data.getData()将返回null，cache将不会缓存节点数据。</p>
<p>**注意：**示例中的Thread.sleep(10)可以注释掉，但是注释后事件监听的触发次数会不全，这可能与PathCache的实现原理有关，不能太过频繁的触发事件！</p>
<h4 id="Node-Cache">Node Cache</h4>
<p>Node Cache与Path Cache类似，Node Cache只是监听某一个特定的节点。它涉及到下面的三个类：</p>
<ul>
<li><code>NodeCache</code> - Node Cache实现类</li>
<li><code>NodeCacheListener</code> - 节点监听器</li>
<li><code>ChildData</code> - 节点数据</li>
</ul>
<p>**注意：**使用cache，依然要调用它的<code>start()</code>方法，使用完后调用<code>close()</code>方法。</p>
<p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/cache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		client.start();</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(PATH);</span><br><span class="line">		<span class="keyword">final</span> NodeCache cache = <span class="keyword">new</span> NodeCache(client, PATH);</span><br><span class="line">		NodeCacheListener listener = () -&gt; &#123;</span><br><span class="line">			ChildData data = cache.getCurrentData();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != data) &#123;</span><br><span class="line">				System.out.println(<span class="string">"节点数据："</span> + <span class="keyword">new</span> String(cache.getCurrentData().getData()));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"节点被删除!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">		cache.start();</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.delete().deletingChildrenIfNeeded().forPath(PATH);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		client.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**示例中的Thread.sleep(10)可以注释，但是注释后事件监听的触发次数会不全，这可能与NodeCache的实现原理有关，不能太过频繁的触发事件！</p>
<p>**注意：**NodeCache只能监听一个节点的状态变化。</p>
<h4 id="Tree-Cache">Tree Cache</h4>
<p>Tree Cache可以监控整个树上的所有节点，类似于PathCache和NodeCache的组合，主要涉及到下面四个类：</p>
<ul>
<li>TreeCache - Tree Cache实现类</li>
<li>TreeCacheListener - 监听器类</li>
<li>TreeCacheEvent - 触发的事件类</li>
<li>ChildData - 节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/cache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		client.start();</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(PATH);</span><br><span class="line">		TreeCache cache = <span class="keyword">new</span> TreeCache(client, PATH);</span><br><span class="line">		TreeCacheListener listener = (client1, event) -&gt;</span><br><span class="line">				System.out.println(<span class="string">"事件类型："</span> + event.getType() +</span><br><span class="line">						<span class="string">" | 路径："</span> + (<span class="keyword">null</span> != event.getData() ? event.getData().getPath() : <span class="keyword">null</span>));</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">		cache.start();</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.delete().deletingChildrenIfNeeded().forPath(PATH);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		client.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**在此示例中没有使用Thread.sleep(10)，但是事件触发次数也是正常的。</p>
<p>**注意：**TreeCache在初始化(调用<code>start()</code>方法)的时候会回调<code>TreeCacheListener</code>实例一个事TreeCacheEvent，而回调的TreeCacheEvent对象的Type为INITIALIZED，ChildData为null，此时<code>event.getData().getPath()</code>很有可能导致空指针异常，这里应该主动处理并避免这种情况。</p>
<h3 id="Leader选举">Leader选举</h3>
<p>在分布式计算中， <strong>leader elections</strong>是很重要的一个功能， 这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是leader(领导者)或者coordinator(协调者). 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务leader. 除此之外， 选举还经常会发生在leader意外宕机的情况下，新的leader要被选举出来。</p>
<p>在zookeeper集群中，leader负责写操作，然后通过Zab协议实现follower的同步，leader或者follower都可以处理读操作。</p>
<p>Curator 有两种leader选举的recipe,分别是<strong>LeaderSelector</strong>和<strong>LeaderLatch</strong>。</p>
<p>前者是所有存活的客户端不间断的轮流做Leader，大同社会。后者是一旦选举出Leader，除非有客户端挂掉重新触发选举，否则不会交出领导权。某党?</p>
<h4 id="LeaderLatch">LeaderLatch</h4>
<p>LeaderLatch有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath,  String id)</span></span></span><br></pre></td></tr></table></figure>
<p>LeaderLatch的启动：</p>
<p><strong>leaderLatch.start( );</strong></p>
<p>一旦启动，LeaderLatch会和其它使用相同latch path的其它LeaderLatch交涉，然后其中一个最终会被选举为leader，可以通过<code>hasLeadership</code>方法查看LeaderLatch实例是否leader：</p>
<p><strong>leaderLatch.hasLeadership( );</strong>     //返回true说明当前实例是leader</p>
<p>类似JDK的CountDownLatch， LeaderLatch在请求成为leadership会block(阻塞)，一旦不使用LeaderLatch了，必须调用<code>close</code>方法。 如果它是leader,会释放leadership， 其它的参与者将会选举一个leader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,EOFException</span></span><br><span class="line"><span class="function"><span class="comment">/*Causes the current thread to wait until this instance acquires leadership</span></span></span><br><span class="line"><span class="function"><span class="comment">unless the thread is interrupted or closed.*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p><strong>异常处理：</strong> LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader。当LOST后连接重连后RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个。LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p>
<p>一个LeaderLatch的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderLatchDemo</span> <span class="keyword">extends</span> <span class="title">BaseConnectionInfo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> String PATH = <span class="string">"/francis/leader"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">		List&lt;LeaderLatch&gt; examples = Lists.newArrayList();</span><br><span class="line">		TestingServer server=<span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; i++) &#123;</span><br><span class="line">				CuratorFramework client</span><br><span class="line">						= CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">20000</span>, <span class="number">3</span>));</span><br><span class="line">				clients.add(client);</span><br><span class="line">				LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line">				latch.addListener(<span class="keyword">new</span> LeaderLatchListener() &#123;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						System.out.println(<span class="string">"I am Leader"</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						System.out.println(<span class="string">"I am not Leader"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				examples.add(latch);</span><br><span class="line">				client.start();</span><br><span class="line">				latch.start();</span><br><span class="line">			&#125;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			LeaderLatch currentLeader = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">				<span class="keyword">if</span> (latch.hasLeadership()) &#123;</span><br><span class="line">					currentLeader = latch;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">			System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">			currentLeader.close();</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">				<span class="keyword">if</span> (latch.hasLeadership()) &#123;</span><br><span class="line">					currentLeader = latch;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">			System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> != latch.getState())</span><br><span class="line">				CloseableUtils.closeQuietly(latch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(client);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以添加test module的依赖方便进行测试，不需要启动真实的zookeeper服务端：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先我们创建了10个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>
通过<code>hasLeadership</code>查看自己是否是leader， 如果是的话返回true。<br>
可以通过<code>.getLeader().getId()</code>可以得到当前的leader的ID。<br>
只能通过<code>close</code>释放当前的领导权。<br>
<code>await</code>是一个阻塞方法， 尝试获取leader地位，但是未必能上位。</p>
<h4 id="LeaderSelector">LeaderSelector</h4>
<p>LeaderSelector使用的时候主要涉及下面几个类：</p>
<ul>
<li>LeaderSelector</li>
<li>LeaderSelectorListener</li>
<li>LeaderSelectorListenerAdapter</li>
<li>CancelLeadershipException</li>
</ul>
<p>核心类是LeaderSelector，它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></span></span><br></pre></td></tr></table></figure>
<p>类似LeaderLatch,LeaderSelector必须<code>start</code>: <code>leaderSelector.start();</code> 一旦启动，当实例取得领导权时你的listener的<code>takeLeadership()</code>方法被调用。而takeLeadership()方法只有领导权被释放时才返回。 当你不再使用LeaderSelector实例时，应该调用它的close方法。</p>
<p><strong>异常处理</strong> LeaderSelectorListener类继承ConnectionStateListener。LeaderSelector必须小心连接状态的改变。如果实例成为leader, 它应该响应SUSPENDED 或 LOST。 当 SUSPENDED 状态出现时， 实例必须假定在重新连接成功之前它可能不再是leader了。 如果LOST状态出现， 实例不再是leader， takeLeadership方法返回。</p>
<p><strong>重要</strong>: 推荐处理方式是当收到SUSPENDED 或 LOST时抛出CancelLeadershipException异常.。这会导致LeaderSelector实例中断并取消执行takeLeadership方法的异常.。这非常重要， 你必须考虑扩展LeaderSelectorListenerAdapter. LeaderSelectorListenerAdapter提供了推荐的处理逻辑。</p>
<p>下面的一个例子摘抄自官方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorAdapter</span> <span class="keyword">extends</span> <span class="title">LeaderSelectorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger leaderCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LeaderSelectorAdapter</span><span class="params">(CuratorFramework client, String path, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		leaderSelector = <span class="keyword">new</span> LeaderSelector(client, path, <span class="keyword">this</span>);</span><br><span class="line">		leaderSelector.autoRequeue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		leaderSelector.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		leaderSelector.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> waitSeconds = (<span class="keyword">int</span>) (<span class="number">5</span> * Math.random()) + <span class="number">1</span>;</span><br><span class="line">		System.out.println(name + <span class="string">" is now the leader. Waiting "</span> + waitSeconds + <span class="string">" seconds..."</span>);</span><br><span class="line">		System.out.println(name + <span class="string">" has been leader "</span> + leaderCount.getAndIncrement() + <span class="string">" time(s) before."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.err.println(name + <span class="string">" was interrupted."</span>);</span><br><span class="line">			Thread.currentThread().interrupt();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(name + <span class="string">" relinquishing leadership.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在takeLeadership进行任务的分配等等，并且不要返回，如果你想要要此实例一直是leader的话可以加一个死循环。调用 <code>leaderSelector.autoRequeue();</code>保证在此实例释放领导权之后还可能获得领导权。 在这里我们使用AtomicInteger来记录此client获得领导权的次数， 它是”fair”， 每个client有平等的机会获得领导权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> String PATH = <span class="string">"/francis/leader"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">		List&lt;LeaderSelectorAdapter&gt; examples = Lists.newArrayList();</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; i++) &#123;</span><br><span class="line">				CuratorFramework client</span><br><span class="line">						= CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">20000</span>, <span class="number">3</span>));</span><br><span class="line">				clients.add(client);</span><br><span class="line">				LeaderSelectorAdapter selectorAdapter = <span class="keyword">new</span> LeaderSelectorAdapter(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line">				examples.add(selectorAdapter);</span><br><span class="line">				client.start();</span><br><span class="line">				selectorAdapter.start();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</span><br><span class="line">			<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Shutting down..."</span>);</span><br><span class="line">			<span class="keyword">for</span> (LeaderSelectorAdapter exampleClient : examples) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(exampleClient);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(client);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比可知，LeaderLatch必须调用<code>close()</code>方法才会释放领导权，而对于LeaderSelector，通过<code>LeaderSelectorListener</code>可以对领导权进行控制， 在适当的时候释放领导权，这样每个节点都有可能获得领导权。从而，LeaderSelector具有更好的灵活性和可控性，建议有LeaderElection应用场景下优先使用LeaderSelector。</p>
<h3 id="分布式锁">分布式锁</h3>
<p><strong>提醒：</strong></p>
<p>1.推荐使用ConnectionStateListener监控连接的状态，因为当连接LOST时你不再拥有锁</p>
<p>2.分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p>
<h4 id="可重入共享锁—Shared-Reentrant-Lock">可重入共享锁—Shared Reentrant Lock</h4>
<p><strong>Shared意味着锁是全局可见的</strong>， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似，即可重入， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。 它是由类<code>InterProcessMutex</code>来实现。 它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span></span><br></pre></td></tr></table></figure>
<p>通过<code>acquire()</code>获得锁，并提供超时机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Acquire the mutex - blocking until it's available. Note: the same thread can call acquire</span></span><br><span class="line"><span class="function">re-entrantly. Each call to acquire must be balanced by a call to <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span></span><br><span class="line"><span class="function">Acquire the mutex - blocks until it's available or the given time expires. Note: the same thread can call acquire re-entrantly. Each call to acquire that returns <span class="keyword">true</span> must be balanced by a call to <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">time - time to wait</span></span><br><span class="line"><span class="function">unit - time unit</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function"><span class="keyword">true</span> <span class="keyword">if</span> the mutex was acquired, <span class="keyword">false</span> <span class="keyword">if</span> not</span></span><br></pre></td></tr></table></figure>
<p>通过<code>release()</code>方法释放锁。 InterProcessMutex 实例可以重用。</p>
<p><strong>Revoking</strong> ZooKeeper recipes wiki定义了可协商的撤销机制。 为了撤销mutex, 调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRevocable</span><span class="params">(RevocationListener&lt;T&gt; listener)</span></span></span><br><span class="line"><span class="function">将锁设为可撤销的. 当别的进程或线程想让你释放锁时Listener会被调用。</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">listener - the listener</span></span><br></pre></td></tr></table></figure>
<p>如果你请求撤销当前的锁， 调用<code>attemptRevoke()</code>方法,注意锁释放时<code>RevocationListener</code>将会回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRevoke</span><span class="params">(CuratorFramework client,String path)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Utility to mark a lock <span class="keyword">for</span> revocation. Assuming that the lock has been registered</span></span><br><span class="line"><span class="function">with a RevocationListener, it will get called and the lock should be released. Note,</span></span><br><span class="line"><span class="function">however, that revocation is cooperative.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">path - the path of the lock - usually from something like InterProcessMutex.<span class="title">getParticipantNodes</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>二次提醒：错误处理</strong> 还是强烈推荐你使用<code>ConnectionStateListener</code>处理连接状态的改变。 当连接LOST时你不再拥有锁。</p>
<p>首先让我们创建一个模拟的共享资源， 这个资源期望只能单线程的访问，否则会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeLimitedResource</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean inUse = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// 真实环境中我们会在这里访问/维护一个共享的资源</span></span><br><span class="line">		<span class="comment">//这个例子在使用锁的情况下不会非法并发异常IllegalStateException</span></span><br><span class="line">		<span class="comment">//但是在无锁的情况由于sleep了一段时间，很容易抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (!inUse.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Needs to be used by one client at a time"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			inUse.set(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个<code>InterProcessMutexDemo</code>类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutexDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutexDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		<span class="keyword">this</span>.lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" get the lock"</span>);</span><br><span class="line">			resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">			lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> InterProcessMutexDemo example = <span class="keyword">new</span> InterProcessMutexDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也很简单，生成10个client， 每个client重复执行10次 请求锁–访问资源–释放锁的过程。每个client都在独立的线程中。 结果可以看到，锁是随机的被每个实例排他性的使用。</p>
<p>既然是可重用的，你可以在一个线程中多次调用<code>acquire()</code>,在线程拥有锁时它总是返回true。</p>
<p><strong>你不应该在多个线程中用同一个<code>InterProcessMutex</code></strong>， 你可以在每个线程中都生成一个新的InterProcessMutex实例，它们的path都一样，这样它们可以共享同一个锁。</p>
<h4 id="不可重入共享锁—Shared-Lock">不可重入共享锁—Shared Lock</h4>
<p>这个锁和上面的<code>InterProcessMutex</code>相比，就是少了Reentrant的功能，也就意味着它不能在同一个线程中重入。这个类是<code>InterProcessSemaphoreMutex</code>,使用方法和<code>InterProcessMutex</code>类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreMutexDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> InterProcessSemaphoreMutex lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InterProcessSemaphoreMutexDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		<span class="keyword">this</span>.lock = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, lockPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到互斥锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 已获取到互斥锁"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到互斥锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 再次获取到互斥锁"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" get the lock"</span>);</span><br><span class="line">			resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">			lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">			lock.release(); <span class="comment">// 获取锁几次 释放锁也要几次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> InterProcessSemaphoreMutexDemo example = <span class="keyword">new</span> InterProcessSemaphoreMutexDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后发现，有且只有一个client成功获取第一个锁(第一个<code>acquire()</code>方法返回true)，然后它自己阻塞在第二个<code>acquire()</code>方法，获取第二个锁超时；其他所有的客户端都阻塞在第一个<code>acquire()</code>方法超时并且抛出异常。</p>
<p>这样也就验证了<code>InterProcessSemaphoreMutex</code>实现的锁是不可重入的。</p>
<h4 id="可重入读写锁—Shared-Reentrant-Read-Write-Lock">可重入读写锁—Shared Reentrant Read Write Lock</h4>
<p>类似JDK的<strong>ReentrantReadWriteLock</strong>。一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁在使用时不允许读(阻塞)。</p>
<p>此锁是可重入的。<strong>一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁</strong>。这也意味着<strong>写锁可以降级成读锁， 比如请求写锁 —&gt;请求读锁—&gt;释放读锁 ----&gt;释放写锁</strong>。从读锁升级成写锁是不行的。</p>
<p>可重入读写锁主要由两个类实现：<code>InterProcessReadWriteLock</code>、<code>InterProcessMutex</code>。使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁，读写锁的类型是<code>InterProcessMutex</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessReadWriteLock lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex readLock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex writeLock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLockDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, lockPath);</span><br><span class="line">		readLock = lock.readLock();</span><br><span class="line">		writeLock = lock.writeLock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 注意只能先得到写锁再得到读锁，不能反过来！！！</span></span><br><span class="line">		<span class="keyword">if</span> (!writeLock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到写锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 已得到写锁"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!readLock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到读锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 已得到读锁"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			resource.use(); <span class="comment">// 使用资源</span></span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" 释放读写锁"</span>);</span><br><span class="line">			readLock.release();</span><br><span class="line">			writeLock.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> ReentrantReadWriteLockDemo example = <span class="keyword">new</span> ReentrantReadWriteLockDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量—Shared-Semaphore">信号量—Shared Semaphore</h4>
<p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(<strong>permits</strong>)，而Curator中称之为租约(<strong>Lease</strong>)。 有两种方式可以决定semaphore的最大租约数。第一种方式是用户给定path并且指定最大LeaseSize。第二种方式用户给定path并且使用<code>SharedCountReader</code>类。<strong>如果不使用SharedCountReader, 必须保证所有实例在多进程中使用相同的(最大)租约数量,否则有可能出现A进程中的实例持有最大租约数量为10，但是在B进程中持有的最大租约数量为20，此时租约的意义就失效了。</strong></p>
<p>这次调用<code>acquire()</code>会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。 租约还可以通过下面的方式返还：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLease</span><span class="params">(Lease lease)</span></span></span><br></pre></td></tr></table></figure>
<p>注意你可以一次性请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty, <span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>Shared Semaphore使用的主要类包括下面几个：</p>
<ul>
<li><code>InterProcessSemaphoreV2</code></li>
<li><code>Lease</code></li>
<li><code>SharedCountReader</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEASE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line"></span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line"></span><br><span class="line">			InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(client, PATH, MAX_LEASE);</span><br><span class="line">			Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="number">5</span>);</span><br><span class="line">			System.out.println(<span class="string">"get "</span> + leases.size() + <span class="string">" leases"</span>);</span><br><span class="line">			Lease lease = semaphore.acquire();</span><br><span class="line">			System.out.println(<span class="string">"get another lease"</span>);</span><br><span class="line"></span><br><span class="line">			resource.use();</span><br><span class="line"></span><br><span class="line">			Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">			System.out.println(<span class="string">"Should timeout and acquire return "</span> + leases2);</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"return one lease"</span>);</span><br><span class="line">			semaphore.returnLease(lease);</span><br><span class="line">			System.out.println(<span class="string">"return another 5 leases"</span>);</span><br><span class="line">			semaphore.returnAll(leases);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先获得了5个租约， 最后我们把它还给了semaphore。 接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。 然后再请求一个租约，因为租约不够，<strong>阻塞到超时，还是没能满足，返回结果为null(租约不足会阻塞到超时，然后返回null，不会主动抛出异常；如果不设置超时时间，会一致阻塞)。</strong></p>
<p>上面说讲的锁都是公平锁(fair)。 总ZooKeeper的角度看， 每个客户端都按照请求的顺序获得锁，不存在非公平的抢占的情况。</p>
<h4 id="多共享锁对象-—Multi-Shared-Lock">多共享锁对象 —Multi Shared Lock</h4>
<p>Multi Shared Lock是一个锁的容器。 当调用<code>acquire()</code>， 所有的锁都会被<code>acquire()</code>，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(<strong>失败被忽略</strong>)。 基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p>
<p>主要涉及两个类：</p>
<ul>
<li><code>InterProcessMultiLock</code></li>
<li><code>InterProcessLock</code></li>
</ul>
<p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span></span></span><br></pre></td></tr></table></figure>
<p>用法和Shared Lock相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiSharedLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH1 = <span class="string">"/examples/locks1"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH2 = <span class="string">"/examples/locks2"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line"></span><br><span class="line">			InterProcessLock lock1 = <span class="keyword">new</span> InterProcessMutex(client, PATH1);</span><br><span class="line">			InterProcessLock lock2 = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, PATH2);</span><br><span class="line"></span><br><span class="line">			InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(Arrays.asList(lock1, lock2));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"could not acquire the lock"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"has got all lock"</span>);</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"has got lock1: "</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">			System.out.println(<span class="string">"has got lock2: "</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"releasing the lock"</span>);</span><br><span class="line">				lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"has got lock1: "</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">			System.out.println(<span class="string">"has got lock2: "</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个<code>InterProcessMultiLock</code>， 包含一个重入锁和一个非重入锁。 调用<code>acquire()</code>后可以看到线程同时拥有了这两个锁。 调用<code>release()</code>看到这两个锁都被释放了。</p>
<p><strong>最后再重申一次， 强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，锁将会丢失。</strong></p>
<h3 id="分布式计数器">分布式计数器</h3>
<p>顾名思义，计数器是用来计数的, 利用ZooKeeper可以实现一个集群共享的计数器。 只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数(<code>SharedCount</code>)，一个用long来计数(<code>DistributedAtomicLong</code>)。</p>
<h4 id="分布式int计数器—SharedCount">分布式int计数器—SharedCount</h4>
<p>这个类使用int类型来计数。 主要涉及三个类。</p>
<ul>
<li>SharedCount</li>
<li>SharedCountReader</li>
<li>SharedCountListener</li>
</ul>
<p><code>SharedCount</code>代表计数器， 可以为它增加一个<code>SharedCountListener</code>，当计数器改变时此Listener可以监听到改变的事件，而<code>SharedCountReader</code>可以读取到最新的值， 包括字面值和带版本信息的值VersionedValue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedCounterDemo</span> <span class="keyword">implements</span> <span class="title">SharedCountListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/counter"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">		SharedCounterDemo example = <span class="keyword">new</span> SharedCounterDemo();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line"></span><br><span class="line">			SharedCount baseCount = <span class="keyword">new</span> SharedCount(client, PATH, <span class="number">0</span>);</span><br><span class="line">			baseCount.addListener(example);</span><br><span class="line">			baseCount.start();</span><br><span class="line"></span><br><span class="line">			List&lt;SharedCount&gt; examples = Lists.newArrayList();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> SharedCount count = <span class="keyword">new</span> SharedCount(client, PATH, <span class="number">0</span>);</span><br><span class="line">				examples.add(count);</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">					count.start();</span><br><span class="line">					Thread.sleep(rand.nextInt(<span class="number">10000</span>));</span><br><span class="line">					System.out.println(<span class="string">"Increment:"</span> + count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(<span class="number">10</span>)));</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				examples.get(i).close();</span><br><span class="line">			&#125;</span><br><span class="line">			baseCount.close();</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework arg0, ConnectionState arg1)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"State changed: "</span> + arg1.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countHasChanged</span><span class="params">(SharedCountReader sharedCount, <span class="keyword">int</span> newCount)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Counter's value is changed to "</span> + newCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用<code>baseCount</code>来监听计数值(<code>addListener</code>方法来添加SharedCountListener )。 任意的SharedCount， 只要使用相同的path，都可以得到这个计数值。 然后我们使用5个线程为计数值增加一个10以内的随机数。相同的path的SharedCount对计数值进行更改，将会回调给<code>baseCount</code>的SharedCountListener。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(10))</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>trySetCount</code>去设置计数器。 <strong>第一个参数提供当前的VersionedValue,如果期间其它client更新了此计数值， 你的更新可能不成功， 但是这时你的client更新了最新的值，所以失败了你可以尝试再更新一次。 而<code>setCount</code>是强制更新计数器的值</strong>。</p>
<p>注意计数器必须<code>start</code>,使用完之后必须调用<code>close</code>关闭它。</p>
<p>强烈推荐使用<code>ConnectionStateListener</code>。 在本例中<code>SharedCountListener</code>扩展<code>ConnectionStateListener</code>。</p>
<h4 id="分布式long计数器—DistributedAtomicLong">分布式long计数器—DistributedAtomicLong</h4>
<p>再看一个Long类型的计数器。 除了计数的范围比<code>SharedCount</code>大了之外， 它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用<code>InterProcessMutex</code>方式来更新计数值。</p>
<p>可以从它的内部实现<code>DistributedAtomicValue.trySet()</code>中看出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AtomicValue&lt;<span class="keyword">byte</span>[]&gt;   trySet(MakeValue makeValue) <span class="keyword">throws</span> Exception</span><br><span class="line"> &#123;</span><br><span class="line">     MutableAtomicValue&lt;<span class="keyword">byte</span>[]&gt;  result = <span class="keyword">new</span> MutableAtomicValue&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">     tryOptimistic(result, makeValue);</span><br><span class="line">     <span class="keyword">if</span> ( !result.succeeded() &amp;&amp; (mutex != <span class="keyword">null</span>) )</span><br><span class="line">     &#123;</span><br><span class="line">         tryWithMutex(result, makeValue);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>此计数器有一系列的操作：</p>
<ul>
<li>get(): 获取当前值</li>
<li>increment()： 加一</li>
<li>decrement(): 减一</li>
<li>add()： 增加特定的值</li>
<li>subtract(): 减去特定的值</li>
<li>trySet(): 尝试设置计数值</li>
<li>forceSet(): 强制设置计数值</li>
</ul>
<p>你<strong>必须</strong>检查返回结果的<code>succeeded()</code>， 它代表此操作是否成功。 如果操作成功， <code>preValue()</code>代表操作前的值， <code>postValue()</code>代表操作后的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedAtomicLongDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/counter"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">		List&lt;DistributedAtomicLong&gt; examples = Lists.newArrayList();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedAtomicLong count = <span class="keyword">new</span> DistributedAtomicLong(client, PATH, <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">				examples.add(count);</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						AtomicValue&lt;Long&gt; value = count.increment();</span><br><span class="line">						System.out.println(<span class="string">"succeed: "</span> + value.succeeded());</span><br><span class="line">						<span class="keyword">if</span> (value.succeeded())</span><br><span class="line">							System.out.println(<span class="string">"Increment: from "</span> + value.preValue() + <span class="string">" to "</span> + value.postValue());</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">			Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式队列">分布式队列</h3>
<p>使用Curator也可以简化Ephemeral Node (<strong>临时节点</strong>)的操作。Curator也提供ZK Recipe的分布式队列实现。 利用ZK的 PERSISTENTS_EQUENTIAL节点， 可以保证放入到队列中的项目是按照顺序排队的。 如果单一的消费者从队列中取数据， 那么它是先入先出的，这也是队列的特点。 如果你严格要求顺序，你就的使用单一的消费者，可以使用Leader选举只让Leader作为唯一的消费者。</p>
<p>但是， 根据Netflix的Curator作者所说， ZooKeeper真心不适合做Queue，或者说ZK没有实现一个好的Queue，详细内容可以看 <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a>， 原因有五：</p>
<ol>
<li>ZK有1MB 的传输限制。 实践中ZNode必须相对较小，而队列包含成千上万的消息，非常的大。</li>
<li>如果有很多节点，ZK启动时相当的慢。 而使用queue会导致好多ZNode. 你需要显著增大 initLimit 和 syncLimit.</li>
<li>ZNode很大的时候很难清理。Netflix不得不创建了一个专门的程序做这事。</li>
<li>当很大量的包含成千上万的子节点的ZNode时， ZK的性能变得不好</li>
<li>ZK的数据库完全放在内存中。 大量的Queue意味着会占用很多的内存空间。</li>
</ol>
<p>尽管如此， Curator还是创建了各种Queue的实现。 如果Queue的数据量不太多，数据量不太大的情况下，酌情考虑，还是可以使用的。</p>
<h4 id="分布式队列—DistributedQueue">分布式队列—DistributedQueue</h4>
<p>DistributedQueue是最普通的一种队列。 它设计以下四个类：</p>
<ul>
<li>QueueBuilder - 创建队列使用QueueBuilder,它也是其它队列的创建类</li>
<li>QueueConsumer - 队列中的消息消费者接口</li>
<li>QueueSerializer - 队列消息序列化和反序列化接口，提供了对队列中的对象的序列化和反序列化</li>
<li>DistributedQueue - 队列实现类</li>
</ul>
<p>QueueConsumer是消费者，它可以接收队列的数据。处理队列中的数据的代码逻辑可以放在QueueConsumer.consumeMessage()中。</p>
<p>正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。可以调用Builder的lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework clientA = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		clientA.start();</span><br><span class="line">		CuratorFramework clientB = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		clientB.start();</span><br><span class="line">		DistributedQueue&lt;String&gt; queueA;</span><br><span class="line">		QueueBuilder&lt;String&gt; builderA = QueueBuilder.builder(clientA, createQueueConsumer(<span class="string">"A"</span>), createQueueSerializer(), PATH);</span><br><span class="line">		queueA = builderA.buildQueue();</span><br><span class="line">		queueA.start();</span><br><span class="line"></span><br><span class="line">		DistributedQueue&lt;String&gt; queueB;</span><br><span class="line">		QueueBuilder&lt;String&gt; builderB = QueueBuilder.builder(clientB, createQueueConsumer(<span class="string">"B"</span>), createQueueSerializer(), PATH);</span><br><span class="line">		queueB = builderB.buildQueue();</span><br><span class="line">		queueB.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			queueA.put(<span class="string">" test-A-"</span> + i);</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">			queueB.put(<span class="string">" test-B-"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);<span class="comment">// 等待消息消费完成</span></span><br><span class="line">		queueB.close();</span><br><span class="line">		queueA.close();</span><br><span class="line">		clientB.close();</span><br><span class="line">		clientA.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 队列消息序列化实现类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义队列消费者</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"连接状态改变: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"消费消息("</span> + name + <span class="string">"): "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了两个分布式队列和两个消费者，因为PATH是相同的，会存在消费者抢占消费消息的情况。</p>
<h4 id="带Id的分布式队列—DistributedIdQueue">带Id的分布式队列—DistributedIdQueue</h4>
<p>DistributedIdQueue和上面的队列类似，<strong>但是可以为队列中的每一个元素设置一个ID</strong>。 可以通过ID把队列中任意的元素移除。 它涉及几个类：</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedQueue</li>
</ul>
<p>通过下面方法创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.buildIdQueue()</span><br></pre></td></tr></table></figure>
<p>放入元素时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.put(aMessage, messageId);</span><br></pre></td></tr></table></figure>
<p>移除元素时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int numberRemoved &#x3D; queue.remove(messageId);</span><br></pre></td></tr></table></figure>
<p>在这个例子中， 有些元素还没有被消费者消费前就移除了，这样消费者不会收到删除的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedIdQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedIdQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line"></span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildIdQueue();</span><br><span class="line">			queue.start();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				queue.put(<span class="string">" test-"</span> + i, <span class="string">"Id"</span> + i);</span><br><span class="line">				Thread.sleep((<span class="keyword">long</span>) (<span class="number">15</span> * Math.random()));</span><br><span class="line">				queue.remove(<span class="string">"Id"</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"consume one message: "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级分布式队列—DistributedPriorityQueue">优先级分布式队列—DistributedPriorityQueue</h4>
<p>优先级队列对队列中的元素按照优先级进行排序。 <strong>Priority越小， 元素越靠前， 越先被消费掉</strong>。 它涉及下面几个类：</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedPriorityQueue</li>
</ul>
<p>通过builder.buildPriorityQueue(minItemsBeforeRefresh)方法创建。 当优先级队列得到元素增删消息时，它会暂停处理当前的元素队列，然后刷新队列。minItemsBeforeRefresh指定刷新前当前活动的队列的最小数量。 主要设置你的程序可以容忍的不排序的最小值。</p>
<p>放入队列时需要指定优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.put(aMessage, priority);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedPriorityQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedPriorityQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line"></span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildPriorityQueue(<span class="number">0</span>);</span><br><span class="line">			queue.start();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> priority = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">				System.out.println(<span class="string">"test-"</span> + i + <span class="string">" priority:"</span> + priority);</span><br><span class="line">				queue.put(<span class="string">"test-"</span> + i, priority);</span><br><span class="line">				Thread.sleep((<span class="keyword">long</span>) (<span class="number">50</span> * Math.random()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"consume one message: "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候你可能会有错觉，优先级设置并没有起效。那是因为优先级是对于队列积压的元素而言，如果消费速度过快有可能出现在后一个元素入队操作之前前一个元素已经被消费，这种情况下DistributedPriorityQueue会退化为DistributedQueue。</p>
<h4 id="分布式延迟队列—DistributedDelayQueue">分布式延迟队列—DistributedDelayQueue</h4>
<p>JDK中也有DelayQueue，不知道你是否熟悉。 DistributedDelayQueue也提供了类似的功能， 元素有个delay值， 消费者隔一段时间才能收到元素。 涉及到下面四个类。</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedDelayQueue</li>
</ul>
<p>通过下面的语句创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder&lt;MessageType&gt;    builder &#x3D; QueueBuilder.builder(client, consumer, serializer, path);</span><br><span class="line">... more builder method calls as needed ...</span><br><span class="line">DistributedDelayQueue&lt;MessageType&gt; queue &#x3D; builder.buildDelayQueue();</span><br></pre></td></tr></table></figure>
<p>放入元素时可以指定<code>delayUntilEpoch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.put(aMessage, delayUntilEpoch);</span><br></pre></td></tr></table></figure>
<p>注意<code>delayUntilEpoch</code>不是离现在的一个时间间隔， 比如20毫秒，而是未来的一个时间戳，如 System.currentTimeMillis() + 10秒。 如果delayUntilEpoch的时间已经过去，消息会立刻被消费者接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedDelayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedDelayQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line"></span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildDelayQueue();</span><br><span class="line">			queue.start();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				queue.put(<span class="string">"test-"</span> + i, System.currentTimeMillis() + <span class="number">10000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> Date().getTime() + <span class="string">": already put all items"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="keyword">new</span> Date().getTime() + <span class="string">": consume one message: "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SimpleDistributedQueue">SimpleDistributedQueue</h4>
<p>前面虽然实现了各种队列，但是你注意到没有，这些队列并没有实现类似JDK一样的接口。 <code>SimpleDistributedQueue</code>提供了和JDK基本一致的接口(但是没有实现Queue接口)。 创建很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client,String path)</span></span></span><br></pre></td></tr></table></figure>
<p>增加元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(byte[] data) throws Exception</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] take() <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>
<p>另外还提供了其它方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] peek() <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] poll(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] poll() <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] remove() <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] element() <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>
<p>没有<code>add</code>方法， 多了<code>take</code>方法。</p>
<p><code>take</code>方法在成功返回之前会被阻塞。 而<code>poll</code>方法在队列为空时直接返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDistributedQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		SimpleDistributedQueue queue;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line">			client.start();</span><br><span class="line">			queue = <span class="keyword">new</span> SimpleDistributedQueue(client, PATH);</span><br><span class="line">			Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">			Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">			<span class="keyword">new</span> Thread(producer, <span class="string">"producer"</span>).start();</span><br><span class="line">			<span class="keyword">new</span> Thread(consumer, <span class="string">"consumer"</span>).start();</span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> SimpleDistributedQueue queue;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SimpleDistributedQueue queue)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.queue = queue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">boolean</span> flag = queue.offer((<span class="string">"zjc-"</span> + i).getBytes());</span><br><span class="line">					<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">						System.out.println(<span class="string">"发送一条消息成功："</span> + <span class="string">"zjc-"</span> + i);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						System.out.println(<span class="string">"发送一条消息失败："</span> + <span class="string">"zjc-"</span> + i);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> SimpleDistributedQueue queue;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SimpleDistributedQueue queue)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.queue = queue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">byte</span>[] datas = queue.take();</span><br><span class="line">				System.out.println(<span class="string">"消费一条消息成功："</span> + <span class="keyword">new</span> String(datas, <span class="string">"UTF-8"</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际上发送了100条消息，消费完第一条之后，后面的消息无法消费，目前没找到原因。查看一下官方文档推荐的demo使用下面几个Api：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Creating a SimpleDistributedQueue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String path)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">path - path to store queue nodes</span></span><br><span class="line"><span class="function">Add to the queue</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Inserts data into queue.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">data - the data</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function"><span class="keyword">true</span> <span class="keyword">if</span> data was successfully added</span></span><br><span class="line"><span class="function">Take from the queue</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Removes the head of the queue and returns it, blocks until it succeeds.</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function">The former head of the queue</span></span><br><span class="line"><span class="function">NOTE: see the Javadoc <span class="keyword">for</span> additional methods</span></span><br></pre></td></tr></table></figure>
<p>但是实际使用发现还是存在消费阻塞问题。</p>
<h3 id="分布式屏障—Barrier">分布式屏障—Barrier</h3>
<p>分布式Barrier是这样一个类： 它会阻塞所有节点上的等待进程，直到某一个被满足， 然后所有的节点继续进行。</p>
<p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p>
<h4 id="DistributedBarrier">DistributedBarrier</h4>
<p><code>DistributedBarrier</code>类实现了栅栏的功能。 它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedBarrier</span><span class="params">(CuratorFramework client, String barrierPath)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - client</span></span><br><span class="line"><span class="function">barrierPath - path to use as the barrier</span></span><br></pre></td></tr></table></figure>
<p>首先你需要设置栅栏，它将阻塞在它上面等待的线程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setBarrier();</span><br></pre></td></tr></table></figure>
<p>然后需要阻塞的线程调用方法等待放行条件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void waitOnBarrier()</span><br></pre></td></tr></table></figure>
<p>当条件满足时，移除栅栏，所有等待的线程将继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeBarrier();</span><br></pre></td></tr></table></figure>
<p><strong>异常处理</strong> DistributedBarrier 会监控连接状态，当连接断掉时<code>waitOnBarrier()</code>方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/barrier"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			DistributedBarrier controlBarrier = <span class="keyword">new</span> DistributedBarrier(client, PATH);</span><br><span class="line">			controlBarrier.setBarrier();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedBarrier barrier = <span class="keyword">new</span> DistributedBarrier(client, PATH);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">					Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" waits on Barrier"</span>);</span><br><span class="line">					barrier.waitOnBarrier();</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" begins"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			System.out.println(<span class="string">"all Barrier instances should wait the condition"</span>);</span><br><span class="line">			controlBarrier.removeBarrier();</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子创建了<code>controlBarrier</code>来设置栅栏和移除栅栏。 我们创建了5个线程，在此Barrier上等待。 最后移除栅栏后所有的线程才继续执行。</p>
<p>如果你开始不设置栅栏，所有的线程就不会阻塞住。</p>
<h4 id="双栅栏—DistributedDoubleBarrier">双栅栏—DistributedDoubleBarrier</h4>
<p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。 双栅栏类是<code>DistributedDoubleBarrier</code>。 构造函数为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String barrierPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> memberQty)</span></span></span><br><span class="line"><span class="function">Creates the barrier abstraction. memberQty is the number of members in the barrier. When <span class="title">enter</span><span class="params">()</span> is called, it blocks until</span></span><br><span class="line"><span class="function">all members have entered. When <span class="title">leave</span><span class="params">()</span> is called, it blocks until all members have left.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">barrierPath - path to use</span></span><br><span class="line"><span class="function">memberQty - the number of members in the barrier</span></span><br></pre></td></tr></table></figure>
<p><code>memberQty</code>是成员数量，当<code>enter()</code>方法被调用时，成员被阻塞，直到所有的成员都调用了<code>enter()</code>。 当<code>leave()</code>方法被调用时，它也阻塞调用线程，直到所有的成员都调用了<code>leave()</code>。 就像百米赛跑比赛， 发令枪响， 所有的运动员开始跑，等所有的运动员跑过终点线，比赛才结束。</p>
<p>DistributedDoubleBarrier会监控连接状态，当连接断掉时<code>enter()</code>和<code>leave()</code>方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedDoubleBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/barrier"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedDoubleBarrier barrier = <span class="keyword">new</span> DistributedDoubleBarrier(client, PATH, QTY);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">					Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" enters"</span>);</span><br><span class="line">					barrier.enter();</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" begins"</span>);</span><br><span class="line">					Thread.sleep((<span class="keyword">long</span>) (<span class="number">3000</span> * Math.random()));</span><br><span class="line">					barrier.leave();</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" left"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">			Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<ul>
<li>《从PAXOS到ZOOKEEPER分布式一致性原理与实践》</li>
<li>《跟着实例学习ZooKeeper的用法》博客系列</li>
</ul>
<p><strong>项目仓库：</strong></p>
<ul>
<li><a href="https://github.com/zjcscut/curator-seed" target="_blank" rel="noopener">https://github.com/zjcscut/curator-seed</a></li>
</ul>
<p>(e-a-2017-5-13 13:10 c-14-d r-a-20181216)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/Zookeeper/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Zookeeper</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/01/rabbitmq-extension-direct-reply-to/">
      RabbitMQ扩展之直接回复(Direct reply-to)
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月1日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：7分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-01T19:05:19+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文内容参考RabbitMQ官方文档<a href="https://www.rabbitmq.com/direct-reply-to.html" target="_blank" rel="noopener">Direct reply-to</a>。</p>
<h2 id="直接回复">直接回复</h2>
<p>直接回复(Direct reply-to)是一种可以避免声明回复队列并且实现类似于RPC功能的一种特性。RabbitMQ中允许使用客户端和RabbitMQ消息代理中间件实现RPC模式，典型的做法是：RPC客户端发送请求(消息)到一个持久化的已知服务端队列，RPC服务端消费该服务端队列的消息，然后使用消息属性中的<code>reply-to</code>属性对应的值作为客户端回复队列发送回复消息到RPC客户端。</p>
<p>客户端回复队列需要考虑创建问题。客户端可以为每个请求-响应声明一个一次性的队列，但是这样的做法是十分低效的，因为即使是非持久状态下的非镜像队列，其删除的代价是昂贵的，特别是在集群模式之下。另一个可选的做法是：客户端为回复创建一个持久化的长期存在的队列，这种情况下队列的管理可能变得复杂，因为客户端本身可能不是长期存在的。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/r-m-d-r/r-m-d-r-1.png" alt="r-m-d-r-1.png"></p>
<p>实际上，RabbitMQ提供了一个功能，允许RPC客户端直接从其RPC服务端接收回复，并且无需创建回复队列，依赖于RabbitMQ的消息中间件的功能，具体做法是：</p>
<p><strong>对于RPC客户端：</strong></p>
<ul>
<li>RPC客户端创建消费者的时候队列指定为伪队列<code>amq.rabbitmq.reply-to</code>，使用非手动ack模式(autoAck=true)进行消费，伪队列<code>amq.rabbitmq.reply-to</code>不需要显式声明，当然如果需要的话也可以显式声明。</li>
<li>发布消息的时候，消息属性中的<code>reply-to</code>属性需要指定为<code>amq.rabbitmq.reply-to</code>。</li>
</ul>
<p><strong>对于RPC服务端：</strong></p>
<ul>
<li>RPC服务端接收消息后感知消息属性中的<code>reply-to</code>属性存在，它应该通过默认的交换器(名称为&quot;&quot;)和<code>reply-to</code>属性作为路由键发送回复消息，那么该回复消息就会直接投递到RPC客户端的消费者中。</li>
<li>如果RPC服务端需要进行一些长时间的计算逻辑，可能需要探测RPC服务端是否存活，可以使用一个一次性使用的信道对<code>reply-to</code>属性做一次队列声明，如果声明成功，队列<code>amq.rabbitmq.reply-to</code>并不会创建，如果声明失败，那么说明客户端已经失去连接。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>RPC客户端在创建伪队列<code>amq.rabbitmq.reply-to</code>消费者的时候必须使用非手动ack模式(autoAck=true)。</li>
<li>使用此机制发送的回复消息通常不具有容错能力，如果发布原始请求的客户端随后断开连接，它们将被丢弃。</li>
<li>伪队列<code>amq.rabbitmq.reply-to</code>可以在<code>basic.consume</code>、<code>basic.publish</code>和消息属性<code>reply-to</code>中使用，实际上，它并不是一个真实存在的队列，RabbitMQ的Web管理器或者<code>rabbitmqctl list_queues</code>命令都无法展示该伪队列的相关属性或者信息。</li>
</ul>
<p>说实话，个人认为这种方式有个比较多的局限性：</p>
<ul>
<li>同一个应用里面，只能使用唯一一个伪队列<code>amq.rabbitmq.reply-to</code>消费回复消息，并且RabbitMQ的Web管理器或者<code>rabbitmqctl list_queues</code>命令都无法展示该伪队列的相关属性或者信息，也就是无法对它进行监控或者管理。</li>
<li>对于多应用同时接进去同一个RabbitMQ消息中间件代理，这些应用之间无法同时使用<code>amq.rabbitmq.reply-to</code>这个特性，因为有可能A客户端发送的消息被远程服务回调到另一个不同的B客户端。</li>
</ul>
<h2 id="直接回复特性使用">直接回复特性使用</h2>
<p>使用伪队列<code>amq.rabbitmq.reply-to</code>的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplyToRawMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FAKE_QUEUE = <span class="string">"amq.rabbitmq.reply-to"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RPC_QUEUE = <span class="string">"rpc.queue"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_EXCHANGE = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			<span class="comment">// 服务端队列</span></span><br><span class="line">			channel.queueDeclare(RPC_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">			client(channel);</span><br><span class="line">			server(channel);</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 客户端消费 - no-ack,也就是autoAck = true</span></span><br><span class="line">		channel.basicConsume(FAKE_QUEUE, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">									   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">									   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(String.format(<span class="string">"[X-Client]\ndeliveryTag:%s\nexchange:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">						envelope.getDeliveryTag(), envelope.getExchange(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">						properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">// 客户端发送</span></span><br><span class="line">		AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">				.correlationId(<span class="string">"message-99999"</span>)</span><br><span class="line">				.replyTo(FAKE_QUEUE)</span><br><span class="line">				.build();</span><br><span class="line">		channel.basicPublish(DEFAULT_EXCHANGE, RPC_QUEUE, basicProperties, <span class="string">"Reply Message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 服务端消费</span></span><br><span class="line">		channel.basicConsume(RPC_QUEUE, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">									   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">									   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">									   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(String.format(<span class="string">"[X-Server]\ndeliveryTag:%s\nexchange:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">						envelope.getDeliveryTag(), envelope.getExchange(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">						properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">				<span class="comment">// 服务端应答-&gt;客户端</span></span><br><span class="line">				AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">						.correlationId(properties.getCorrelationId())</span><br><span class="line">						.build();</span><br><span class="line">				channel.basicPublish(DEFAULT_EXCHANGE, properties.getReplyTo(), basicProperties, body);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，可以直接创建一个真实的独占队列(生命周期跟客户端的连接绑定)作为回复队列，举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplyToMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			<span class="comment">// 服务端队列</span></span><br><span class="line">			channel.queueDeclare(<span class="string">"rpc.queue"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 客户端接收应答队列 - 排他队列,生命周期和连接绑定</span></span><br><span class="line">			AMQP.Queue.DeclareOk callback = channel.queueDeclare(<span class="string">""</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"建立排他应答队列:"</span> + callback.getQueue());</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 客户端消费</span></span><br><span class="line">			channel.basicConsume(callback.getQueue(), <span class="keyword">false</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">										   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">										   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">										   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">					System.out.println(String.format(<span class="string">"[X-Client]\ndeliveryTag:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">							envelope.getDeliveryTag(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">							properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 服务端消费</span></span><br><span class="line">			channel.basicConsume(<span class="string">"rpc.queue"</span>, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">										   Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">										   AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">										   <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">					System.out.println(String.format(<span class="string">"[X-Server]\ndeliveryTag:%s\nroutingKey:%s\ncorrelationId:%s\nreplyTo:%s\ncontent:%s\n"</span>,</span><br><span class="line">							envelope.getDeliveryTag(), envelope.getRoutingKey(), properties.getCorrelationId(),</span><br><span class="line">							properties.getReplyTo(), <span class="keyword">new</span> String(body, StandardCharsets.UTF_8)));</span><br><span class="line">					<span class="comment">// 服务端应答</span></span><br><span class="line">					AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">							.correlationId(properties.getCorrelationId())</span><br><span class="line">							.build();</span><br><span class="line">					channel.basicPublish(<span class="string">""</span>, properties.getReplyTo(), basicProperties, body);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 客户端发送</span></span><br><span class="line">			AMQP.BasicProperties basicProperties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">					.correlationId(<span class="string">"message-99999"</span>)</span><br><span class="line">					.replyTo(callback.getQueue())</span><br><span class="line">					.build();</span><br><span class="line">			channel.basicPublish(<span class="string">""</span>, <span class="string">"rpc.queue"</span>, basicProperties, <span class="string">"Reply Message"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="个人想法">个人想法</h2>
<p>在实际项目中，我们经常被RabbitMQ消息发送是否成功这个问题困扰，一般情况下，我们认为调用<code>basic.publish</code>只要不抛出异常就是发送消息成功，例如一个代码模板如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		channel.basicPublish();</span><br><span class="line">		<span class="comment">// 发送成功</span></span><br><span class="line">		success = <span class="keyword">true</span>;</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">		<span class="comment">// 发送失败</span></span><br><span class="line">		log.error();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码模板在极大多数情况下是合适的，但是有些时候我们确实需要消息的接收方告知发送方已经收到消息，这个时候就需要用到消息的回复功能，个人认为可选的方案有：</p>
<ul>
<li>消息发布方基于伪队列<code>amq.rabbitmq.reply</code>进行消费，消息接收方回复到伪队列<code>amq.rabbitmq.reply</code>上。</li>
<li>消息发布方自定义独占队列进行消费，消息接收方回复到此独占队列。</li>
<li>消息发布方自定义持久化队列进行消费，消息接收方回复到此持久化队列。</li>
</ul>
<p>其实，<strong>在<code>AMQP.BasicProperties</code>的replyTo属性中指定需要回复的队列名只是RabbitMQ提出的一种规约或者建议，并不是强制实行的方案，实际上可以自行选择回复队列或者忽略replyTo属性</strong>。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/30/rabbitmq-extension-consumer-priority/">
      RabbitMQ扩展之消费者优先级
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：690字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：2分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-30T00:25:37+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年11月30日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文来源于官方文档<a href="https://www.rabbitmq.com/consumer-priority.html" target="_blank" rel="noopener">Consumer Priorities</a>。</p>
<h2 id="消费者优先级">消费者优先级</h2>
<p>消费者优先级的机制：</p>
<ul>
<li>高优先级的消费者处于活跃状态的情况下优先接收和处理消息。</li>
<li>消息会流入到低优先级的活跃消费者仅当高优先级的消费者处于阻塞状态。</li>
</ul>
<p>正常情况下，所有订阅同一个队列的活跃消费者以循环的(round-robin)方式从队列中接收消息。当使用了消费者优先级，如果多个活跃消费者使用了相同的高优先级属性，那么消息投递也是以循环的方式进行(其实使用了相同的优先级类似于没有启用优先级)。</p>
<h3 id="活跃消费者的定义">活跃消费者的定义</h3>
<p>活跃的消费者就是可以在不用等待的情况下接收和处理消息的消费者，也就是消费者如果无法接收消息，那么它就是出于非活跃状态(或者说阻塞状态)，阻塞的常见原因有：</p>
<ul>
<li>使用了<code>basic.qos</code>之后，消费者在信道中未确认的预读取消息达到了上限。</li>
<li>网络阻塞。</li>
</ul>
<p>因此，对于每个存在的队列，必定至少出现下面三种情况的其中一种：</p>
<ul>
<li>队列没有活跃的消费者。</li>
<li>队列是空的。</li>
<li>队列正在忙于向消费者投递消息。</li>
</ul>
<p>消费者可能在一秒内多次在活跃和阻塞状态之间切换，只要消费处理速度足够快。<strong>RabbitMQ不会通过Web管理插件或者<code>rabbitmqctl</code>命令公开消费者当前是活跃还是阻塞状态</strong>，换言之，只能通过客户端感知。</p>
<p>启用消费者优先级的时候，RabbitMQ会优先投递消息到优先级属性比较高的消费者，但是如果所有优先级高的消费者都处于阻塞状态，RabbitMQ会把消息投递到活跃的优先级稍低的消费者，而不是一直等待优先级高的消费者解除阻塞，造成优先级低的消费者一直处于饥饿状态。</p>
<h3 id="使用消费者优先级特性">使用消费者优先级特性</h3>
<p><strong>在使用<code>basic.consume</code>方法可以设置参数<code>x-priority</code>的值为整数，数字越大则优先级越高，未设置则使用默认值0</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerPriorityMain</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			Map&lt;String, Object&gt; consumerArgs = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">			consumerArgs.put(<span class="string">"x-priority"</span>, <span class="number">10</span>);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>, <span class="keyword">true</span>, consumerArgs, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			&#125;);</span><br><span class="line">			consumerArgs.put(<span class="string">"x-priority"</span>, <span class="number">100</span>);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>, <span class="keyword">true</span>, consumerArgs, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子设置了两个消费者，后者的优先级为100，而前者的优先级为10。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/28/rabbitmq-extension-consumer-prefetch/">
      RabbitMQ扩展之消费者消息预读取
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月28日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.1k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：4分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-28T23:21:11+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年11月28日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文来源于官方文档<a href="https://www.rabbitmq.com/consumer-prefetch.html" target="_blank" rel="noopener">Consumer Prefetch</a>。</p>
<h2 id="消费者消息预读取">消费者消息预读取</h2>
<p>消费者消息预读取是一个更加合理和高效的限制未确认消息数量的解决方式。</p>
<p>AMQP 0-9-1协议中定义了<code>basic.qos</code>方法用于限制信道或者连接上的未确认消息数量，这个消息数据量命名为<code>prefetch_count</code>。不幸的是，信道其实并不是限制未确认消息数量的理想范畴，因为单个信道有可能有多个消费者订阅多个不同的队列，所以信道和队列需要为发送的每个消息相互协调，以确保消息总数量不超过限制，造成了性能下降，单机性能出现瓶颈，在集群方案中耗时更加严重。</p>
<p><code>basic.qos</code>定义了两个属性：</p>
<ul>
<li>prefetch_count：预读取消息的数量。</li>
<li>global：是否全局的。</li>
</ul>
<p>在许多情况下，指定每个消费者的预读取消息数量更加合理。因此，RabbitMQ在<code>basic.qos</code>方法中重新定义了<code>global</code>标志的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:left">global的值</th>
<th style="text-align:left">prefetch_count在AMQP 0-9-1中的含义</th>
<th style="text-align:left">prefetch_count在RabbitMQ中的含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">同一个信道上的消费者共享</td>
<td style="text-align:left">单独应用于信道上的每个新消费者</td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">所有消费者基于同一个连接共享</td>
<td style="text-align:left">同一个信道上的消费者共享</td>
</tr>
</tbody>
</table>
<p><code>basic.qos</code>方法在RabbitMQ的Java驱动中对应三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchSize, <span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefetchSize = 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount, <span class="keyword">boolean</span> global)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prefetchSize = 0 , global = false</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicQos</span><span class="params">(<span class="keyword">int</span> prefetchCount)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>prefetchSize：预读取的消息内容大小上限(包含)，可以简单理解为消息有效载荷字节数组的最大长度限制，0表示无上限。</li>
<li>prefetchCount：预读取的消息数量上限，0表示无上限。</li>
<li>global：false表示prefetchCount单独应用于信道上的每个新消费者，true表示prefetchCount在同一个信道上的消费者共享。</li>
</ul>
<h3 id="限制单个消费者">限制单个消费者</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicQosSingle</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			channel.basicQos(<span class="number">10</span>); <span class="comment">//基于消费者进行限制</span></span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此消费者最多只能有10条预读取的未确认的消息。</p>
<h3 id="独立限制多个消费者">独立限制多个消费者</h3>
<p>基于同一个信道对多个队列建立不同的消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicQosMulti</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			DefaultConsumer consumer1 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			DefaultConsumer consumer2 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			channel.basicQos(<span class="number">10</span>); <span class="comment">//基于消费者进行限制</span></span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>,consumer1);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.fanout"</span>,consumer2);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个费者最多只能有10条预读取的未确认的消息。</p>
<h3 id="基于共享限制多个消费者">基于共享限制多个消费者</h3>
<p>AMQP规范没有解释如果使用不同的<code>global</code>多次调用<code>basic.qos</code>会发生什么，RabbitMQ将此解释为意味着两个预取限制应该彼此独立地强制执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicQosShare</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			DefaultConsumer consumer1 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			DefaultConsumer consumer2 = <span class="keyword">new</span> DefaultConsumer(channel) &#123;&#125;;</span><br><span class="line">			channel.basicQos(<span class="number">10</span>, <span class="keyword">false</span>); <span class="comment">//基于消费者进行限制</span></span><br><span class="line">			channel.basicQos(<span class="number">15</span>, <span class="keyword">true</span>); <span class="comment">//基于信道进行限制</span></span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>,consumer1);</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.fanout"</span>,consumer2);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码表示：</p>
<ul>
<li>两个消费者consumer1和consumer2基于信道最多只能有15条未确认的预读取消息。</li>
<li>消费者consumer1和consumer2自身最多只能有10条未确认的预读取消息。</li>
</ul>
<p>也就是有双重限制，这种限制需要信道和队列之间协调，会耗费额外的性能。</p>
<h2 id="消息预读取的意义">消息预读取的意义</h2>
<p>消息预读取可以理解为RabbitMQ Broker把未确认的消息批量推送到RabbitMQ的Java客户端中，由客户端先缓存这些消息，然后投递到消费者中。试想，如果在推模式下，没有消息预读取功能，RabbitMQ Broker每次投递一条消息到客户端消费者中，这样就会产生大量的IO操作，导致性能下降，此外，消费者处理速度有可能比较快，容易产生消费者饥饿的情况。可以根据消费者实际的消费速度和消息发布的速度，对消费者的预读取未确认消息的上限进行配置，这样在大多数场景下可以提高消费者的性能。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/11/28/rabbitmq-extension-confirm-cancel/">
      RabbitMQ扩展之消费者取消通知
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年11月28日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/RabbitMQ/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;RabbitMQ</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：646字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：2分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-11-28T23:03:26+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年11月28日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>前提</h1>
<p>本文来源于官方文档<a href="https://www.rabbitmq.com/consumer-cancel.html" target="_blank" rel="noopener">Consumer Cancel Notification</a>。</p>
<h2 id="消费者取消通知">消费者取消通知</h2>
<p>当一个信道上建立的消费者订阅了一个队列，有可能出现各种原因导致消费停止。一个很明显的原因就是客户端在同一个信道上发出<code>basic.cancel</code>命令，消息中间件代理响应<code>basic.cancel-ok</code>，将会导致消费者被取消。还有其他的事件如队列的删除或者集群方案所在队列的集群节点失败也有可能导致消费者被取消，<strong>消费者被取消这个事件并不会通知客户端对应的信道，这样子会造成客户端无法感知消费者被取消</strong>。</p>
<p>为了避免上面这些情况出现，RabbitMQ引入了扩展特性：由于消息中间件代理出现的异常或者正常情况导致消费者取消，会向对应的消费者(信道)发送<code>basic.cancel</code>，但是由客户端信道主动向消息中间件代理发送<code>basic.cancel</code>以取消消费者的情况下不会受到消息中间件代理的<code>basic.cancel</code>回复。</p>
<p>有些情况下，客户端感知到异常(例如队列删除等)主动向消息中间件代理发送<code>basic.cancel</code>，这个时候，消息中间件代理也有可能因为队列删除主动向对应的消费者(信道)发送<code>basic.cancel</code>，也就是存在竞争，RabbitMQ代理收到前者的<code>basic.cancel</code>时不会出现异常，基于后者还是正常回复<code>basic.cancel-ok</code>。</p>
<p>举个例子，<strong>情况一：例如我们主动取消信道上的消费者</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitiativeBasicCancel</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			<span class="comment">// 此方法返回的是消费者的标签</span></span><br><span class="line">			String consumerTag = channel.basicConsume(<span class="string">"throwable.queue.direct"</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;);</span><br><span class="line">			channel.basicCancel(consumerTag);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>情况二：假如我们想监听消息中间件代理异步回调的<code>basic.cancel</code>和<code>basic.cancel-ok</code>，应该这样做</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncBasicCancel</span> <span class="keyword">extends</span> <span class="title">BaseChannelFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		provideChannel(channel -&gt; &#123;</span><br><span class="line">			channel.basicConsume(<span class="string">"throwable.queue.direct"</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCancelOk</span><span class="params">(String consumerTag)</span> </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"收到来自消息中间件代理的basic.cancel-ok回复,consumerTag="</span> + consumerTag);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCancel</span><span class="params">(String consumerTag)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"收到来自消息中间件代理的basic.cancel回复,consumerTag="</span> + consumerTag);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，我们应该同时考虑情况一和情况二有可能同时发生(也就是前面说到的竞争)，并且做好相应的处理即可。</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/RabbitMQ/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> RabbitMQ</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/blog/categories/Middleware/page/2/">
            <section class="post prev white-box card-shadow " >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          3 / 4
        </p>
        
          <a class="next" rel="next" href="/blog/categories/Middleware/page/4/">
            <section class="post next white-box card-shadow ">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  

</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
