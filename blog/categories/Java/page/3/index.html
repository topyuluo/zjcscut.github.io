<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Category: Java | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 5px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/06/java-jsr310-date-time-calculate/">
      JSR310新日期API(四)-日期时间常用计算工具
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月6日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.5k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：6分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-06T16:25:10+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月6日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(四)-日期时间常用计算工具</h1>
<h2 id="前提">前提</h2>
<p>这篇文章主要介绍JSR-310中日期时间类的常用计算工具，包括常规的两个日期时间实例之间的前后比较、间隔的时间量等等。</p>
<h2 id="日期时间的基准类">日期时间的基准类</h2>
<p>日期时间类库中提供了几个常用的计算或者度量基准类，分别是：</p>
<ul>
<li>表示取值范围的<code>ValueRange</code>：内部持有四个主要的成员变量minSmallest、minLargest、maxSmallest和maxLargest，可以表示的值范围是<code>[minSmallest/maxSmallest,minLargest/maxLargest]</code>。</li>
<li>表示秒和纳秒级别的时间量<code>Duration</code>：<code>TemporalAmount</code>的实现类，内部持有一个长整型的成员seconds代表秒和一个整型的成员nanos代表纳秒，由秒和纳秒组成时间量。</li>
<li>表示年月日级别的时间量<code>Period</code>：<code>TemporalAmount</code>的实现类，内部持有三个整型的成员years、months和days分别代表年、月、日，由年月日组成时间量。</li>
<li>日期时间的基本单位<code>TemporalUnit</code>：主要实现类是枚举类型<code>ChronoUnit</code>，一个<code>ChronoUnit</code>成员会维护一个字符串名字属性name和一个<code>Duration</code>类型的实例。</li>
<li>日期时间的属性(field)表示<code>TemporalField</code>：主要实现是枚举类型<code>ChronoField</code>，一个<code>ChronoField</code>成员会维护一个字符串名字属性name、一个<code>TemporalUnit</code>的基础单位baseUnit、一个<code>TemporalUnit</code>的表示范围的单位rangeUnit和一个<code>ValueRange</code>类型的range用于表示当前属性的范围。</li>
</ul>
<p>举一些简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueRangeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ValueRange valueRange = ValueRange.of(<span class="number">1L</span>, <span class="number">10000L</span>);</span><br><span class="line">		System.out.println(valueRange);</span><br><span class="line">		valueRange = ValueRange.of(<span class="number">1L</span>, <span class="number">5L</span>, <span class="number">10000L</span>, <span class="number">50000L</span>);</span><br><span class="line">		System.out.println(valueRange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span> - <span class="number">10000</span></span><br><span class="line"><span class="number">1</span>/<span class="number">5</span> - <span class="number">10000</span>/<span class="number">50000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Duration duration = Duration.of(<span class="number">1L</span>, ChronoUnit.HOURS);</span><br><span class="line">		System.out.println(duration);</span><br><span class="line">		duration = Duration.from(duration);</span><br><span class="line">		System.out.println(duration);</span><br><span class="line">		duration = Duration.ofSeconds(<span class="number">1L</span>, <span class="number">999_999_999</span>);</span><br><span class="line">		System.out.println(duration.get(ChronoUnit.SECONDS));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果 - toString方法重写了，有特定的格式</span></span><br><span class="line">PT1H</span><br><span class="line">PT1H</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Period period = Period.of(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">		System.out.println(period);</span><br><span class="line">		period = Period.from(period);</span><br><span class="line">		System.out.println(period.getYears());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">P10Y10M10D</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="常用计算工具">常用计算工具</h2>
<h3 id="判断是否闰年">判断是否闰年</h3>
<p>判断是否闰年这个功能是由年表<code>Chronology</code>提供的，因为不同的年表中的闰年规则可能不一致。一般情况下，我们都是使用ISO规范下的年表，对应的是<code>IsoChronology</code>，可以看一下<code>IsoChronology</code>判断闰年方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">long</span> prolepticYear)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((prolepticYear &amp; <span class="number">3</span>) == <span class="number">0</span>) &amp;&amp; ((prolepticYear % <span class="number">100</span>) != <span class="number">0</span> || (prolepticYear % <span class="number">400</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也是最常见的Java基础面试题之一，可以记下来怎么实现。静态方法<code>java.time.Year#isLeap()</code>也是同样的实现。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsLeapYearMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> year = <span class="number">2016</span>;</span><br><span class="line">		System.out.println(Year.isLeap(year));</span><br><span class="line">		System.out.println(IsoChronology.INSTANCE.isLeapYear(year));</span><br><span class="line">		<span class="comment">// 2018年</span></span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		System.out.println(localDate.isLeapYear());</span><br><span class="line">		System.out.println(localDateTime.toLocalDate().isLeapYear());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h3 id="比较日期时间的先后">比较日期时间的先后</h3>
<p>所有的日期时间、日期、时间类都具备三个比较方法：<code>isBefore()</code>、<code>isAfter()</code>和<code>isEqual()或者equals()</code>，对于<code>ChronoLocalDateTime</code>或者<code>ChronoZonedDateTime</code>，底层总是先转化为新纪元天数再基于天数进行比较。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeCompareMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(LocalDateTime.now().isBefore(LocalDateTime.now().plus(<span class="number">1</span>, ChronoUnit.SECONDS)));</span><br><span class="line">		System.out.println(LocalDate.now().isBefore(LocalDate.now().plus(<span class="number">1</span>, ChronoUnit.DAYS)));</span><br><span class="line">		System.out.println(LocalTime.now().equals(LocalTime.now().plus(<span class="number">1</span>, ChronoUnit.SECONDS)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h3 id="计算日期时间的间隔">计算日期时间的间隔</h3>
<p>计算日期时间的间隔主要通过<code>Duration</code>或者<code>Period</code>的静态方法，主要是通过两个类的<code>between()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Duration中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Duration <span class="title">between</span><span class="params">(Temporal startInclusive, Temporal endExclusive)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Period中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Period</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChronoPeriod <span class="title">between</span><span class="params">(ChronoLocalDate startDateInclusive, ChronoLocalDate endDateExclusive)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> Period <span class="title">between</span><span class="params">(LocalDate startDateInclusive, LocalDate endDateExclusive)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于日期时间类来说，计算时间间隔底层是基于<code>TemporalUnit#between()</code>方法，入口方法一般是<code>long until(Temporal endExclusive, TemporalUnit unit)</code>方法。</p>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurationPeriodMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalTime start = LocalTime.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		LocalTime end = LocalTime.of(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">		Duration duration = Duration.between(start, end);</span><br><span class="line">		<span class="keyword">long</span> until = start.until(end, ChronoUnit.SECONDS);</span><br><span class="line">		System.out.println(duration.getSeconds());</span><br><span class="line">		System.out.println(until);</span><br><span class="line">		LocalDateTime startDt = LocalDateTime.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">		LocalDateTime endDt = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">		duration = Duration.between(startDt, endDt);</span><br><span class="line">		until = startDt.until(endDt, ChronoUnit.SECONDS);</span><br><span class="line">		System.out.println(duration.getSeconds());</span><br><span class="line">		System.out.println(until);</span><br><span class="line">		LocalDate startD = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		LocalDate endD = LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">		Period period = Period.between(startD, endD);</span><br><span class="line">		Period untilPeriod = startD.until(endD);</span><br><span class="line">		System.out.println(period);</span><br><span class="line">		System.out.println(untilPeriod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">3661</span></span><br><span class="line"><span class="number">3661</span></span><br><span class="line"><span class="number">10581009</span></span><br><span class="line"><span class="number">10581009</span></span><br><span class="line">P11M5D</span><br><span class="line">P11M5D</span><br></pre></td></tr></table></figure>
<p>只要通过计算得到<code>Duration</code>或者<code>Period</code>实例，那么可以通过<code>get(TemporalUnit unit)</code>方法转换为对应单位的时间量，但是要注意的是对于此方法<code>Duration</code>只支持<code>ChronoUnit.SECONDS</code>和<code>ChronoUnit.NANOS</code>，而<code>Period</code>只支持<code>ChronoUnit.YEARS</code>、<code>ChronoUnit.MONTHS</code>和<code>ChronoUnit.DAYS</code>。一般情况下，我们更希望得知两个日期时间之间相差多少年，多少个月等，这个时候，可以使用<code>Duration</code>或者<code>Period</code>提供的实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Period中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相差的总月数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toTotalMonths</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Period中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Period</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为天数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toDays</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为小时数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toHours</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为分钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMinutes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为秒钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toSeconds</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为毫秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMillis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为纳秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toNanos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确天数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toDaysPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确小时数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toHoursPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确分钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toMinutesPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确秒钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toSecondsPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确毫秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toMillisPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确纳秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toNanosPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上的实例方法都是<strong>基于整数的除法，也就是说会截断尾数</strong>。举个简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime start = LocalDateTime.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">LocalDateTime end = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">Duration duration = Duration.between(start, end);</span><br><span class="line">Period period = Period.between(start.toLocalDate(), end.toLocalDate());</span><br><span class="line">System.out.println(duration.toDays());</span><br><span class="line">System.out.println(period.toTotalMonths());</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如果不使用<code>Duration</code>或者<code>Period</code>，可以直接使用日期时间类的<code>util()</code>方法，本质是一致的，以<code>LocalDateTime</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime start = LocalDateTime.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">LocalDateTime end = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">long</span> months = start.until(end, ChronoUnit.MONTHS);</span><br><span class="line"><span class="keyword">long</span> days = start.until(end, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(months);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>(本文完 c-1-d e-a-201816)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/05/java-jsr310-date-time-format-parse/">
      JSR310新日期API(三)-日期时间格式化与解析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月5日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：11分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-05T21:45:27+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月5日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(三)-日期时间格式化与解析</h1>
<h2 id="前提">前提</h2>
<p>前一篇文章已经比较详细地介绍了JSR-310中新增的常用的日期时间类，在实际应用中，我们也十分关注这些日期时间类的格式化操作，更加通俗来说就是字符串和日期时间类的相互转换问题。下面先回顾一下Java旧有的日期时间类和字符串之间的转换方案，然后重点分析JSR-310中新增的常用的日期时间类和字符串之间的转换方案。</p>
<h2 id="SimpleDateFormat">SimpleDateFormat</h2>
<p>Java旧有的日期时间类格式化为字符串或者字符串基于模式(pattern)解析为日期时间类完全依赖于<code>java.text.DateFormat</code>的实现类<code>java.text.SimpleDateFormat</code>。<code>SimpleDateFormat</code>的基本功能是完备的，但是存在两个问题：</p>
<ul>
<li><strong>解析和格式化的效率比较低</strong>，原因是依赖了本来就效率不高的<code>Calendar</code>，内部有大量的字符串或者字符(char)的判断和转换代码，因此使用了大量循环、switch块等，这些因素都导致了<code>SimpleDateFormat</code>的效率比较低。</li>
<li><strong>非线程安全</strong>，这个是因为<code>SimpleDateFormat</code>在做转换操作的时候共享了<code>DateFormat</code>的一个内部<code>Calendar</code>的成员calendar。</li>
</ul>
<p>效率低是可以忍受的，但是非线程安全这一点可能会导致严重的问题。对于非线程安全这个问题也有解决方案：</p>
<ul>
<li>方案一：把<code>SimpleDateFormat</code>实例封闭在方法中，也就是调用的时候才创建，这样虽然导致了资源浪费，但是可以避免并发问题。</li>
<li>方案二：使用<code>ThreadLocal</code>装载<code>SimpleDateFormat</code>实例，对于同一个线程来说，共享一个<code>SimpleDateFormat</code>实例。</li>
</ul>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		java.util.Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateString = simpleDateFormat.format(date);</span><br><span class="line">		System.out.println(dateString);</span><br><span class="line">		date = simpleDateFormat.parse(dateString);</span><br><span class="line">		System.out.println(date);</span><br><span class="line">		simpleDateFormat.applyPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">		dateString = simpleDateFormat.format(date);</span><br><span class="line">		System.out.println(dateString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">03</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">05</span></span><br><span class="line">Thu Jan <span class="number">03</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">05</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">03</span></span><br></pre></td></tr></table></figure>
<p>对于Java旧有的日期时间类，<code>SimpleDateFormat</code>是基本能够满足的，再加上有第三方库<code>apache-common-lang3</code>、<code>joda-time</code>等的补足，格式化和解析的效率也会有所提高。</p>
<h2 id="JSR-310日期时间类的格式化和解析">JSR-310日期时间类的格式化和解析</h2>
<p>JSR-310日期时间类的格式化依赖于日期时间格式化器<code>java.time.format.DateTimeFormatter</code>，它有一个建造器类<code>java.time.format.DateTimeFormatterBuilder</code>。</p>
<h3 id="DateTimeFormatterBuilder">DateTimeFormatterBuilder</h3>
<p><code>java.time.format.DateTimeFormatterBuilder</code>用于构建日期时间类格式化器，它在设计的时候使用了链式结构，内部持有一个<code>DateTimeFormatterBuilder</code>类型的parent成员指向父<code>DateTimeFormatterBuilder</code>实例和一个<code>DateTimeFormatterBuilder</code>类型的active成员指向当前的<code>DateTimeFormatterBuilder</code>实例。还有一点比较重要的是：<code>DateTimeFormatterBuilder</code>实例内部维护了一个<code>DateTimePrinterParser</code>列表printerParsers，真正的解析工作是委托给对应的<code>DateTimePrinterParser</code>实例完成的，如果没有可用或者没有添加<code>DateTimePrinterParser</code>，那么解析或者格式化方法相当于空跑。接着看下<code>DateTimeFormatterBuilder</code>提供构建<code>DateTimeFormatter</code>时允许添加特性的方法。</p>
<p><strong>解析风格配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小写敏感 - 默认</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseCaseSensitive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 大小写不敏感</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseCaseInsensitive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 严格 - 默认</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseStrict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 宽松</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseLenient</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>默认值配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于TemporalField实例配置解析时候写入默认值，支持的TemporalField主要在ChronoField</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseDefaulting</span><span class="params">(TemporalField field, <span class="keyword">long</span> value)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加日期时间属性格式化符号控制配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于每个日期时间字段格式化的控制，实际作用是添加一个DateTimePrinterParser的实现NumberPrinterParser</span></span><br><span class="line"><span class="comment"> * TemporalField：日期时间字段类型实例，主要实现类为在ChronoField的枚举属性</span></span><br><span class="line"><span class="comment"> * minWidth：打印最小长度限制，范围是[1,19]</span></span><br><span class="line"><span class="comment"> * maxWidth：打印最大长度限制，范围是[1,19]</span></span><br><span class="line"><span class="comment"> * SignStyle：符号风格，有NORMAL、ALWAYS、NEVER、NOT_NEGATIVE、EXCEEDS_PAD五种选择</span></span><br><span class="line"><span class="comment"> *     - NORMAL：严格模式下只接收负值，宽松模式下接收所有符号</span></span><br><span class="line"><span class="comment"> *     - ALWAYS：0会替换为'+'，严格模式下不接收缺失的符号，宽松模式下缺失的符号会替换为一个正数</span></span><br><span class="line"><span class="comment"> *     - NEVER：只输出绝对的固定值，严格模式下不接收任何符号，宽松模式下只接收固定长度的符号</span></span><br><span class="line"><span class="comment"> *     - NOT_NEGATIVE：以异常的方式阻止负值，严格模式下不接收任何符号，宽松模式下只接收固定长度的符号</span></span><br><span class="line"><span class="comment"> *     - EXCEEDS_PAD：只输出超出宽度限制的符号，负数替换为'-'，严格模式下只输出超出宽度限制的符号，宽松模式下缺失的符号会替换为一个正数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValue</span><span class="params">(TemporalField field, <span class="keyword">int</span> minWidth, <span class="keyword">int</span> maxWidth, SignStyle signStyle)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 下面2个是重载方法</span></span></span><br><span class="line"><span class="function"><span class="comment">// minWidth = 1,maxWidth = 19,signStyle = SignStyle.NORMAL</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValue</span><span class="params">(TemporalField field)</span></span></span><br><span class="line"><span class="function"><span class="comment">// minWidth = maxWidth = width,signStyle = SignStyle.NOT_NEGATIVE</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValue</span><span class="params">(TemporalField field, <span class="keyword">int</span> width)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加基于基础值进行减少配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如field=YEAR，width=2，baseValue=2018，那么当前格式化的实例的有效值为[2018,2117]，2019-&gt;1，2117-&gt;99</span></span><br><span class="line"><span class="comment">// width范围是[1,10]，maxWidth范围是[1,10]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValueReduced</span><span class="params">(TemporalField field, <span class="keyword">int</span> width, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> baseValue)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValueReduced</span><span class="params">(TemporalField field, <span class="keyword">int</span> width, <span class="keyword">int</span> maxWidth, ChronoLocalDate baseDate)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加小数(点)配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decimalPoint = true则输出小数，minWidth范围是[0,9]，maxWidth范围是[1,9]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendFraction</span><span class="params">(TemporalField field, <span class="keyword">int</span> minWidth, <span class="keyword">int</span> maxWidth, <span class="keyword">boolean</span> decimalPoint)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加文本格式配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendText</span><span class="params">(TemporalField field)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendText</span><span class="params">(TemporalField field, TextStyle textStyle)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendText</span><span class="params">(TemporalField field, Map&lt;Long, String&gt; textLookup)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加瞬时时间配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendInstant</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendInstant</span><span class="params">(<span class="keyword">int</span> fractionalDigits)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加时区相关的配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间偏移量如+01:00</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendOffsetId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 指定格式的时间偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendOffset</span><span class="params">(String pattern, String noOffsetText)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 指定文本风格的本地时间偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLocalizedOffset</span><span class="params">(TextStyle style)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneRegionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneOrOffsetId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneText</span><span class="params">(TextStyle textStyle)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneText</span><span class="params">(TextStyle textStyle, Set&lt;ZoneId&gt; preferredZones)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 太平洋时间时区偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendGenericZoneText</span><span class="params">(TextStyle textStyle)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendGenericZoneText</span><span class="params">(TextStyle textStyle, Set&lt;ZoneId&gt; preferredZones)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 日历配置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendChronologyId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendChronologyText</span><span class="params">(TextStyle textStyle)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加本地日期时间配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLocalized</span><span class="params">(FormatStyle dateStyle, FormatStyle timeStyle)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加常量文字(字符串)配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLiteral</span><span class="params">(<span class="keyword">char</span> literal)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLiteral</span><span class="params">(String literal)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加其他格式化器的属性到当期建造器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">append</span><span class="params">(DateTimeFormatter formatter)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 配置候选格式化器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendOptional</span><span class="params">(DateTimeFormatter formatter)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加通用格式配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pattern的解析基本包含了上面提到的其他种类的配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendPattern</span><span class="params">(String pattern)</span></span></span><br></pre></td></tr></table></figure>
<p>上面只是分析完毕，实际上理解这些配置方法的成本还是挺高的，可以参考<code>DateTimeFormatter</code>中已经存在的一些静态变量<code>ISO_LOCAL_TIME</code>、<code>ISO_OFFSET_TIME</code>、<code>ISO_LOCAL_DATE_TIME</code>等学习怎么使用<code>DateTimeFormatterBuilder</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ISO_LOCAL_TIME;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ISO_LOCAL_TIME = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">            .appendValue(HOUR_OF_DAY, <span class="number">2</span>)</span><br><span class="line">            .appendLiteral(<span class="string">':'</span>)</span><br><span class="line">            .appendValue(MINUTE_OF_HOUR, <span class="number">2</span>)</span><br><span class="line">            .optionalStart()</span><br><span class="line">            .appendLiteral(<span class="string">':'</span>)</span><br><span class="line">            .appendValue(SECOND_OF_MINUTE, <span class="number">2</span>)</span><br><span class="line">            .optionalStart()</span><br><span class="line">            .appendFraction(NANO_OF_SECOND, <span class="number">0</span>, <span class="number">9</span>, <span class="keyword">true</span>)</span><br><span class="line">            .toFormatter(ResolverStyle.STRICT, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模仿上面的代码，我们做一个简单的例子：格式化用<code>LocalDateTime</code>存储的日期时间2018-1-5 15:30:30为&quot;当前时间是：2018年1月5日 15时30分30秒，祝你生活愉快！&quot;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeFormatterBuilderMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DateTimeFormatterBuilder builder = <span class="keyword">new</span> DateTimeFormatterBuilder();</span><br><span class="line">		builder.appendLiteral(<span class="string">"当前时间是："</span>);</span><br><span class="line">		builder.appendValue(ChronoField.YEAR, <span class="number">4</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"年"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.MONTH_OF_YEAR, <span class="number">1</span>, <span class="number">2</span>, SignStyle.NORMAL);</span><br><span class="line">		builder.appendLiteral(<span class="string">"月"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.DAY_OF_MONTH, <span class="number">1</span>, <span class="number">2</span>, SignStyle.NORMAL);</span><br><span class="line">		builder.appendLiteral(<span class="string">"日"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">" "</span>);</span><br><span class="line">		builder.appendValue(ChronoField.HOUR_OF_DAY, <span class="number">2</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"时"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">":"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.MINUTE_OF_HOUR, <span class="number">2</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"分"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">":"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.SECOND_OF_MINUTE, <span class="number">2</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"秒"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"，祝你生活愉快！"</span>);</span><br><span class="line">		DateTimeFormatter formatter = builder.toFormatter();</span><br><span class="line">		System.out.println(formatter.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻执行后输出结果</span></span><br><span class="line">当前时间是：<span class="number">2019</span>年<span class="number">1</span>月<span class="number">5</span>日 <span class="number">15</span>时:<span class="number">50</span>分:<span class="number">50</span>秒，祝你生活愉快！</span><br></pre></td></tr></table></figure>
<p>从理论上来看，如果能够熟练使用上面分析过的规则，那么可以格式化或者反向解析任意格式的日期时间或者字符串。</p>
<h3 id="DateTimeFormatter">DateTimeFormatter</h3>
<p><code>java.time.format.DateTimeFormatter</code>在设计上是一个不可变类，也就是它是线程安全的，<code>DateTimeFormatter</code>的静态方法和实例方法只要返回<code>DateTimeFormatter</code>类型，那么必定是一个新的实例。它主要职责是格式化日期时间。一般情况下，构造<code>DateTimeFormatter</code>实例可以使用它提供的静态工厂方法，这些静态方法如果不能满足需求，可以考虑使用<code>DateTimeFormatterBuilder</code>定制化建造<code>DateTimeFormatter</code>实例。常用的2个静态工厂方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateTimeFormatter <span class="title">ofPattern</span><span class="params">(String pattern)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateTimeFormatter <span class="title">ofPattern</span><span class="params">(String pattern, Locale locale)</span></span></span><br></pre></td></tr></table></figure>
<p>字符串pattern基本可以填写任意合法的日期时间格式，因为底层使用<code>DateTimeFormatterBuilder#appendPattern()</code>进行解析，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>)</span><br></pre></td></tr></table></figure>
<p>至于日期时间实例的格式化，主要通过下面的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(TemporalAccessor temporal)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">formatTo</span><span class="params">(TemporalAccessor temporal, Appendable appendable)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeFormatterMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		String value = formatter.format(localDateTime);</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		formatter.formatTo(localDateTime, builder);</span><br><span class="line">		System.out.println(value);</span><br><span class="line">		System.out.println(builder.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line"><span class="number">2019</span>年<span class="number">01</span>月<span class="number">05</span>日 <span class="number">16</span>时<span class="number">28</span>分<span class="number">01</span>秒</span><br><span class="line"><span class="number">2019</span>年<span class="number">01</span>月<span class="number">05</span>日 <span class="number">16</span>时<span class="number">28</span>分<span class="number">01</span>秒</span><br></pre></td></tr></table></figure>
<p>字符串反解析为日期时间类型的(parse)方法并不存在于<code>DateTimeFormatter</code>类中，parse方法存在于日期时间类自身之中，这样的设计才是合理的，思想和领域驱动的方向是一致的，这里用<code>LocalDateTime</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用DateTimeFormatter.ISO_LOCAL_DATE_TIME进行解析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parse</span><span class="params">(CharSequence text)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用传入的自定义DateTimeFormatter进行解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parse</span><span class="params">(CharSequence text, DateTimeFormatter formatter)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeFormatterMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">		String dateTime = <span class="string">"2019年01月05日 16时28分01秒"</span>;</span><br><span class="line">		LocalDateTime parseResult = LocalDateTime.parse(dateTime, formatter);</span><br><span class="line">		System.out.println(parseResult);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">05</span>T16:<span class="number">28</span>:<span class="number">01</span></span><br></pre></td></tr></table></figure>
<p>由于<code>DateTimeFormatter</code>实例创建的时候相对耗时，因此需要考虑避免多次创建<code>DateTimeFormatter</code>实例，可以考虑编写一个工具类，用哈希表缓存<code>pattern -&gt; DateTimeFormatter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只列举LocalDateTime和LocalDate的例子，其他的日期时间类可以以此类推</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DateTimeFormatUtils &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 单例</span></span><br><span class="line">	SINGLETON;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTERS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">formatLocalDateTime</span><span class="params">(LocalDateTime value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getOrCreateDateTimeFormatter(pattern).format(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">parseLocalDateTime</span><span class="params">(String value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.parse(value, getOrCreateDateTimeFormatter(pattern));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">formatLocalDate</span><span class="params">(LocalDate value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getOrCreateDateTimeFormatter(pattern).format(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalDate <span class="title">parseLocalDate</span><span class="params">(String value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> LocalDate.parse(value, getOrCreateDateTimeFormatter(pattern));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> DateTimeFormatter <span class="title">getOrCreateDateTimeFormatter</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> FORMATTERS.computeIfAbsent(pattern, DateTimeFormatter::ofPattern);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还要注意一点：<strong>格式化或者解析的时候使用的模式pattern必须是合法日期时间表示格式(例如年份用yyyy表示)，并且严格区分日期时间、只有日期属性和只有时间属性三种不同的情况</strong>，如果使用<code>yyyy-MM-dd HH:mm:ss</code>模式创建的<code>DateTimeFormatter</code>去格式化<code>LocalTime</code>或者<code>LocalDate</code>，会抛出异常，异常的类型是<code>DateTimeException</code>或者其子类，属于运行时异常。</p>
<h2 id="小结">小结</h2>
<p>在JavaEE开发中，特别在系统交互中，日期时间字段的转换是比较重要的。其实JSR-310中的日期时间API的格式化和解析和旧有的日期时间API的格式化和解析从本质上是没有区别的，都是字符串解析和转换的游戏，但是个人是推荐使用JSR-310中的日期时间API的格式化和解析，原因是：</p>
<ul>
<li>性能上有很大提升(直观上推测，没有做严格测试)。</li>
<li>类库设计上更加合理。</li>
<li>线程安全。</li>
</ul>
<p>(本文完 e-a-2019-1-5 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/01/java-jsr310-time-api/">
      JSR310新日期API(二)-日期时间API
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月1日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：29分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-01T22:04:22+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(二)-日期时间API</h1>
<h2 id="前提">前提</h2>
<p>这篇文章主要介绍一下日期时间API中最常用的类库，分别是：</p>
<ul>
<li><code>java.time.Clock</code>：时钟。</li>
<li><code>java.time.Instant</code>：瞬时时间，时间戳<code>java.sql.Timestamp</code>的替代类。</li>
<li><code>java.time.LocalDate</code>：本地日期，ISO-8601日历系统下的日期表示，不包含时区的概念，只能表示年月日。</li>
<li><code>java.time.LocalDateTime</code>：本地日期时间，ISO-8601日历系统下的日期时间表示，不包含时区的概念，只能表示年月日时分秒。</li>
<li><code>java.time.LocalTime</code>：本地时间，ISO-8601日历系统下的时间表示，不包含时区的概念，只能表示时分秒。</li>
<li><code>java.time.OffsetTime</code>：带有时间偏移量的时间，ISO-8601日历系统下的带有UTC/GMT时间偏移量的时间表示。</li>
<li><code>java.time.OffsetDateTime</code>：带有时间偏移量的日期时间，ISO-8601日历系统下的带有UTC/GMT时间偏移量(不包含基于ZoneRegion的时间偏移量)的日期时间表示。</li>
<li><code>java.time.ZonedDateTime</code>：带有时间偏移量的日期时间，ISO-8601日历系统下的带有UTC/GMT时间偏移量(包含基于ZoneRegion的时间偏移量)的日期时间表示。</li>
</ul>
<p>其他的类库还有<code>Year</code>、<code>Month</code>、<code>DayOfWeek</code>、<code>MonthDay</code>、<code>YearMonth</code>等。值得注意的是：JSR-310增加的日期API是严格区分年月日-时分秒格式的日期表示类，例如XXXDateTime一定表示为年月日时分秒，XXXTime只能表示时分秒，XXXDate只能表示年月日。</p>
<p><strong>值得注意的是</strong>：这些新增的日期时间类都是不可变类，每次通过其方法更变或者修改都是返回一个全新的对象，因此它们都是<strong>线程安全</strong>的。</p>
<h2 id="Clock">Clock</h2>
<p><code>java.time.Clock</code>是一个抽象类，它表示时钟，一般情况下，它需要结合时区使用，提供获取当前时刻的功能。<code>Clock</code>主要提供下面四个方法，其他方法都是静态工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用于创建时钟的时区。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ZoneId	<span class="title">getZone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取时钟的当前瞬时对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Instant <span class="title">instant</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取时钟的当前毫秒数值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">millis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前时钟实例的一个新的拷贝时钟实例，并且使用入参作为新时钟实例的时区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Clock <span class="title">withZone</span><span class="params">(ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>
<p>静态工厂方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static Clock systemUTC()</td>
<td style="text-align:center">获取可以返回当前时刻的系统时钟，使用UTC(零)时区进行进行时间转换[SystemClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock systemDefaultZone()</td>
<td style="text-align:center">获取可以返回当前时刻的系统时钟，使用默认时区进行时间转换[SystemClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock system(ZoneId zone)</td>
<td style="text-align:center">获取可以返回当前时刻的系统时钟，使用指定时区ID进行时间转换[SystemClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tickMillis(ZoneId zone)</td>
<td style="text-align:center">获取以整数毫秒返回当前时刻的时钟，使用指定时区ID进行时间转换[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tickSeconds(ZoneId zone)</td>
<td style="text-align:center">获取以整数秒返回当前时刻的时钟，使用指定时区ID进行时间转换[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tickMinutes(ZoneId zone)</td>
<td style="text-align:center">获取以整数分钟返回当前时刻的时钟，使用指定时区ID进行时间转换[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tick(Clock baseClock, Duration tickDuration)</td>
<td style="text-align:center">返回一个以基础时钟和时钟记录基础单位为构造的时钟[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock fixed(Instant fixedInstant, ZoneId zone)</td>
<td style="text-align:center">获得一个始终返回同一时刻的时钟，使用指定时区ID进行时间转换[FixedClock]</td>
</tr>
<tr>
<td style="text-align:center">offset​(Clock baseClock, Duration offsetDuration)</td>
<td style="text-align:center">返回一个以基础时钟和固定时间偏移量为构造的时钟[OffsetClock]</td>
</tr>
</tbody>
</table>
<p><code>java.time.Clock</code>主要有四个实现，它们都是<code>java.time.Clock</code>的内部类，上面的工厂方法创建的实例一定是这四个实现之一：</p>
<ul>
<li><code>SystemClock</code>：总是基于<code>System#currentTimeMillis()</code>返回最新的时间<code>SystemClock.UTC</code>是典型的实现。</li>
<li><code>FixedClock</code>：总是返回相同的瞬时时间，可以认为是一个固定时刻的时钟，通常使用于测试。</li>
<li><code>OffsetClock</code>：基于一个确定的Clock实现，为它添加一个时间偏移量，时间偏移量的单位是<code>Duration</code>。</li>
<li><code>TickClock</code>：基于一个确定的Clock实现，为它添加一个时间偏移量，时间偏移量的单位是纳秒。</li>
</ul>
<p>上面比较难理解的是<code>TickClock</code>，这里举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickClockMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Clock tickMillis = Clock.tickMillis(ZoneId.systemDefault());</span><br><span class="line">		Clock tickSeconds = Clock.tickSeconds(ZoneId.systemDefault());</span><br><span class="line">		System.out.println(tickMillis.millis());</span><br><span class="line">		System.out.println(tickSeconds.millis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">1546010945575</span></span><br><span class="line"><span class="number">1546010945000</span></span><br></pre></td></tr></table></figure>
<p>简单来说，<code>Clock#tickMillis()</code>构造的时钟的计时单位是毫秒，而<code>Clock#tickSeconds()</code>构造的时钟的计时单位是秒(毫秒部分会被截断)，以此类推。</p>
<p><code>FixedClock</code>是一个固定时刻的时钟，<strong>一般用于测试</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedClockMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Clock fixed = Clock.fixed(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(fixed.millis());</span><br><span class="line">		System.out.println(fixed.millis());</span><br><span class="line">		System.out.println(fixed.millis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">1546011492590</span></span><br><span class="line"><span class="number">1546011492590</span></span><br><span class="line"><span class="number">1546011492590</span></span><br></pre></td></tr></table></figure>
<p>最常用的是默认ZoneId下的系统时钟<code>SystemClock</code>和UTC系统时钟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClockMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Clock clock = Clock.systemDefaultZone();</span><br><span class="line">		System.out.println(clock.millis());</span><br><span class="line">		Clock utc = Clock.systemUTC();</span><br><span class="line">		System.out.println(utc.millis());</span><br><span class="line">		System.out.println(System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某个时刻的输出结果</span></span><br><span class="line"><span class="number">1546011686413</span></span><br><span class="line"><span class="number">1546011686413</span></span><br><span class="line"><span class="number">1546011686413</span></span><br></pre></td></tr></table></figure>
<h2 id="Instant">Instant</h2>
<p><code>java.time.Instant</code>字面意思是瞬时时间，它是<code>java.sql.Timestamp</code>的对应类，代表时间线(time-line)上的一个瞬时时间点，准确来说，它内部持有一个long类型的纪元秒属性(seconds)和一个int类型的纳秒属性(nanos，nanos的取值范围是[0,999_999_999])，纪元秒如果为正数，表示该瞬时时间点位于格林威治新纪元<code>1970-01-01T00:00:00Z</code>之后，而纪元秒如果为负数，则表示该瞬时时间点位于格林威治新纪元之前。因此<code>Instant</code>能表示的时间点其实是有上下界的，逻辑上的界限就是<code>1970-01-01T00:00:00Z - 31557014167219200秒</code>到<code>1970-01-01T00:00:00Z + 31556889864403199秒 + 999_999_999纳秒</code>或者表示为<code>Instant#MIN</code>到<code>Instant#MAX</code>，这个范围很大，因此暂时不需要考虑超限的问题。<code>Instant</code>中已经提供了一个公有静态实例用于表示格林威治新纪元，它就是<code>Instant#EPOCH</code>，代表1970-01-01T00:00:00Z这个瞬时时间点。先看一下<code>Instant</code>的常用静态工厂方法(<code>Instant</code>没有公有构造器，必须通过工厂方法构造实例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时刻的瞬时时间点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于时钟实例获取瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于距离新纪元的秒数创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">ofEpochSecond</span><span class="params">(<span class="keyword">long</span> epochSecond)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于距离新纪元的秒数和纳秒创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">ofEpochSecond</span><span class="params">(<span class="keyword">long</span> epochSecond, <span class="keyword">long</span> nanoAdjustment)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于毫秒数创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">ofEpochMilli</span><span class="params">(<span class="keyword">long</span> epochMilli)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于其他日期时间API创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">from</span><span class="params">(TemporalAccessor temporal)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于特定格式字符串创建瞬时时间点，如2007-12-03T10:15:30.00Z</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">parse</span><span class="params">(<span class="keyword">final</span> CharSequence text)</span></span></span><br></pre></td></tr></table></figure>
<p>当然还有其他常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前Instant实例对于不同计时单位的值，见ChronoField</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(TemporalField field)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前Instant实例的纪元秒属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEpochSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前Instant实例的纳秒属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNano</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前Instant实例的毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toEpochMilli</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于TemporalField实例(TemporalField)和新的值调整并且创建一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">with</span><span class="params">(TemporalField field, <span class="keyword">long</span> newValue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当前Instant实例基于TemporalUnit(ChronoUnit)截断并且返回一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">truncatedTo</span><span class="params">(TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 顾名思义，基于一个时间基准单位进行时间量增加，返回一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">plus</span><span class="params">(<span class="keyword">long</span> amountToAdd, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 顾名思义，基于一个时间基准单位进行时间量减少，返回一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">minus</span><span class="params">(<span class="keyword">long</span> amountToSubtract, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 计算当前Instant实例和入参endExclusive基于时间基准单位unit之间的时间量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">until</span><span class="params">(Temporal endExclusive, TemporalUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>举个使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Instant instant = Instant.now();</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.now(Clock.systemDefaultZone());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.ofEpochSecond(<span class="keyword">new</span> Date().toInstant().getEpochSecond());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.ofEpochMilli(System.currentTimeMillis());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.from(Instant.now());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.parse(<span class="string">"2018-12-31T10:15:30.00Z"</span>);</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">261861900</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">291941900</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">0</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">292000000</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">292946400</span></span><br><span class="line">Second:<span class="number">1546251330</span>,Nano:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="LocalDate">LocalDate</h2>
<p><code>java.time.LocalDate</code>代表ISO-8601日历系统中<strong>不包含时区的日期(当然也不包含具体的时间)表示</strong>，例如2007-12-03。<code>LocalDate</code>是一个不可变的日期对象，也就是只能表示日期，通常的表示格式为年-月-日，同时提供其他日期字段的访问，例如一年中的第几日(day-of-year)、星期几(day-of-week)和一年中的第几周(week-of-year)等。不同的<code>LocalDate</code>之间的比较只能通过<code>LocalDate#equals()</code>方法，其他比较操作如<code>==</code>或者<code>hash()</code>方法会产生无法预知的结果。<code>LocalDate</code>提供的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -999999999-01-01</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate MIN = LocalDate.of(Year.MIN_VALUE, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 999999999-12-31</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate MAX = LocalDate.of(Year.MAX_VALUE, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate EPOCH = LocalDate.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>LocalDate</code>的工厂方法比较多，这里只列举部分常用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前日期获取LocalDate实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前日期和时区获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前日期和时钟获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月(枚举)日获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月日获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年和具体该年中的某一日获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">ofYearDay</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> dayOfYear)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于新纪元1970-01-01的偏移天数获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">ofEpochDay</span><span class="params">(<span class="keyword">long</span> epochDay)</span></span></span><br></pre></td></tr></table></figure>
<p><code>LocalDate</code>的实例方法也比较多，这里也列举部分常用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取年份值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取月份值，范围是1-12</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonthValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取月份枚举</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Month <span class="title">getMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例的该年中具体的第几天</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDayOfYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例的具体是星期几</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DayOfWeek <span class="title">getDayOfWeek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 是否闰年</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例月份长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例年份长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期属性修改对应的值返回一个新的LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">with</span><span class="params">(TemporalField field, <span class="keyword">long</span> newValue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期时间基准单位增加对应的值返回一个新的LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">plus</span><span class="params">(<span class="keyword">long</span> amountToAdd, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期时间基准单位减去对应的值返回一个新的LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">minus</span><span class="params">(<span class="keyword">long</span> amountToSubtract, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期时间基准单位计算以入参为endExclusive计算日期或者时间的间隔</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">until</span><span class="params">(Temporal endExclusive, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回基于新纪元年1970-1-1的偏移天数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toEpochDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果入参为LocalDate类型功能和equals一致，否则通过基于纪元年的偏移天数比较</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(ChronoLocalDate other)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 只有年月日三个成员同时相等此方法才返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		localDate = LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		localDate = localDate.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		System.out.println(localDate.equals(LocalDate.of(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">		System.out.println(localDate.toEpochDay());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某天执行的输出结果</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">17897</span></span><br></pre></td></tr></table></figure>
<h2 id="LocalTime">LocalTime</h2>
<p><code>java.time.LocalTime</code>代表ISO-8601日历系统中<strong>不包含时区的时间(当然也不包含具体的日期)表示</strong>，例如10:15:30。<code>LocalTime</code>是一个不可变的时间对象，也就是只能表示时间，通常的表示格式为时:分:秒，也可以包含一个纳秒属性(nano取值范围[0,999999999])，通俗来说，它表示的就是挂钟上所见的时间的描述。同样，不同的<code>LocalTime</code>实例必须通过<code>LocalTime#equals()</code>方法比较。<code>LocalTime</code>提供的静态实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一天的起始时间 - 00:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime MIN</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一天的结束时间 - 23:59:59.999999999</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime MAX</span><br><span class="line"></span><br><span class="line"><span class="comment">// 午夜 - 00:00 其实和MIN是一样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime MIDNIGHT</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中午 - 12:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime NOON</span><br></pre></td></tr></table></figure>
<p><code>LocalTime</code>常用的工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前时间构造LocalTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前时间和时区ID构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前时间和时钟实例构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于小时、分钟(、秒和纳秒)构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于瞬时时间实例和时区ID构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一天当中的具体秒数构造LocalTime实例,secondOfDay范围是[0,24 * 60 * 60 - 1]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">ofSecondOfDay</span><span class="params">(<span class="keyword">long</span> secondOfDay)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一天当中的具体纳秒数构造LocalTime实例,nanoOfDay[0,24 * 60 * 60 * 1,000,000,000 - 1]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">ofNanoOfDay</span><span class="params">(<span class="keyword">long</span> nanoOfDay)</span></span></span><br></pre></td></tr></table></figure>
<p><code>LocalTime</code>常用的实例方法有很多，套路和上面章节提到过的方法类似，这里不啰嗦分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小时值，范围[0,23]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回分钟值，范围[0,59]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回秒数值，范围[0,59]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回纳秒数值，范围[0,999_999_999]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNano</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalTime localTime = LocalTime.now();</span><br><span class="line">		System.out.println(localTime);</span><br><span class="line">		localTime = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line">		System.out.println(localTime);</span><br><span class="line">		localTime = LocalTime.MAX;</span><br><span class="line">		System.out.println(String.format(<span class="string">"Hour:%d,minute:%d,second:%d,nano:%d"</span>, localTime.getHour(),</span><br><span class="line">				localTime.getMinute(), localTime.getSecond(), localTime.getNano()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻下的输出结果</span></span><br><span class="line"><span class="number">00</span>:<span class="number">46</span>:<span class="number">08.845848800</span></span><br><span class="line"><span class="number">23</span>:<span class="number">59</span></span><br><span class="line">Hour:<span class="number">23</span>,minute:<span class="number">59</span>,second:<span class="number">59</span>,nano:<span class="number">999999999</span></span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime">LocalDateTime</h2>
<p><code>java.time.LocalDateTime</code>实际上就是<code>LocalDate</code>和<code>LocalTime</code>的结合版本，代表ISO-8601日历系统中<strong>不包含时区(<code>LocalDateTime</code>不存储时区信息，但是可以使用时区ID构造<code>LocalDateTime</code>实例)的日期时间表示</strong>，例如2007-12-03T10:15:30。<code>LocalDateTime</code>是一个不可变的时间对象，也就是只能表示日期时间，通常的表示格式为年-月日 时:分:秒，也可以包含一个纳秒属性(nano取值范围[0,999999999])。不同的<code>LocalDateTime</code>实例必须通过<code>LocalDateTime#equals()</code>方法比较。<code>LocalDateTime</code>内部持有一个<code>LocalDate</code>实例和一个<code>LocalTime</code>实例。它定义了两个公有的静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime能够表示的最小日期时间，即-999999999-01-01T00:00:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDateTime MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDateTime能够表示的最大日期时间，即999999999-12-31T23:59:59.999999999</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDateTime MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX)</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>常用的静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前日期时间、时区ID、时钟创建LocalDateTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月(枚举)日时分秒纳秒创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDate和LocalTime实例创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于Instant实例和时区ID实例创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于新纪元偏移秒数、纳秒数和时间偏移量创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">ofEpochSecond</span><span class="params">(<span class="keyword">long</span> epochSecond, <span class="keyword">int</span> nanoOfSecond, ZoneOffset offset)</span></span></span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>的实例方法和前面介绍过的类差不多，这里不做详细展开，举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now(ZoneId.systemDefault());</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">		localDateTime = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">		localDateTime = localDateTime.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T17:<span class="number">43</span>:<span class="number">48.260517400</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T17:<span class="number">43</span>:<span class="number">48.260517400</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span>T17:<span class="number">43</span>:<span class="number">48.260517400</span></span><br></pre></td></tr></table></figure>
<h2 id="OffsetTime">OffsetTime</h2>
<p><code>java.time.OffsetTime</code>表示ISO-8601日历系统中带有基于UTC/Greenwich时间偏移量的时间，例如10:15:30+01:00。<code>OffsetTime</code>也是一个不可变的时间对象，通常表示格式为时:分:秒-时间偏移量，当然它也可以包含一个纳秒属性(nano取值范围[0,999999999])。相比<code>LocalTime</code>，它多存储了一个时区时间偏移量(zone offset)属性。<code>OffsetTime</code>的公有静态实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表00:00:00+18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetTime MIN = LocalTime.MIN.atOffset(ZoneOffset.MAX)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表23:59:59.999999999-18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetTime MAX = LocalTime.MAX.atOffset(ZoneOffset.MIN)</span><br></pre></td></tr></table></figure>
<p><code>OffsetTime</code>的常用工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前时间、时区ID、时钟创建OffsetTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalTime实例和时间偏移量创建OffsetTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">of</span><span class="params">(LocalTime time, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于时分秒纳秒和时间偏移量创建OffsetTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于Instant实例和时区ID实例创建OffsetTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		OffsetTime offsetTime = OffsetTime.now();</span><br><span class="line">		System.out.println(offsetTime);</span><br><span class="line">		offsetTime = OffsetTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(offsetTime);</span><br><span class="line">		offsetTime = OffsetTime.of(LocalTime.now(), ZoneOffset.UTC);</span><br><span class="line">		System.out.println(offsetTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//某个时刻下的输出结果如下</span></span><br><span class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">26.263710800</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">26.264713600</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">26.264713600</span>Z</span><br></pre></td></tr></table></figure>
<h2 id="OffsetDateTime">OffsetDateTime</h2>
<p><code>java.time.OffsetDateTime</code>表示ISO-8601日历系统中带有基于UTC/Greenwich时间偏移量的日期时间，例如2007-12-03T10:15:30+01:00。<code>OffsetDateTime</code>也是一个不可变的日期时间对象，通常表示格式为年-月-日 时:分:秒-时间偏移量，当然它也可以包含一个纳秒属性(nano取值范围[0,999999999])。相比<code>LocalDateTime</code>，它多存储了一个时区时间偏移量(zone offset)属性。<code>OffsetDateTime</code>提供的公有静态实例常量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OffsetDateTime能表示的最小的日期时间-999999999-01-01T00:00:00+18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetDateTime MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OffsetDateTime能表示的最大的日期时间999999999-12-31T23:59:59.999999999-18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetDateTime MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN)</span><br></pre></td></tr></table></figure>
<p><code>OffsetDateTime</code>的常用静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前的日期时间、时区ID、时钟创建OffsetDateTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDate实例、LocalTime实例和时间偏移量创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDateTime实例和时间偏移量创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">of</span><span class="params">(LocalDateTime dateTime, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月日时分秒纳秒和时间偏移量创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">of</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于Instant实例和时区ID实例创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		OffsetDateTime offsetDateTime = OffsetDateTime.now();</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line">		offsetDateTime = OffsetDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line">		offsetDateTime = OffsetDateTime.of(LocalDateTime.now(), ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T20:<span class="number">38</span>:<span class="number">03.388846400</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T20:<span class="number">38</span>:<span class="number">03.388846400</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T20:<span class="number">38</span>:<span class="number">03.388846400</span>+<span class="number">08</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="ZonedDateTime">ZonedDateTime</h2>
<p><code>java.time.ZonedDateTime</code>应该是JSR-310中最复杂但是最全面的日期时间类(它的API文档中注释也是最多的，从这点也可以看出它的复杂性)。<code>ZonedDateTime</code>可以简单理解为<code>LocalDateTime</code>，时区ID和一个可处理的<code>ZoneOffset</code>三者的共同实现，或者更简单理解为日期时间、时间偏移量、区域时区等时区规则的多重实现。<code>ZonedDateTime</code>也是一个不可变的日期时间对象，常用的格式为：年-月-日 时:分:秒-时区偏移量-区域，例如2007-12-03T10:15:30+01:00 Europe/Paris。除了包含所有的日期时间属性之外，<code>ZonedDateTime</code>还包含一个纳秒属性(nano取值范围[0,999999999])。<code>ZonedDateTime</code>的常用静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前的日期时间、时区ID和时钟创建ZonedDateTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDate实例、LocalTime实例和时区ID创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDateTime实例和时区ID创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(LocalDateTime localDateTime, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月日时分秒纳秒和时区ID创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDateTime实例、时区ID和候选偏好的时间偏移量创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">ofLocal</span><span class="params">(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">		zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">		zonedDateTime = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的执行结果</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T21:<span class="number">00</span>:<span class="number">03.193242200</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T21:<span class="number">00</span>:<span class="number">03.193242200</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T21:<span class="number">00</span>:<span class="number">03.193242200</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="Year">Year</h3>
<p><code>java.time.Year</code>基于ISO-8601日期系统下表示年份，支持的范围是[-999_999_999,999_999_999]。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YearMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Year year = Year.now();</span><br><span class="line">		System.out.println(year);</span><br><span class="line">		System.out.println(year.isLeap());</span><br><span class="line">		year = Year.of(<span class="number">2016</span>);</span><br><span class="line">		System.out.println(year);</span><br><span class="line">		System.out.println(year.isLeap());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">2019</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="Month">Month</h3>
<p><code>java.time.Month</code>是一个枚举，代表ISO-8601日期系统中的月份。枚举的成员一共有12个，就是JANUARY到DECEMBER一共12个月份的英文大写表示。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonthMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Month month = Month.of(<span class="number">12</span>);</span><br><span class="line">		System.out.println(month);</span><br><span class="line">		month = Month.JANUARY;</span><br><span class="line">		System.out.println(month);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">DECEMBER</span><br><span class="line">JANUARY</span><br></pre></td></tr></table></figure>
<h3 id="DayOfWeek">DayOfWeek</h3>
<p><code>java.time.DayOfWeek</code>是一个枚举，表示一个星期中具体是星期几。枚举成员一共有7个，就是从MONDAY到SUNDAY一共7个指代具体星期几的英文大写表示。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		DayOfWeek dayOfWeek = DayOfWeek.of(<span class="number">1</span>);</span><br><span class="line">		System.out.println(dayOfWeek);</span><br><span class="line">		dayOfWeek = DayOfWeek.SUNDAY;</span><br><span class="line">		System.out.println(dayOfWeek);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">MONDAY</span><br><span class="line">SUNDAY</span><br></pre></td></tr></table></figure>
<h3 id="MonthDay">MonthDay</h3>
<p><code>java.time.MonthDay</code>代表月份和对应月份一共存在的天数，内部维护着整型的属性month和整型的属性day。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonthDayMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		MonthDay monthDay = MonthDay.now();</span><br><span class="line">		System.out.println(monthDay);</span><br><span class="line">		monthDay = MonthDay.of(<span class="number">2</span>, <span class="number">29</span>);</span><br><span class="line">		System.out.println(monthDay);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//某个时刻的输出结果</span></span><br><span class="line">--<span class="number">01</span>-<span class="number">01</span></span><br><span class="line">--<span class="number">02</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure>
<p><code>MonthDay</code>通过静态工厂方法构建实例的时候会判断月份或者天数是否超过实际的限制，如果超限会抛异常。</p>
<h3 id="YearMonth">YearMonth</h3>
<p><code>java.time.YearMonth</code>代表年份和月份，内部维护着整型的属性month和整型的属性month。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YearMonthMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		YearMonth yearMonth = YearMonth.now();</span><br><span class="line">		System.out.println(yearMonth);</span><br><span class="line">		yearMonth = YearMonth.of(<span class="number">2019</span>, <span class="number">12</span>);</span><br><span class="line">		System.out.println(yearMonth);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<p>这里主要总结一下JSR-310的日期时间类之间的转换以及JSR-310的日期时间类和已经存在的旧Java日期时间类之间的转换关系。</p>
<h3 id="Instant和其他日期时间类互转">Instant和其他日期时间类互转</h3>
<p>如果有注意到上面介绍日期时间类的时候会发现每个类的工厂方法都包含<code>ofInstant()</code>方法，也就是<code>Instant</code>实例可以转化为其他日期时间类实例，这里总结一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantConvertTo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Instant instant = Instant.now();</span><br><span class="line">		ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);</span><br><span class="line">		LocalDate localDate = LocalDate.ofInstant(instant, zoneId);</span><br><span class="line">		LocalTime localTime = LocalTime.ofInstant(instant, zoneId);</span><br><span class="line">		OffsetTime offsetTime = OffsetTime.ofInstant(instant, zoneId);</span><br><span class="line">		OffsetDateTime offsetDateTime = OffsetDateTime.ofInstant(instant,zoneId);</span><br><span class="line">		ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实很好理解，即使在旧的Java日期时间API中，长整型的时间戳毫秒也可以通过各种日期时间类的构造或者静态工厂方法创建对应的实例。值得注意的是，只有同时包含日期和时间的类才能转换为<code>Instant</code>实例，这一点也很好理解，只包含时间或者只包含日期的类转换成瞬时时间会丢失部分时间值。这里举个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantConvertFrom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 这里只以LocalDateTime为例,其他类似</span></span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		Instant instant = localDateTime.toInstant(ZoneOffset.UTC);</span><br><span class="line">		<span class="comment">// 或者</span></span><br><span class="line">		instant = Instant.ofEpochMilli(localDateTime.toEpochSecond(ZoneOffset.UTC) * <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSR-310日期时间类之间互相转换">JSR-310日期时间类之间互相转换</h3>
<p>日期时间类本身就包含日期和时间的维度，一般它们直接保存时间类实例作为成员属性，所以转换也十分方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeToTime</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">		LocalTime localTime = localDateTime.toLocalTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日期类不包含时间部分，所以日期类转换为日期时间类的时候，时间部分会取最小，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateToDateTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		LocalDateTime localDateTime = localDate.atStartOfDay();</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">		ZonedDateTime zonedDateTime = localDate.atStartOfDay(ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">00</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<p>带有时区ID(时间偏移量或者地区)的类型可以轻易转变为不带有时区ID的类型，如果要反过来，则需要添加对应的时区ID属性，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">		LocalDateTime localDateTime = zonedDateTime.toLocalDateTime();</span><br><span class="line">		LocalDate localDate = zonedDateTime.toLocalDate();</span><br><span class="line">		LocalTime localTime = zonedDateTime.toLocalTime();</span><br><span class="line">		zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.systemDefault());</span><br><span class="line"></span><br><span class="line">		OffsetDateTime offsetDateTime = OffsetDateTime.of(LocalDateTime.now(), ZoneOffset.UTC);</span><br><span class="line">		localDateTime = offsetDateTime.toLocalDateTime();</span><br><span class="line">		localDate = offsetDateTime.toLocalDate();</span><br><span class="line">		localTime = offsetDateTime.toLocalTime();</span><br><span class="line">		offsetDateTime = OffsetDateTime.of(localDateTime, ZoneOffset.UTC);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSR-310中的类和旧的日期时间相关类之间的转换">JSR-310中的类和旧的日期时间相关类之间的转换</h3>
<p><code>java.sql.Timestamp</code>和<code>java.time.LocalDateTime</code>之间的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampLocalDateTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		Timestamp timestamp = Timestamp.valueOf(localDateTime);</span><br><span class="line">		LocalDateTime ldt = timestamp.toLocalDateTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.sql.Date</code>和<code>java.time.LocalDate</code>之间的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateLocalDate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		LocalDate localDate = date.toLocalDate();</span><br><span class="line">		date = <span class="keyword">new</span> Date(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要是能使用毫秒表示的旧的日期时间类，都可以和<code>java.time.Instant</code>相互转换，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToInstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Timestamp timestamp = <span class="keyword">new</span> Timestamp(System.currentTimeMillis());</span><br><span class="line">		Instant instant = timestamp.toInstant();</span><br><span class="line">		java.util.Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">		instant = date.toInstant();</span><br><span class="line">		timestamp = <span class="keyword">new</span> Timestamp(instant.toEpochMilli());</span><br><span class="line">		date = <span class="keyword">new</span> Date(instant.toEpochMilli());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>JSR-310的新时间日期类库的设计相比已经存在的旧的日期时间类库来说，个人认为有以下的优点：</p>
<ul>
<li>线程安全。</li>
<li>类的职责更加分明，时间、日期、日期时间需要使用明确的类去表示。</li>
<li>API封装更加合理，使得易用性提高。</li>
</ul>
<p>不过会存在一些问题，最明显的是已有的旧类库存在兼容性问题，例如JDBC模块里面处理日期时间需要进行新的日期时间类和<code>java.sql.Timestamp</code>进行转换的问题，不过转换成本并不高。</p>
<p>(本文完 c-3-d e-a-20181230)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/23/java-jsr310-zone-id/">
      JSR310新日期API(一)-时区与时间偏移量
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月23日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.2k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：12分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-01T22:04:05+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(一)-时区与时间偏移量</h1>
<h2 id="前提">前提</h2>
<p>最近刚好有新项目使用到JSR-310(JDK8)中引入的新日期API，打算做一下总结。本文编写基于JDK11，部分API可能是JDK9之后新增的。</p>
<h2 id="地理知识补充">地理知识补充</h2>
<p>主要补充一下一些地理知识：时区、UTC、GMT、CST、DST和ISO-8601的相关概念。</p>
<h3 id="时区">时区</h3>
<p>时区(Time Zone)是地球上的区域使用同一个时间定义。1884年在华盛顿召开国际经度会议时，为了克服时间上的混乱，规定将全球划分为24个时区。造成时间上的混乱是由于世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差(<strong>这个偏差我们通常叫做时差</strong>)。</p>
<p>前边提到全球共分为24个时区(<strong>东、西各12个时区</strong>)，也就是每个时区的经度宽度为15度，其中本初子午线(0度经线)为0时区的中心线，而东、西12时区合并为一个时区，这些时区的经度分布如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时区</th>
<th style="text-align:center">时区经度范围</th>
<th style="text-align:center">时区中心线</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UTC(0时区)</td>
<td style="text-align:center">7.5°W~7.5°E</td>
<td style="text-align:center">0°</td>
</tr>
<tr>
<td style="text-align:center">UTC+1(东1区)</td>
<td style="text-align:center">7.5°E~22.5°E</td>
<td style="text-align:center">15°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+2(东2区)</td>
<td style="text-align:center">22.5°E~37.5°E</td>
<td style="text-align:center">30°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+3(东3区)</td>
<td style="text-align:center">37.5°E~52.5°E</td>
<td style="text-align:center">45°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+4(东4区)</td>
<td style="text-align:center">52.5°E~67.5°E</td>
<td style="text-align:center">60°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+5(东5区)</td>
<td style="text-align:center">67.5°E~82.5°E</td>
<td style="text-align:center">75°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+6(东6区)</td>
<td style="text-align:center">82.5°E~97.5°E</td>
<td style="text-align:center">90°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+7(东7区)</td>
<td style="text-align:center">97.5°E~112.5°E</td>
<td style="text-align:center">105°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+8(东8区)</td>
<td style="text-align:center">112.5°E~127.5°E</td>
<td style="text-align:center">120°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+9(东9区)</td>
<td style="text-align:center">127.5°E~142.5°E</td>
<td style="text-align:center">135°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+10(东10区)</td>
<td style="text-align:center">142.5°E~157.5°E</td>
<td style="text-align:center">150°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+11(东11区)</td>
<td style="text-align:center">157.5°E~172.5°E</td>
<td style="text-align:center">165°E</td>
</tr>
<tr>
<td style="text-align:center">UTC12(东、西12区)</td>
<td style="text-align:center">172.5°E~172.5°W</td>
<td style="text-align:center">180°</td>
</tr>
<tr>
<td style="text-align:center">UTC-11(西11区)</td>
<td style="text-align:center">172.5°W~157.5°W</td>
<td style="text-align:center">165°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-10(西10区)</td>
<td style="text-align:center">157.5°W~142.5°W</td>
<td style="text-align:center">150°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-9(西9区)</td>
<td style="text-align:center">142.5°W~127.5°W</td>
<td style="text-align:center">135°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-8(西8区)</td>
<td style="text-align:center">127.5°W~112.5°W</td>
<td style="text-align:center">120°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-7(西7区)</td>
<td style="text-align:center">112.5°W~97.5°W</td>
<td style="text-align:center">105°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-6(西6区)</td>
<td style="text-align:center">97.5°W~82.5°W</td>
<td style="text-align:center">90°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-5(西5区)</td>
<td style="text-align:center">82.5°W~67.5°W</td>
<td style="text-align:center">75°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-4(西4区)</td>
<td style="text-align:center">67.5°W~52.5°W</td>
<td style="text-align:center">60°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-3(西3区)</td>
<td style="text-align:center">52.5°W~37.5°W</td>
<td style="text-align:center">45°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-2(西2区)</td>
<td style="text-align:center">37.5°W~22.5°W</td>
<td style="text-align:center">30°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-1(西1区)</td>
<td style="text-align:center">22.5°W~7.5°W</td>
<td style="text-align:center">15°W</td>
</tr>
</tbody>
</table>
<p>但是实际上，通常1个国家或1个省份同时跨着多个时区，是因为为了照顾到行政上的方便，常将1个国家或1个省份划在同一个时区。例如，中国跨5个时区，但为了使用方便简单并且全国统一使用一个区时，实际上在中国使用东8区的区时一般称为北京时间作为标准时间。全球的标准时区划分如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/Standard_World_Time_Zones.png" alt="Standard_World_Time_Zones"></p>
<h3 id="UTC、GMT、CST、DST与ISO-8601">UTC、GMT、CST、DST与ISO-8601</h3>
<p><strong>GMT</strong>，Greenwich Mean Time，格林尼治(或者有时候翻译为格林威治)标准时间，是指位于伦敦郊区的皇家格林尼治天文台的标准时间。<strong>格林尼治所在地的标准时间也叫世界时UT</strong>。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点(见分至点)和平太阳，由此确定的时间分别称为恒星时和平太阳时。对于世界上发生的重大事件，都以格林尼治的地方时间记录下来。一旦知道了格林尼治时间，人们就很容易推算出相对应的本地时间。指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。 格林威治子午线上的地方时，或零时区（中时区）的区时叫做格林威治时间(又译为&quot;格林尼治时间&quot;)，也叫&quot;世界时&quot;。原是采用格林威治的平正午作为一个平太阳日的开始，但在使用中有些不便。因此，国际天文学联合会于1928年决定，将由格林威治平子夜起算的平太阳时作为世界时，也就是通常所说的<strong>格林威治时间</strong>。格林威治时间所在时区为0时区，可以推算出使用GMT+8表示中国的时间，是因为中国位于东八区，时间上比格林威治时间快8个小时。</p>
<p><strong>UTC</strong>，Coordinated Universal Time，也就是协调世界时，由于英文(CUT)和法文(TUC)的缩写不同，作为妥协，简称UTC。协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统(<strong>由实验室用足够精确的铯原子钟导出的时间作为原子时，原子时的精确度极高，精度可以达到每2000万年才误差1秒</strong>)。国际原子时的准确度为每日数纳秒，而世界时的准确度为每日数毫秒。许多应用部门要求时间系统接近世界时UT，对于这种情况，一种称为协调世界时的折衷时标于1972年面世。为确保协调世界时与世界时相差不会超过0.9秒，在有需要的情况下会在协调世界时内加上正或负闰秒。因此协调世界时与国际原子时之间会出现若干整数秒的差别，两者之差逐年积累，便采用跳秒(闰秒)的方法使协调时与世界时的时刻相接近，其差不超过1s。<strong>通常将GMT和UTC视作等同</strong>，但UTC更加科学更加精确，它是以原子时为基础，在时刻上尽量接近世界时的一种时间计量系统。类似的，可以使用UTC+8表示中国的时间。</p>
<p><strong>CST</strong>，China Standard Time，也就是中国标准时间，当格林威治时间为凌晨0:00时，中国标准时间正好为上午8:00，也就是CST实际上是参照于UTC，通用公式为：CST = UTC/GMT +8。</p>
<p><strong>DST</strong>，Daylight Saving Time，阳光节约时，在我国称为夏时制，又称夏令时，是一种为节约能源而人为调整地方时间的制度。有些国家DST的使用时间较长，(如美国长达7个月)跨越了春夏秋等三个季节，因此简单地用夏时制的概念已经不能完全表达DST的确切含义了，所以有人也称其为节能时。所谓的DST，就是利用夏季天亮得早这一自然现象，人为地将时间提前一小时。这样就可以使人们早起早睡，以充分利用光照资源，减少照明时间，从而节约照明用电。目前中国已经弃用DST。</p>
<p><strong>ISO-8601</strong>，是国际标准化组织的日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是2004年12月1日发行的第三版&quot;ISO8601:2004&quot;以替代1998年的第一版&quot;ISO8601:1988&quot;与2000年的第二版&quot;ISO8601:2000&quot;。该表示方法规定：年由4位数字组成YYYY，或者带正负号的四或五位数字表示±YYYYY，月、日用两位数字表示：MM、DD。只使用数字为基本格式。使用短横线&quot;-“间隔开年、月、日为扩展格式。时间只使用数字为基本格式。使用冒号”:&quot;间隔开小时、分、秒的为扩展格式。小时、分和秒都用2位数表示。合并表示时，要在时间前面加一大写字母T，如要表示北京时间2004年5月3日下午5点30分8秒，可以写成2004-05-03T17:30:08+08:00或20040503T173008+08。如果时间在零时区，并恰好与协调世界时相同，那么(不加空格地)在时间最后加一个大写字母Z。Z是相对协调世界时时间0偏移的代号。如下午2点30分5秒表示为14:30:05Z或143005Z；只表示小时和分，为1430Z或14:30Z；只表示小时，则为14Z或14Z。其他时区用实际时间加时差表示，当时的UTC+8时间表示为22:30:05+08:00或223005+0800，也可以简化成223005+08。Java中已存在的类<code>java.util.Date</code>默认就是使用ISO-8601表示的。</p>
<h2 id="ZoneId">ZoneId</h2>
<p>JSR-310中引入了抽象类<code>java.time.ZoneId</code>表示时区ID，它是旧API<code>java.util.TimeZone</code>的替代。<code>ZoneRulesProvider</code>用于加载Zone Rule(时区规则，ZoneRules)，自定义实现是可以通过系统变量设置<code>java.time.zone.DefaultZoneRulesProvider=全类名</code>为<code>ZoneRulesProvider</code>自定义的提供类，或者通过SPI加载，默认的实现类是<code>TzdbZoneRulesProvider</code>，<code>TzdbZoneRulesProvider</code>会加载${JAVA_HONE}/lib/tzdb.dat文件(可以打开这个文件看下里面是怎么定义和描述时区的相应规则，这里不做详细分析，实际上如果深入了解这个规则文件的定义可以自行编写规则文件和实现加载类加载自定义的规则)，这个DAT文件中存放着时区的规则映射。<code>ZoneId</code>就是时区ID主要用于定制<code>Instant</code>和<code>LocalDateTime</code>之间的转换规则的。时区ID一共有两种不同的类型：</p>
<ul>
<li>固定时间偏移量(Fixed Offset) - 实际上对应<code>ZoneOffset</code>。</li>
<li>地理区域(Geographical Region) - 实际上对应<code>ZoneRegion</code>。</li>
</ul>
<p>静态方法<code>ZoneId#of(String zoneId)</code>会根据入参自动适配最终的时区ID到底表示固定时间偏移量还是地理区域，此方法支持如下的参数：</p>
<ul>
<li>
<p>地理区域参数，形式是：洲(州、国家)/城市，如<code>ZoneId.of(&quot;Asia/Shanghia&quot;)</code>，值得注意的是默认加载的规则里面没有北京。</p>
</li>
<li>
<p>固定时间偏移量格式(offset-style)，支持的格式比较多：</p>
<ul>
<li>UTC或者GMT。</li>
<li>Z(相当于UTC)。</li>
<li>+h或者-h。</li>
<li>+hh或者-hh。</li>
<li>+hh:mm或者-hh:mm。</li>
<li>+hh:mm:ss或者-hh:mm:ss。</li>
<li>+hhmmss或者-hhmmss。</li>
</ul>
</li>
</ul>
<p>基于固定时间偏移量格式举几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZoneId z;</span><br><span class="line">z = ZoneId.of(<span class="string">"Z"</span>); <span class="comment">//for UTC</span></span><br><span class="line">z = ZoneId.of(<span class="string">"+02:00"</span>);</span><br><span class="line">z = ZoneId.of(<span class="string">"-02:00"</span>);</span><br><span class="line"></span><br><span class="line">ZoneId.of(<span class="string">"GMT+2"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"UTC"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"UT+01:00"</span>);</span><br><span class="line"></span><br><span class="line">ZoneId.of(<span class="string">"Asia/Aden"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"Etc/GMT+9"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"Asia/Aqtau"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="固定时间偏移量-ZoneOffset">固定时间偏移量-ZoneOffset</h3>
<p><code>java.time.ZoneOffset</code>是<code>java.time.ZoneId</code>实现类，表示固定时间偏移量，这个偏移量是以格林尼治(GMT)/协调世界时(UTC)为基准的偏移时间量。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneOffsetMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+02:00"</span>);</span><br><span class="line">		System.out.println(zoneOffset);</span><br><span class="line">		zoneOffset = ZoneOffset.of(<span class="string">"-02:00"</span>);</span><br><span class="line">		System.out.println(zoneOffset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ZoneOffset.of(&quot;+02:00&quot;)</code>表示UTC下2小时的时间偏移(简单理解为东2区)，<code>ZoneOffset.of(&quot;-02:00&quot;)</code>表示UTC下-2小时的时间偏移(简单理解为西2区)。</p>
<h3 id="地理区域-ZoneRegion">地理区域-ZoneRegion</h3>
<p><code>java.time.ZoneRegion</code>是<code>java.time.ZoneId</code>实现类(不过其修饰符为default，因此无法直接访问，只能通过<code>ZoneId</code>操作)，表示地理区域，格式是：洲(州、国家)/城市。注释中提到：最常见的区域分类是时区数据库(TZDB)，TZDB使用Europe/Paris’和’Asia/Tokyo’等形式区分地区。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneRegionMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">		System.out.println(zoneId);</span><br><span class="line">		Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">		<span class="keyword">for</span> (String z : availableZoneIds) &#123;</span><br><span class="line">			<span class="keyword">if</span> (z.contains(<span class="string">"Beijing"</span>) || z.contains(<span class="string">"BeiJing"</span>)) &#123;</span><br><span class="line">				System.out.println(z);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后控制台输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>实际上，执行这个方法的时候，笔者在广州，得到的系统默认zoneId是Asia/Shanghai，并且默认加载的地理区域中没有北京相关的zoneId。</p>
<h2 id="小结">小结</h2>
<p>JSR-310中引入的时间API类<code>ZoneId</code>表示时区ID，具体有两种类型：固定时间偏移量-<code>ZoneOffset</code>和地理区域-<code>ZoneRegion</code>，这两种类型可以再细分为三种表示方式：</p>
<ul>
<li>地理区域表示，如：<code>ZoneId.of(&quot;Asia/Aden&quot;)</code>。</li>
<li>GMT/UTC偏移量详细表示，如：<code>ZoneId.of(&quot;UTC&quot;)</code>、<code>ZoneId.of(&quot;GMT+2&quot;)</code>。</li>
<li>GMT/UTC偏移量简单表示，如：<code>ZoneId.of(&quot;Z&quot;)</code>、<code>ZoneId.of(&quot;+2:00&quot;)</code>。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Time_zone" target="_blank" rel="noopener">维基百科-Time zone</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">维基百科-ISO 8601</a></li>
<li>Bing互动百科相关资料</li>
<li><a href="https://stackoverflow.com/questions/32931871/java-8-how-to-derive-a-zoneid-from-zoneoffset" target="_blank" rel="noopener">Java 8: how to derive a ZoneId from ZoneOffset</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 c-1-d e-a-20181223)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/java-reflection-optimal-performance/">
      深入分析Java反射(八)-优化反射调用性能
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：8分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T12:01:22+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(八)-优化反射调用性能</h1>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>前一篇文章已经介绍了反射调用的底层原理，其实在实际中对大多数Java使用者来说更关系的是如何提升反射调用的性能，本文主要提供几个可行的方案。另外，由于方法调用时频率最高的反射操作，会着重介绍方法的反射调用优化。</p>
<h2 id="方法一：选择合适的API">方法一：选择合适的API</h2>
<p>选择合适的API主要是在获取反射相关元数据的时候尽量避免使用遍历的方法，例如：</p>
<ul>
<li>获取Field实例：尽量避免频繁使用<code>Class#getDeclaredFields()</code>或者<code>Class#getFields()</code>，应该根据Field的名称直接调用<code>Class#getDeclaredField()</code>或者<code>Class#getField()</code>。</li>
<li>获取Method实例：尽量避免频繁使用<code>Class#getDeclaredMethods()</code>或者<code>Class#getMethods()</code>，应该根据Method的名称和参数类型数组调用<code>Class#getDeclaredMethod()</code>或者<code>Class#getMethod()</code>。</li>
<li>获取Constructor实例：尽量避免频繁使用<code>Class#getDeclaredConstructors()</code>或者<code>Class#getConstructors()</code>，应该根据Constructor参数类型数组调用<code>Class#getDeclaredConstructor()</code>或者<code>Class#getConstructor()</code>。</li>
</ul>
<p>其实思路很简单，除非我们想要获取Class的所有Field、Method或者Constructor，否则应该避免使用返回一个集合或者数组的API，这样子能减少遍历或者判断带来的性能损耗。</p>
<h2 id="方法二：缓存反射操作相关元数据">方法二：缓存反射操作相关元数据</h2>
<p>使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的，这里列举几个相对耗时的场景：</p>
<ul>
<li>获取Class实例：<code>Class#forName()</code>，此方法可以查看源码，耗时相对其他方法高得多。</li>
<li>获取Field实例：<code>Class#getDeclaredField()</code>、<code>Class#getDeclaredFields()</code>、<code>Class#getField()</code>、<code>Class#getFields()</code>。</li>
<li>获取Method实例：<code>Class#getDeclaredMethod()</code>、<code>Class#getDeclaredMethods()</code>、<code>Class#getMethod()</code>、<code>Class#getMethods()</code>。</li>
<li>获取Constructor实例：<code>Class#getDeclaredConstructor()</code>、<code>Class#getDeclaredConstructors()</code>、<code>Class#getConstructor()</code>、<code>Class#getConstructors()</code>。</li>
</ul>
<p>这里举个简单的例子，需要反射调用一个普通JavaBean的Setter和Getter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;ReflectionMetadata&gt;&gt; METADATA = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; CLASSES = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析的时候尽量放在&lt;cinit&gt;里面</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = JavaBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		CLASSES.put(clazz.getName(), clazz);</span><br><span class="line">		List&lt;ReflectionMetadata&gt; metadataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		METADATA.put(clazz, metadataList);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (Field f : clazz.getDeclaredFields()) &#123;</span><br><span class="line">				ReflectionMetadata metadata = <span class="keyword">new</span> ReflectionMetadata();</span><br><span class="line">				metadataList.add(metadata);</span><br><span class="line">				metadata.setTargetClass(clazz);</span><br><span class="line">				metadata.setField(f);</span><br><span class="line">				String name = f.getName();</span><br><span class="line">				Class&lt;?&gt; type = f.getType();</span><br><span class="line">				metadata.setReadMethod(clazz.getDeclaredMethod(String.format(<span class="string">"get%s%s"</span>, Character.toUpperCase(name.charAt(<span class="number">0</span>)), name.substring(<span class="number">1</span>))));</span><br><span class="line">				metadata.setWriteMethod(clazz.getDeclaredMethod(String.format(<span class="string">"set%s%s"</span>, Character.toUpperCase(name.charAt(<span class="number">0</span>)), name.substring(<span class="number">1</span>)), type));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String fieldName = <span class="string">"name"</span>;</span><br><span class="line">		Class&lt;JavaBean&gt; javaBeanClass = JavaBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		JavaBean javaBean = <span class="keyword">new</span> JavaBean();</span><br><span class="line">		invokeSetter(javaBeanClass, javaBean, fieldName , <span class="string">"Doge"</span>);</span><br><span class="line">		System.out.println(invokeGetter(javaBeanClass,javaBean, fieldName));</span><br><span class="line">		invokeSetter(javaBeanClass.getName(), javaBean, fieldName , <span class="string">"Throwable"</span>);</span><br><span class="line">		System.out.println(invokeGetter(javaBeanClass.getName(),javaBean, fieldName));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeSetter</span><span class="params">(String className, Object target, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		METADATA.get(CLASSES.get(className)).forEach(each -&gt; &#123;</span><br><span class="line">			Field field = each.getField();</span><br><span class="line">			<span class="keyword">if</span> (field.getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					each.getWriteMethod().invoke(target, value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeSetter</span><span class="params">(Class&lt;?&gt; clazz, Object target, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		METADATA.get(clazz).forEach(each -&gt; &#123;</span><br><span class="line">			Field field = each.getField();</span><br><span class="line">			<span class="keyword">if</span> (field.getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					each.getWriteMethod().invoke(target, value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invokeGetter</span><span class="params">(String className, Object target, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ReflectionMetadata metadata : METADATA.get(CLASSES.get(className))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.getField().getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> metadata.getReadMethod().invoke(target);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invokeGetter</span><span class="params">(Class&lt;?&gt; clazz, Object target, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ReflectionMetadata metadata : METADATA.get(clazz)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.getField().getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> metadata.getReadMethod().invoke(target);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Class&lt;?&gt; targetClass;</span><br><span class="line">		<span class="keyword">private</span> Field field;</span><br><span class="line">		<span class="keyword">private</span> Method readMethod;</span><br><span class="line">		<span class="keyword">private</span> Method writeMethod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，解析反射元数据进行缓存的操作最好放在静态代码块或者首次调用的时候(也就是懒加载)，这样能够避免真正调用的时候总是需要重新加载一次反射相关元数据。</p>
<h2 id="方法三：反射操作转变为直接调用">方法三：反射操作转变为直接调用</h2>
<p>&quot;反射操作转变为直接调用&quot;并不是完全不依赖于反射的类库，这里的做法是把反射操作相关元数据直接放置在类的成员变量中，这样就能省去从缓存中读取反射相关元数据的消耗，而所谓&quot;直接调用&quot;一般是通过继承或者实现接口实现。有一些高性能的反射类库也会使用一些创新的方法：例如使用成员属性缓存反射相关元数据，并且把方法调用通过数字建立索引[Number-&gt;Method]或者建立索引类(像<code>CGLIB</code>的<code>FastClass</code>)，<strong>这种做法在父类或者接口方法比较少的时候会有一定的性能提升，但是实际上性能评估需要从具体的场景通过测试分析结果而不能盲目使用</strong>，使用这个思想的类库有<code>CGLIB</code>、<code>ReflectASM</code>等。&quot;反射操作转变为直接调用&quot;的最典型的实现就是JDK的动态代理，这里翻出之前动态代理那篇文章的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的话<code>Simple</code>接口实例虽然最终是通过反射调用<code>sayHello(String var1)</code>方法，但是相关元数据在静态代码块中创建并且已经缓存在类成员属性中，那么反射调用方法的性能已经优化到极致，剩下的都只是Native方法的耗时，这一点使用者在编码层面已经没有办法优化，只能通过升级JVM(JDK)、使用JIT编译器等非编码层面的手段提升反射性能。</p>
<h2 id="小结">小结</h2>
<p>本文主要从编码层面分析反射操作一些性能优化的可行经验或者方案，或许有其他更好的优化方案，具体还是需要看使用场景。</p>
<p>(本文完 e-a-20181216 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/java-reflection-implementance/">
      深入分析Java反射(七)-简述反射调用的底层实现
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：14分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T01:09:52+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(七)-简述反射调用的底层实现</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射调用的底层实现，当然还没有能力分析JVM的实现，这里只分析到最终Native方法的调用点。底层会依赖到Unsafe类，可以的话可以看下笔者之前写的一篇文章《神奇的魔法类和双刃剑-Unsafe》。</p>
<h2 id="反射调用的底层实现探究">反射调用的底层实现探究</h2>
<p>主要考虑下面的情况：</p>
<ul>
<li>属性操作：<code>java.lang.reflect.Field#set(Object obj, Object value)</code>和<code>java.lang.reflect.Field#get(Object obj)</code>。</li>
<li>构造器调用：<code>java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>。</li>
<li>方法调用：<code>java.lang.reflect.Method#invoke(Object obj, Object... args)</code>。</li>
</ul>
<h3 id="处理属性操作的底层实现">处理属性操作的底层实现</h3>
<p>属性操作方法<code>Field#set(Object obj, Object value)</code>和<code>Field#get(Object obj)</code>底层都是委托到<code>jdk.internal.reflect.FieldAccessor</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FieldAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setByte</span><span class="params">(Object obj, <span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChar</span><span class="params">(Object obj, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShort</span><span class="params">(Object obj, <span class="keyword">short</span> s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(Object obj, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FieldAccessor</code>接口有很多的实现，<code>FieldAccessor</code>接口实例是通过<code>jdk.internal.reflect.ReflectionFactory</code>这个工厂构造的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field field, <span class="keyword">boolean</span> override)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    Field root = langReflectAccess.getRoot(field);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// FieldAccessor will use the root unless the modifiers have</span></span><br><span class="line">        <span class="comment">// been overrridden</span></span><br><span class="line">        <span class="keyword">if</span> (root.getModifiers() == field.getModifiers() || !override) &#123;</span><br><span class="line">            field = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UnsafeFieldAccessorFactory.newFieldAccessor(field, override);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终委托到<code>UnsafeFieldAccessorFactory#newFieldAccessor()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeFieldAccessorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field field, <span class="keyword">boolean</span> override)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; type = field.getType();</span><br><span class="line">        <span class="keyword">boolean</span> isStatic = Modifier.isStatic(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isFinal = Modifier.isFinal(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isVolatile = Modifier.isVolatile(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isQualified = isFinal || isVolatile;</span><br><span class="line">        <span class="keyword">boolean</span> isReadOnly = isFinal &amp;&amp; (isStatic || !override);</span><br><span class="line">        <span class="keyword">if</span> (isStatic) &#123;</span><br><span class="line">            <span class="comment">// This code path does not guarantee that the field's</span></span><br><span class="line">            <span class="comment">// declaring class has been initialized, but it must be</span></span><br><span class="line">            <span class="comment">// before performing reflective operations.</span></span><br><span class="line">            UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(field.getDeclaringClass());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isQualified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticBooleanFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticByteFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticShortFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticCharacterFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticIntegerFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticLongFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticFloatFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticDoubleFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticObjectFieldAccessorImpl(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticBooleanFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticByteFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticShortFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticCharacterFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticIntegerFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticLongFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticFloatFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticDoubleFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticObjectFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isQualified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeBooleanFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeByteFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeShortFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeCharacterFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeIntegerFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeLongFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeFloatFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeDoubleFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeObjectFieldAccessorImpl(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedBooleanFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedByteFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedShortFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedCharacterFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedIntegerFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedLongFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedFloatFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedDoubleFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedObjectFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意一下属性修饰符的判断：</p>
<ul>
<li>isStatic：静态属性，也就是static关键字修饰的属性。</li>
<li>isFinal：final关键字修饰的属性。</li>
<li>isVolatile：valatile关键字修饰的属性。</li>
<li>isQualified：valatile关键字或者final关键字修饰的属性。</li>
<li>isReadOnly：是否只读属性，final关键字修饰的属性或者static关键字修饰并且不能覆盖(override = false)的属性。</li>
</ul>
<p>通过上面修饰符做判断，得到最终的<code>FieldAccessor</code>实现。这里挑一个例子进行分析，例如<strong>一个普通非静态没有volatile和final关键字修饰属性</strong>最终就会得到<code>UnsafeObjectFieldAccessorImpl</code>的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeObjectFieldAccessorImpl</span> <span class="keyword">extends</span> <span class="title">UnsafeFieldAccessorImpl</span> </span>&#123;</span><br><span class="line">    UnsafeObjectFieldAccessorImpl(Field field) &#123;</span><br><span class="line">        <span class="keyword">super</span>(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ensureObj(obj);</span><br><span class="line">        <span class="keyword">return</span> unsafe.getObject(obj, fieldOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>&#123;</span><br><span class="line">        ensureObj(obj);</span><br><span class="line">        <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">            throwFinalFieldIllegalAccessException(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!field.getType().isAssignableFrom(value.getClass())) &#123;</span><br><span class="line">                throwSetIllegalArgumentException(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.putObject(obj, fieldOffset, value);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> newGetBooleanIllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> newGetByteIllegalArgumentException();</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他直接抛出异常的方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>UnsafeObjectFieldAccessorImpl</code>中除了<code>get(Object obj)</code>和<code>set(Object obj, Object value)</code>方法，其他方法都是直接抛出IllegalArgumentException。而<code>get(Object obj)</code>和<code>set(Object obj, Object value)</code>底层分别依赖于<code>jdk.internal.misc.Unsafe</code>的<code>putObject(obj, fieldOffset, value)</code>和<code>getObject(obj, fieldOffset)</code>方法。而属性的内存偏移地址是在<code>UnsafeObjectFieldAccessorImpl</code>的父类<code>UnsafeFieldAccessorImpl</code>的构造函数中计算出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFieldAccessorImpl</span> <span class="keyword">extends</span> <span class="title">FieldAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Field   field;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span>    fieldOffset;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFinal;</span><br><span class="line"></span><br><span class="line">    UnsafeFieldAccessorImpl(Field field) &#123;</span><br><span class="line">        <span class="keyword">this</span>.field = field;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers()))</span><br><span class="line">            fieldOffset = unsafe.staticFieldOffset(field);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fieldOffset = unsafe.objectFieldOffset(field);</span><br><span class="line">        isFinal = Modifier.isFinal(field.getModifiers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以做个小结，属性反射操作<code>Field</code>的<code>setXX</code>和<code>getXX</code>方法最终委托到<code>jdk.internal.misc.Unsafe</code>的<code>putXX</code>和<code>getXX</code>方法，而属性的内存偏移地址是通过<code>jdk.internal.misc.Unsafe</code>的<code>staticFieldBase()</code>、<code>staticFieldOffset</code>和<code>objectFieldOffset</code>几个方法计算的。</p>
<h3 id="处理构造器调用的底层实现">处理构造器调用的底层实现</h3>
<p><code>Constructor#newInstance()</code>方法调用依赖到<code>ConstructorAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, clazz, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConstructorAccessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstructorAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Constructor&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而获取<code>ConstructorAccessor</code>实例也是通过反射工厂类<code>ReflectionFactory</code>，具体是<code>ReflectionFactory#newConstructorAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConstructorAccessor <span class="title">newConstructorAccessor</span><span class="params">(Constructor&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Class&lt;?&gt; declaringClass = c.getDeclaringClass();</span><br><span class="line">    <span class="comment">// 抽象方法会进入此if分支</span></span><br><span class="line">    <span class="keyword">if</span> (Modifier.isAbstract(declaringClass.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationExceptionConstructorAccessorImpl(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 宿主类直接是Class类型，则无法实例化</span></span><br><span class="line">    <span class="keyword">if</span> (declaringClass == Class<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationExceptionConstructorAccessorImpl</span><br><span class="line">            (<span class="string">"Can not instantiate java.lang.Class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the root Constructor that will not cache caller class</span></span><br><span class="line">    Constructor&lt;?&gt; root = langReflectAccess.getRoot(c);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前声明构造的宿主类是ConstructorAccessorImpl的子类</span></span><br><span class="line">    <span class="keyword">if</span> (Reflection.isSubclassOf(declaringClass,</span><br><span class="line">                                ConstructorAccessorImpl<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BootstrapConstructorAccessorImpl(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                c.getParameterTypes(),</span><br><span class="line">                                c.getExceptionTypes(),</span><br><span class="line">                                c.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeConstructorAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeConstructorAccessorImpl(c);</span><br><span class="line">        DelegatingConstructorAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingConstructorAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见最终得到的<code>ConstructorAccessor</code>实例为<code>DelegatingConstructorAccessorImpl</code>，而<code>DelegatingConstructorAccessorImpl</code>只是一个委托实现，底层是调用<code>NativeConstructorAccessorImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeConstructorAccessorImpl</span> <span class="keyword">extends</span> <span class="title">ConstructorAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;?&gt; c;</span><br><span class="line">    <span class="keyword">private</span> DelegatingConstructorAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeConstructorAccessorImpl(Constructor&lt;?&gt; c) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate a constructor belonging to a vm-anonymous class</span></span><br><span class="line">        <span class="comment">// because that kind of class can't be referred to by name, hence can't</span></span><br><span class="line">        <span class="comment">// be found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">            ConstructorAccessorImpl acc = (ConstructorAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                        c.getParameterTypes(),</span><br><span class="line">                                        c.getExceptionTypes(),</span><br><span class="line">                                        c.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newInstance0(c, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingConstructorAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个就是最终构造实例化对象的native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newInstance0</span><span class="params">(Constructor&lt;?&gt; c, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NativeConstructorAccessorImpl#newInstance0()</code>就是最终构造实例化对象的Native方法。当然有例外的情况，例如非正常调用下，如果构造器的宿主类是一个抽象类，那么最终会返回一个<code>InstantiationExceptionConstructorAccessorImpl</code>实例，里面直接抛出InstantiationException异常。</p>
<h3 id="处理方法调用的底层实现">处理方法调用的底层实现</h3>
<p><code>Method#invoke()</code>调用依赖于<code>MethodAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodAccessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz,</span><br><span class="line">                        Modifier.isStatic(modifiers) ? <span class="keyword">null</span> : obj.getClass(),</span><br><span class="line">                        modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">        MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>获取<code>MethodAccessor</code>实例的逻辑和前两节类似，是通过<code>ReflectionFactory#newMethodAccessor()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Reflection.isCallerSensitive(method)) &#123;</span><br><span class="line">        Method altMethod = findMethodForReflection(method);</span><br><span class="line">        <span class="keyword">if</span> (altMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            method = altMethod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the root Method that will not cache caller class</span></span><br><span class="line">    Method root = langReflectAccess.getRoot(method);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        method = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeMethodAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">        DelegatingMethodAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会委托到<code>NativeMethodAccessorImpl#invoke(Object obj, Object[] args)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>NativeMethodAccessorImpl#invoke0()</code>就是方法调用的最终调用的Native方法。</p>
<h2 id="小结">小结</h2>
<p>学习知识过程总是阶梯式上升的，JDK中的类库设计也类似这样，如果提前熟悉<code>Unsafe</code>类的相关方法，其实反射调用的底层实现也能够相对轻易地理解。属性、构造和方法反射调用底层的实现(<strong>只考虑正常调用的情况下</strong>)如下：</p>
<ul>
<li>对于属性(Field)：<code>Field#setXX()</code>和<code>Field#getXX()</code>分别对应<code>Unsafe</code>的<code>putXX()</code>和<code>getXX()</code>方法，也就是说完全依赖<code>Unsafe</code>中的Native方法。</li>
<li>对于构造(Constructor)：<code>Constructor#newInstance()</code>底层调用<code>NativeConstructorAccessorImpl#newInstance0()</code>。</li>
<li>对于方法(Method)：<code>Method#invoke()</code>底层调用<code>NativeMethodAccessorImpl#invoke0()</code></li>
</ul>
<p>(本文完 e-a-20181216 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/15/java-reflection-handle-exception/">
      深入分析Java反射(六)-反射调用异常处理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月15日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：6分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-08T00:04:20+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(六)-反射调用异常处理</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍一个使用反射一定会遇到的问题-反射调用异常处理。</p>
<h2 id="反射调用异常处理">反射调用异常处理</h2>
<p>反射调用出现异常的方法主要考虑下面的情况：</p>
<ul>
<li>属性操作：<code>java.lang.reflect.Field#set(Object obj, Object value)</code>和<code>java.lang.reflect.Field#get(Object obj)</code>。</li>
<li>构造器调用：<code>java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>。</li>
<li>方法调用：<code>java.lang.reflect.Method#invoke(Object obj, Object... args)</code>。</li>
</ul>
<h3 id="处理属性操作异常">处理属性操作异常</h3>
<p>先看设置属性的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br></pre></td></tr></table></figure>
<p>实际上，通过方法注释可以得知会抛出四种异常：</p>
<ul>
<li>IllegalAccessException：非法访问异常，<strong>注意它是检查(checked)异常</strong>，也就是需要显示捕获，此异常会在修饰符禁用访问的时候抛出，可以通过<code>setAccessible(true)</code>抑制修饰符检查来避免抛出此异常。</li>
<li>IllegalArgumentException：非法参数异常，它是运行时异常，当入参实例obj不是当前Field所在类(包括父类、子类和接口)的时候会抛出此异常。</li>
<li>NullPointerException：空指针异常，当入参实例obj为null的时候会抛出此异常。</li>
<li>ExceptionInInitializerError：初始化器调用异常导致的错误，如果由于<code>set(Object obj, Object value)</code>方法引发的初始化失败会包装成ExceptionInInitializerError，此异常的父类为Error，常见的发生情况就是静态成员或者静态代码块依赖到反射属性设置。</li>
</ul>
<p>前面三种异常都很好理解，最后一个ExceptionInInitializerError可能有点陌生，它的抛出条件是：在静态代码块初始化解析过程总抛出异常或者静态变量初始化的时候抛出异常。笔者尝试了很多例子都没办法造出案例，从Stackoverflow找到一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = Fail.class.getDeclaredField("number");</span><br><span class="line">        field.set(<span class="keyword">null</span>, <span class="number">42</span>); <span class="comment">// Fail class isn't initialized at this point</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> val = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); <span class="comment">// causes initialization to end with an exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是：静态代码块和静态变量的初始化顺序和它们在类文件编写的顺序是一致的，如果一个类未初始化直接使用它的静态代码块和静态变量通过<code>Field#set(Object obj, Object value)</code>调用就会出现ExceptionInInitializerError异常。</p>
<p>属性的获取方法抛出的异常和设置值方法是一致的，这里不做详细展开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br></pre></td></tr></table></figure>
<h3 id="处理构造器调用异常">处理构造器调用异常</h3>
<p>构造器调用主要是用于对象的实例化，先看<code>newInstance</code>方法的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InstantiationException：实例化异常，抛出此异常的一般情况是：当前构造所在类型为一个抽象类型。</li>
<li>IllegalAccessException：非法访问异常。</li>
<li>IllegalArgumentException：非法参数异常，下面的情况会抛出此异常：参数数量或者类型不匹配，参数列表为原始类型但是实际使用了包装类型、参数列表为原始类型但是实际使用了包装类型、构造所在的类是枚举类型等。</li>
<li>InvocationTargetException：目标调用异常，这个是需要处理的重点异常，在下一节&quot;处理方法调用异常&quot;详细探讨。</li>
</ul>
<p>这里只举个例子说明一下InstantiationException出现的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Constructor&lt;AbstractSample&gt; declaredConstructor = AbstractSample<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">		declaredConstructor.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面的抽象类<code>AbstractSample</code>包含一个默认的公有构造，使用<code>Constructor#newInstance()</code>会抛出InstantiationException异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.InstantiationException</span><br><span class="line">	at java.base/jdk.internal.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:<span class="number">48</span>)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">490</span>)</span><br><span class="line">	at club.throwable.jdk.sample.reflection.reflect.AbstractSample.main(AbstractSample.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<h3 id="处理方法调用异常">处理方法调用异常</h3>
<p>方法调用是反射中使用频率最高的反射操作，主要是<code>Method#invoke(Object obj, Object... args)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<p>主要包括以下几种异常：</p>
<ul>
<li>IllegalAccessException：非法访问异常。</li>
<li>IllegalArgumentException：非法参数异常，下面的情况会抛出此异常：入参obj并不是当前实例方法对应的实例对象、参数数量或者类型不匹配，参数列表为原始类型但是实际使用了包装类型、参数列表为原始类型但是实际使用了包装类型等等。</li>
<li>NullPointerException：空指针异常，入参obj为null时候会抛出此异常。</li>
<li>ExceptionInInitializerError：初始化器调用异常导致的错误。</li>
<li>InvocationTargetException：目标调用异常。</li>
</ul>
<p>重点看InvocationTargetException(继承自ReflectiveOperationException，而ReflectiveOperationException继承自Exception，<strong>也就是它是checked异常，必须显式捕获</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 持有的目标异常实例</span></span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);  <span class="comment">// Disallow initCause</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);  <span class="comment">// Disallow initCause</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中得知：方法(Method)或者构造(Constructor)调用异常会抛出此InvocationTargetException异常，用于包装源异常，源异常实例作为目标被InvocationTargetException通过成员target持有，可以通过<code>InvocationTargetException#getTargetException()</code>或者<code>InvocationTargetException#getCause()</code>获取原始的目标异常。这里注意到，InvocationTargetException在覆盖父类构造的时候使用了null，所以调用其<code>getMessage()</code>方法会得到null。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetExceptionMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		InvocationTargetExceptionMain main = <span class="keyword">new</span> InvocationTargetExceptionMain();</span><br><span class="line">		Method method = InvocationTargetExceptionMain.class.getDeclaredMethod("method");</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			method.invoke(main);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">			<span class="comment">//no-op</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"InvocationTargetException#message:"</span> + e.getMessage());</span><br><span class="line">			<span class="keyword">if</span> (e.getTargetException() <span class="keyword">instanceof</span> NullPointerException) &#123;</span><br><span class="line">				NullPointerException nullPointerException = (NullPointerException) e.getTargetException();</span><br><span class="line">				System.out.println(<span class="string">"NullPointerException#message:"</span> + nullPointerException.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvocationTargetException#message:null</span><br><span class="line">NullPointerException#message:Null</span><br></pre></td></tr></table></figure>
<p>构造器<code>Constructor#newInstance()</code>中抛出InvocationTargetException的场景是类似的。</p>
<h2 id="小结">小结</h2>
<p>在反射操作中，方法调用的频次是最高的，其次是通过构造器实例化对象。需要重点关注这两个地方的异常处理，特别是异常类型<code>InvocationTargetException</code>，紧记需要获取原始目标异常类型再进行判断，否则很容易导致逻辑错误(最近笔者在做一个功能的时候刚好踩了这个坑)。</p>
<p>(本文完 e-a-20181215 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/13/java-magic-unsafe/">
      神奇的魔法类和双刃剑-Unsafe
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月13日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：5.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：20分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-13T23:47:39+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月13日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>神奇的魔法类和双刃剑-Unsafe</h1>
<h2 id="前提">前提</h2>
<p>JDK9或者以后，<code>sun.misc</code>包的源码也可以上传到JDK类库中，可以直接导入IDE进行注释的阅读，这一点是比较好的改进。本文基于JDK11的源码阅读Unsafe类的注释，介绍一下这个类的使用方式。</p>
<h2 id="Unsafe简介">Unsafe简介</h2>
<p>在JDK9之后，<code>sun.misc.Unsafe</code>被移动到<code>jdk.unsupported</code>模块中，同时在<code>java.base</code>模块克隆了一个<code>jdk.internal.misc.Unsafe</code>类，代替了JDK8以前的<code>sun.misc.Unsafe</code>的功能，<code>jdk.internal</code>包不开放给开发者调用。</p>
<p>Unsafe是用于在实质上扩展Java语言表达能力、便于在更高层（Java层）代码里实现原本要在更低层（C层）实现的核心库功能用的。这些功能包括裸内存的申请/释放/访问，低层硬件的atomic/volatile支持，创建未初始化对象等。它原本的设计就只应该被标准库使用。</p>
<p>为了让开发者有机会过渡到尽量不使用<code>sun.misc.Unsafe</code>，默认不允许Java应用代码访问<code>sun.misc.Unsafe</code>类，同时在<code>java.base</code>模块克隆了一个不能被外部访问的<code>jdk.internal.misc.Unsafe</code>类用于JDK内部API演进。</p>
<h2 id="获取Unsafe实例">获取Unsafe实例</h2>
<p><code>sun.misc.Unsafe</code>提供了一个静态方法来获取其实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VM类中的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSystemDomainLoader</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loader == <span class="keyword">null</span> || loader == ClassLoader.getPlatformClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个静态方法<code>getUnsafe()</code>必须在当前调用的类对应的类加载器为null(<strong>类加载器为null也就是当前调用的类必须使用Bootstrap类加载器加载</strong>)或者为<code>PlatformClassLoader</code>才不会抛出<code>SecurityException</code>异常。由于对<code>PlatformClassLoader</code>理解不深入，所以我们可以用VM参数<code>-Xbootclasspath:</code>让当前的调用类被Bootstrap类加载器加载。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-unsafe-1.png" alt="j-unsafe-1"></p>
<p>但是试验了一下(其实文档中已经提到此参数已经失效，不过这里还是试了下)，发现这个参数在JDK9之后已经不支持，使用的时候会导致JVM启动失败，异常信息是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">-Xbootclasspath is no longer a supported option.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure>
<p>此特性暂时在JDK9以后找不到替代的VM参数，所以这里只能选择其他可行方法。查看<code>sun.misc.Unsafe</code>所在模块的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> jdk.unsupported &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.sun.nio.file;</span><br><span class="line">    <span class="keyword">exports</span> sun.misc;</span><br><span class="line">    <span class="keyword">exports</span> sun.reflect;</span><br><span class="line"></span><br><span class="line">    opens sun.misc;</span><br><span class="line">    opens sun.reflect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>sun.misc</code>是opens修饰的，可以使用反射直接调用。因此可以像下面这样获取<code>sun.misc.Unsafe</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">		f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有特殊的技巧可以直接暴露<code>jdk.internal.misc.Unsafe</code>所在的模块让它可以直接使用反射调用，只需要使用参数<code>addExports:java.base/jdk.internal.misc=ALL-UNAMED</code>，这样子就可以反射获取<code>jdk.internal.misc.Unsafe</code>的实例，不过推荐这种做法，毕竟<code>jdk.internal.misc.Unsafe</code>中提供更多底层的方法，能力越大越容易失去控制。</p>
<h2 id="Unsafe的使用建议">Unsafe的使用建议</h2>
<p>使用Unsafe要注意以下几个问题：</p>
<p>1、Unsafe有可能在未来的JDK版本移除或者不允许Java应用代码使用，这一点可能导致使用了Unsafe的应用无法运行在高版本的JDK。<br>
2、Unsafe的不少方法中必须提供原始地址(内存地址)和被替换对象的地址，偏移量要自己计算，一旦出现问题就是JVM崩溃级别的异常，会导致整个JVM实例崩溃，表现为应用程序直接crash掉(<strong>其实这个很好理解，JVM是C语言写出来的软件，如果操作一个不存在的内存地址，在C程序中就是引发程序崩溃的操作</strong>)。<br>
3、Unsafe提供的直接内存访问的方法中使用的内存不受JVM管理(无法被GC)，需要手动管理，一旦出现疏忽很有可能成为内存泄漏的源头。</p>
<p>暂时总结出以上三点问题。Unsafe在JUC(java.util.concurrent)包中大量使用(主要是CAS)，在netty中方便使用直接内存，还有一些高并发的交易系统为了提高CAS的效率也有可能直接使用到Unsafe。总而言之，Unsafe类是魔法类，也可以说是一把双刃剑。</p>
<h2 id="Unsafe的核心方法">Unsafe的核心方法</h2>
<p><code>sun.misc.Unsafe</code>一共提供了89个public修饰的方法，下面针对核心方法按功能分组简单介绍一下。</p>
<h3 id="类操作">类操作</h3>
<p>类操作相关主要和类实例化、属性地址获取等等操作，原来存在一个<code>defineClass</code>方法，已经被移除，但是该方法在<code>jdk.internal.misc.Unsafe</code>中依然存在。</p>
<p><strong>ensureClassInitialized</strong></p>
<ul>
<li><code>public boolean shouldBeInitialized(Class&lt;?&gt; c)</code></li>
</ul>
<p>检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。</p>
<p><strong>shouldBeInitialized</strong></p>
<ul>
<li><code>public boolean shouldBeInitialized(Class&lt;?&gt; c)</code></li>
</ul>
<p>检测给定的类是否需要初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。 此方法当且仅当<code>ensureClassInitialized</code>方法不生效的时候才返回false。</p>
<p><strong>defineAnonymousClass</strong></p>
<ul>
<li>
<p><code>public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches)</code></p>
<ul>
<li>hostClass：宿主类。</li>
<li>data：字节码字节数组。</li>
<li>cpPatches：替换常量池(Constant Pool)中的字面量得到的引用数组。</li>
</ul>
</li>
</ul>
<p>这个方法的使用可以看R大的知乎回答：<a href="https://www.zhihu.com/question/51132462" target="_blank" rel="noopener">JVM crashes at libjvm.so</a>，下面截取一点内容解释此方法。</p>
<ul>
<li>1、VM Anonymous Class可以看作一种模板机制，如果程序要动态生成很多结构相同、只是若干变量不同的类的话，可以先创建出一个包含占位符常量的正常类作为模板，然后利用<code>sun.misc.Unsafe#defineAnonymousClass()</code>方法，传入该类(host class，宿主类或者模板类)以及一个作为&quot;constant pool path&quot;的数组来替换指定的常量为任意值，结果得到的就是一个替换了常量的<code>VM Anonymous Class</code>。</li>
<li>2、<code>VM Anonymous Class</code>从VM的角度看是真正的&quot;没有名字&quot;的，在构造出来之后只能通过<code>Unsafe#defineAnonymousClass()</code>返回出来一个Class实例来进行反射操作。</li>
</ul>
<p>还有其他几点看以自行阅读。这个方法虽然翻译为&quot;定义匿名类&quot;，但是它所定义的类和实际的匿名类有点不相同，因此一般情况下我们不会用到此方法。在JDK中Lambda表达式的构造依赖到此方法，可以看<code>InnerClassLambdaMetafactory</code>这个类。<strong>方法的注释：定义一个不被类加载器系统或者系统字典感知的类型</strong>。</p>
<p><strong>allocateInstance</strong></p>
<ul>
<li><code>public native Object allocateInstance(Class&lt;?&gt; cls)</code></li>
</ul>
<p>注意此方法是JVM本地接口方法，通过Class对象创建一个类的实例，不需要调用其构造函数、初始化代码、JVM安全检查等等。同时，它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化。</p>
<p><strong>staticFieldBase</strong></p>
<ul>
<li><code>public Object staticFieldBase(Field f)</code></li>
</ul>
<p>返回给定的静态属性所在的位置(其实就是所在的对象的内存快照)，配合<code>staticFieldOffset</code>方法使用。实际上，这个方法返回值就是静态属性所在的Class对象的一个内存快照。注释中说到，此方法返回的Object有可能为null，它只是一个’cookie’而不是真实的对象，不要直接使用的它的实例中的获取属性和设置属性的方法，它的作用只是方便调用像<code>getInt(Object,long)</code>等等的任意方法。</p>
<p><strong>staticFieldOffset</strong></p>
<ul>
<li><code>public long staticFieldOffset(Field f)</code></li>
</ul>
<p>返回给定的<strong>静态属性</strong>在它的类的内存分配中的位置(内存偏移地址)。不要在这个偏移量上执行任何类型的算术运算，它只是一个被传递给不安全的堆内存访问器的cookie。注意：这个方法仅仅针对静态属性，使用在非静态属性上会抛异常。</p>
<p><strong>objectFieldOffset</strong></p>
<ul>
<li><code>public long staticFieldOffset(Field f)</code></li>
</ul>
<p>返回给定的<strong>非静态属性</strong>在它的类的内存分配中的位置(内存偏移地址)。不要在这个偏移量上执行任何类型的算术运算，它只是一个被传递给不安全的堆内存访问器的cookie。注意：这个方法仅仅针对非静态属性，使用在静态属性上会抛异常。</p>
<p><strong>defineClass</strong></p>
<ul>
<li><code>public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain)</code></li>
</ul>
<p>这个方法位于<code>jdk.internal.misc.Unsafe</code>，也就是开发者无法直接使用。作用是：绕过安全检查告知JVM定义一个类。默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例应该来源于调用者。</p>
<h3 id="基于内存地址直接存取属性">基于内存地址直接存取属性</h3>
<p>前一节中提供了一些方法可以直接获取静态或者非静态成员属性的内存地址，这一节介绍的API可以基于成员属性内存地址直接获取或者设置其值。</p>
<p><strong>getObject</strong></p>
<ul>
<li><code>public Object getObject(Object o, long offset)</code></li>
</ul>
<p>通过给定的Java对象和属性内存地址获取引用值。这里实际上是获取一个Java对象o中，获取偏移地址为offset的属性的值，此方法可以突破修饰符的抑制，也就是无视private、protected和default修饰符。类似的方法有<code>getInt</code>、<code>getDouble</code>等等。</p>
<p><strong>putObject</strong></p>
<ul>
<li>
<p><code>public void putObject(Object o, long offset, Object x)</code></p>
<ul>
<li>o：当前操作的对象。</li>
<li>offset：成员属性的内存地址。</li>
<li>x：需要设置的目标属性值。</li>
</ul>
</li>
</ul>
<p>将引用值存储到给定的Java变量中。这里实际上是设置一个Java对象o中偏移地址为offset的属性的值为x，此方法可以突破修饰符的抑制，也就是无视private、protected和default修饰符。类似的方法有putInt、putDouble等等。</p>
<p><strong>getObjectVolatile</strong></p>
<ul>
<li><code>public Object getObjectVolatile(Object o, long offset)</code></li>
</ul>
<p>此方法和上面的<code>getObject</code>功能类似，不过附加了<code>volatile</code>关键字加载语义，也就是强制从主存中获取属性值。类似的方法有<code>getIntVolatile</code>、<code>getDoubleVolatile</code>等等。这个方法要求被使用的属性被volatile修饰，否则功能和<code>getObject</code>方法相同。</p>
<p><strong>putObjectVolatile</strong></p>
<ul>
<li><code>public void putObjectVolatile(Object o, long offset, Object x)</code></li>
</ul>
<p>此方法和上面的<code>putObject</code>功能类似，不过附加了<code>volatile</code>关键字加载语义，也就是设置值的时候强制(JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后)更新到主存，从而保证这些变更对其他线程是可见的。类似的方法有<code>putIntVolatile</code>、<code>putDoubleVolatile</code>等等。这个方法要求被使用的属性被volatile修饰，否则功能和putObject方法相同。</p>
<p><strong>putOrderedObject</strong></p>
<ul>
<li><code>public void putOrderedObject(Object o, long offset, Object x)</code></li>
</ul>
<p>设置o对象中offset偏移地址offset对应的Object型field的值为指定值x。这是一个有序或者有延迟的<code>putObjectVolatile</code>方法，并且不保证值的改变被其他线程立即看到。只有在属性被volatile修饰并且期望被修改的时候使用才会生效。类似的方法有<code>putOrderedInt</code>和<code>putOrderedLong</code>。方法注释中提到：相当于C11中的<code>atomic_store_explicit(..., memory_order_release)</code>。</p>
<h3 id="数组操作">数组操作</h3>
<p><strong>arrayBaseOffset</strong></p>
<ul>
<li><code>public int arrayBaseOffset(Class&lt;?&gt; arrayClass)</code></li>
</ul>
<p>返回数组类型的第一个元素的偏移地址(基础偏移地址)。如果arrayIndexScale方法返回的比例因子不为0，你可以通过结合基础偏移地址和比例因子访问数组的所有元素。Unsafe中已经初始化了很多类似的常量如<code>ARRAY_BOOLEAN_BASE_OFFSET</code>等。</p>
<p><strong>arrayIndexScale</strong></p>
<ul>
<li><code>public int arrayIndexScale(Class&lt;?&gt; arrayClass)</code></li>
</ul>
<p>返回数组类型的比例因子(其实就是数据中元素偏移地址的增量，因为数组中的元素的地址是连续的)。此方法不适用于数组类型为&quot;narrow&quot;类型的数组，&quot;narrow&quot;类型的数组类型使用此方法会返回0(这里narrow应该是狭义的意思，但是具体指哪些类型暂时不明确，笔者查了很多资料也没找到结果)。Unsafe中已经初始化了很多类似的常量如<code>ARRAY_BOOLEAN_INDEX_SCALE</code>等。</p>
<h3 id="低级同步原语">低级同步原语</h3>
<p>低级同步原语的相关方法在JDK8还能通过<code>sun.misc.Unsafe</code>使用，在JDK9以后<code>sun.misc.Unsafe</code>和<code>jdk.internal.misc.Unsafe</code>都移除了相关的方法。低级同步原语主要包括监视器锁定、解锁方法。</p>
<p><strong>monitorEnter</strong></p>
<ul>
<li><code>public native void monitorEnter(Object o)</code></li>
</ul>
<p>锁定对象，必须通过monitorExit方法才能解锁。此方法经过实验是可以重入的，也就是可以多次调用，然后通过多次调用monitorExit进行解锁。</p>
<p><strong>monitorExit</strong></p>
<ul>
<li><code>public native void monitorExit(Object o)</code></li>
</ul>
<p>解锁对象，前提是对象必须已经调用monitorEnter进行加锁，否则抛出IllegalMonitorStateException异常。</p>
<p><strong>tryMonitorEnter</strong></p>
<ul>
<li><code>public native boolean tryMonitorEnter(Object o)</code></li>
</ul>
<p>尝试锁定对象，如果加锁成功返回true，否则返回false。必须通过monitorExit方法才能解锁。</p>
<h3 id="线程挂起与恢复">线程挂起与恢复</h3>
<p>JDK1.5引入了并发包<code>java.util.concurrent</code>中组件控制线程挂起和恢复就是依赖于<code>java.util.concurrent.locks.LockSupport</code>完成，而<code>LockSupport</code>底层依赖于<code>sun.misc.Unsafe</code>中下面提到线程的挂起和恢复方法完成的。相关方法主要是用于替代线程类<code>Thread</code>中过时并且不安全的<code>suspend</code>和<code>resume</code>方法。</p>
<p><strong>park</strong></p>
<ul>
<li>
<p><code>public void park(boolean isAbsolute, long time)</code></p>
<ul>
<li>time：时间长度，单位由isAbsolute控制，0表示永久阻塞。</li>
<li>isAbsolute：如果isAbsolute为true，time是相对于新纪元之后的毫秒，否则time表示纳秒。</li>
</ul>
</li>
</ul>
<p>注释：阻塞当前线程直到一个<code>unpark</code>方法出现(被调用)、一个用于<code>unpark</code>方法已经出现过(在此<code>park</code>方法调用之前已经调用过)、线程被中断或者time时间到期(也就是阻塞超时)。在time非零的情况下，如果isAbsolute为true，time是相对于新纪元之后的毫秒，否则time表示纳秒。这个方法执行时也可能不合理地返回(没有具体原因)。</p>
<p><strong>unpark</strong></p>
<ul>
<li><code>public void unpark(Object thread)</code></li>
</ul>
<p>释放被<code>park</code>创建的在一个线程上的阻塞。这个方法也可以被使用来终止一个先前调用<code>park</code>导致的阻塞。这个操作是不安全的，因此必须保证线程是存活的(thread has not been destroyed)。从Java代码中判断一个线程是否存活的是显而易见的，所以解除阻塞的时候需要对线程的存活性做判断。</p>
<p><strong>重点注意：</strong></p>
<ul>
<li><code>unpark</code>方法调用多次，实际上只有一次会生效，可以简单理解为它是一个只有0和1两个值的计数器，调用<code>unpark</code>多次，计数仍然为1。</li>
<li><code>park</code>方法总是针对当前线程，如果预先已经调用过一次<code>unpark</code>方法后再调用<code>park</code>方法，那么<strong>将不会进入阻塞状态直接释放</strong>。</li>
</ul>
<h3 id="CAS操作">CAS操作</h3>
<p>CAS，也就是Compare And Swap，也就是在一个原子操作中完成比较和交互。</p>
<p><strong>compareAndSwapObject</strong></p>
<ul>
<li>
<p><code>public final boolean compareAndSwapObject(Object o, long offset, Object expected, Object x)</code></p>
<ul>
<li>o：目标Java变量引用。</li>
<li>offset：目标Java变量中的目标属性的偏移地址。</li>
<li>expected：目标Java变量中的目标属性的期望的当前值。</li>
<li>x：目标Java变量中的目标属性的目标更新值。</li>
</ul>
</li>
</ul>
<p>针对Object对象进行CAS操作。即是对应Java变量引用o，原子性地更新o中偏移地址为offset的属性的值为x，当且仅的偏移地址为offset的属性的当前值为expected才会更新成功返回true，否则返回false。类似的方法有<code>compareAndSwapInt</code>和<code>compareAndSwapLong</code>，在Jdk8中基于CAS扩展出来的相关方法有<code>getAndAddInt</code>、<code>getAndAddLong</code>、<code>getAndSetInt</code>、<code>getAndSetLong</code>、<code>getAndSetObject</code>，它们的作用都是：通过CAS设置新的值，返回旧的值。</p>
<p><strong>getAndSetObject</strong></p>
<ul>
<li><code>public final Object getAndSetObject(Object o, long offset, Object newValue)</code></li>
</ul>
<p>见<strong>compareAndSwapObject</strong>中的描述。</p>
<h3 id="内存管理">内存管理</h3>
<p><strong>addressSize</strong></p>
<ul>
<li><code>public int addressSize();</code></li>
</ul>
<p>获取本地指针的大小(单位是byte)，通常值为4或者8。常量ADDRESS_SIZE就是调用此方法。</p>
<p><strong>pageSize</strong></p>
<ul>
<li><code>public int pageSize();</code></li>
</ul>
<p>获取本地内存的页数，此值为2的幂次方。</p>
<p><strong>allocateMemory</strong></p>
<ul>
<li><code>public long allocateMemory(long bytes);</code></li>
</ul>
<p>分配一块新的本地内存，通过bytes指定内存块的大小(单位是byte)，返回新开辟的内存的地址。如果内存块的内容不被初始化，那么它们一般会变成内存垃圾。生成的本机指针永远不会为零，并将对所有值类型进行对齐。可以通过<code>freeMemory</code>方法释放内存块，或者通过<code>reallocateMemory</code>方法调整内存块大小。bytes值为负数或者过大会抛出IllegalArgumentException异常，如果系统拒绝分配内存会抛出OutOfMemoryError异常。</p>
<p><strong>reallocateMemory</strong></p>
<ul>
<li><code>public long reallocateMemory(long address, long bytes);</code></li>
</ul>
<p>通过指定的内存地址address重新调整本地内存块的大小，调整后的内存块大小通过bytes指定(单位为byte)。可以通过<code>freeMemory</code>方法释放内存块，或者通过<code>reallocateMemory</code>方法调整内存块大小。bytes值为负数或者过大会抛出IllegalArgumentException异常，如果系统拒绝分配内存会抛出OutOfMemoryError异常。</p>
<p><strong>setMemory</strong></p>
<ul>
<li><code>public void setMemory(Object o, long offset, long bytes, byte value);</code></li>
</ul>
<p>将给定内存块中的所有字节设置为固定值(通常是0)。内存块的地址由对象引用o和偏移地址共同决定，如果对象引用o为null，offset就是绝对地址。第三个参数就是内存块的大小，如果使用<code>allocateMemory</code>进行内存开辟的话，这里的值应该和<code>allocateMemory</code>的参数一致。value就是设置的固定值，一般为0(这里可以参考netty的DirectByteBuffer)。一般而言，o为null，所有有个重载方法是<code>public void setMemory(long offset, long bytes, byte value);</code>，等效于<code>setMemory(null, long offset, long bytes, byte value);</code>。</p>
<p><strong>copyMemory</strong></p>
<ul>
<li><code>public void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes) </code></li>
</ul>
<p>拷贝给定内存地址的字节长度对应的字节到指定内存地址中。如果srcBase或者destBase为null，则srcOffset或者destOffset分别指代绝对地址。</p>
<h3 id="内存屏障">内存屏障</h3>
<p>内存屏障相关的方法是在Jdk8添加的。内存屏障相关的知识可以先自行查阅，笔者目前也没有深入了解相关知识。</p>
<p><strong>loadFence</strong></p>
<ul>
<li><code>public void loadFence();</code></li>
</ul>
<p>在该方法之前的所有读操作，一定在load屏障之前执行完成。</p>
<p><strong>storeFence</strong></p>
<ul>
<li><code>public void storeFence();</code></li>
</ul>
<p>在该方法之前的所有写操作，一定在store屏障之前执行完成</p>
<p><strong>fullFence</strong></p>
<ul>
<li><code>public void fullFence();</code></li>
</ul>
<p>在该方法之前的所有读写操作，一定在full屏障之前执行完成，这个内存屏障相当于上面两个(load屏障和store屏障)的合体功能。</p>
<h3 id="其它">其它</h3>
<p><strong>invokeCleaner</strong></p>
<ul>
<li><code>public void invokeCleaner(java.nio.ByteBuffer directBuffer)</code></li>
</ul>
<p>清空使用了堆外内存的<code>ByteBuffer</code>实例占据的内存，一般是<code>DirectBuffer</code>的子类。</p>
<p><strong>throwException</strong></p>
<ul>
<li><code>public void throwException(Throwable ee)</code></li>
</ul>
<p>绕过检测机制直接抛出异常。</p>
<p><strong>getLoadAverage</strong></p>
<ul>
<li><code>public int getLoadAverage(double[] loadavg, int nelems);</code></li>
</ul>
<p>获取系统的平均负载值，loadavg这个double数组将会存放负载值的结果，nelems决定样本数量，nelems只能取值为1到3，分别代表最近1、5、15分钟内系统的平均负载。如果无法获取系统的负载，此方法返回-1，否则返回获取到的样本数量(loadavg中有效的元素个数)。实验中这个方法一直返回-1，其实完全可以使用<strong>JMX</strong>中的相关方法替代此方法。</p>
<h2 id="使用例子">使用例子</h2>
<p>先封装一下获取<code>Unsafe</code>实例的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Field f = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">	f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过内存地址直接操作属性">通过内存地址直接操作属性</h3>
<p>通过<code>staticFieldOffset</code>和<code>objectFieldOffset</code>可以获取静态和非静态成员属性的偏移地址，然后直接进行存取值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Integer STATIC_INT = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">   Long longField = <span class="number">1024L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Unsafe unsafe = getUnsafe();</span><br><span class="line">		Field staticInt = Simple.class.getDeclaredField("STATIC_INT");</span><br><span class="line">		staticInt.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		Object staticFieldBase = unsafe.staticFieldBase(staticInt);</span><br><span class="line">		<span class="keyword">long</span> staticFieldOffset = unsafe.staticFieldOffset(staticInt);</span><br><span class="line">		<span class="comment">// 注意这里一定要getObject,getInt是针对原始类型int,包装类型要自己强转</span></span><br><span class="line">		System.out.println(<span class="string">"Sample初始化前,STATIC_INT = "</span> + unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line">		Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">		System.out.println(<span class="string">"Sample初始化后,STATIC_INT = "</span> + unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line"></span><br><span class="line">		Field longField = Simple.class.getDeclaredField("longField");</span><br><span class="line">		longField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">long</span> objectFieldOffset = unsafe.objectFieldOffset(longField);</span><br><span class="line">		System.out.println(<span class="string">"Sample初始化后,longField = "</span> + unsafe.getObject(simple, objectFieldOffset));</span><br><span class="line">		unsafe.putObject(simple,objectFieldOffset, <span class="number">4201L</span>);</span><br><span class="line">		System.out.println(<span class="string">"Sample属性被覆盖后,longField = "</span> + simple.longField);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line">Sample初始化前,STATIC_INT = <span class="keyword">null</span></span><br><span class="line">Sample初始化后,STATIC_INT = <span class="number">10086</span></span><br><span class="line">Sample初始化后,longField = <span class="number">1024</span></span><br><span class="line">Sample属性被覆盖后,longField = <span class="number">4201</span></span><br></pre></td></tr></table></figure>
<h3 id="线程挂起和恢复">线程挂起和恢复</h3>
<p>主要介绍一下<code>park</code>和<code>unpark</code>的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Unsafe unsafe = getUnsafe();</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"线程park!"</span>);</span><br><span class="line">				unsafe.park(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">				System.out.println(<span class="string">"线程恢复运行!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">"主线程unpark阻塞着的线程!"</span>);</span><br><span class="line">		unsafe.unpark(thread);</span><br><span class="line">		TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行后输出：</span></span><br><span class="line">线程park!</span><br><span class="line">主线程unpark阻塞着的线程!</span><br><span class="line">线程恢复运行!</span><br></pre></td></tr></table></figure>
<h3 id=""></h3>
<h2 id="小结">小结</h2>
<p>存在即合理，虽然不推荐使用<code>Unsafe</code>，但是如果有需要的还是要挥动这把双刃剑。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/29266773?sort=created" target="_blank" rel="noopener">为什么JUC中大量使用了sun.misc.Unsafe 这个类，但官方却不建议开发者使用？</a></li>
<li>JDK11相关源码</li>
<li><a href="http://ifeve.com/sun-misc-unsafe/" target="_blank" rel="noopener">Java Magic. Part 4: sun.misc.Unsafe</a></li>
</ul>
<p>(本文完 e-a-20181213 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/09/java-reflection-class-load/">
      深入分析Java反射(五)-类实例化和类加载
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月9日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：15分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-12T00:45:32+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月12日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(五)-类实例化和类加载</h1>
<h2 id="前提">前提</h2>
<p>其实在前面写过的《深入分析Java反射(一)-核心类库和方法》已经介绍过通过类名或者<code>java.lang.Class</code>实例去实例化一个对象，在《浅析Java中的资源加载》中也比较详细地介绍过类加载过程中的双亲委派模型，这篇文章主要是加深一些对类实例化和类加载的认识。</p>
<h2 id="类实例化">类实例化</h2>
<p>在反射类库中，用于实例化对象只有两个方法：</p>
<ul>
<li><code>T java.lang.Class#newInstance()</code>：这个方法只需要提供<code>java.lang.Class&lt;T&gt;</code>的实例就可以实例化对象，如果提供的是无限定类型<code>Class&lt;?&gt;</code>则得到的是Object类型的返回值，可以进行强转。这个方法不支持任何入参，底层实际上也是依赖无参数的构造器Constructor进行实例化。</li>
<li><code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>：这个方法需要提供<code>java.lang.reflect.Constructor&lt;T&gt;</code>实例和一个可变参数数组进行对象的实例化，上面提到的<code>T java.lang.Class#newInstance()</code>底层也是依赖此方法。这个方法除了可以传入构造参数之外，还有一个好处就是可以通过``抑制修饰符访问权限检查，也就是私有的构造器也可以用于实例化对象。</li>
</ul>
<p>在编写反射类库的时候，优先选择<code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>进行对象实例化，目前参考很多优秀的框架(例如Spring)都是用这个方法进行对象实例化。</p>
<h2 id="类加载">类加载</h2>
<p>类加载实际上由类加载器(ClassLoader)完成，<code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>方法提现了类加载过程中遵循了双亲委派模型，实际上，我们可以覆写此方法完全不遵循双亲委派模型，实现同一个类(这里指的是全类名完全相同)重新加载。JDK中提供类加载相关的特性有两个方法：</p>
<ul>
<li><code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>：通过类加载器实例去加载类，一般应用类路径下的类是由<code>jdk.internal.loader.ClassLoaders$AppClassLoader</code>加载，也可以自行继承<code>java.lang.ClassLoader</code>实现自己的类加载器。</li>
<li><code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>：通过全类名进行类加载，可以通过参数控制类初始化行为。</li>
</ul>
<h3 id="ClassLoader中的类加载">ClassLoader中的类加载</h3>
<p>类加载过程其实是一个很复杂的过程，主要包括下面的步骤：</p>
<ul>
<li>1、加载过程：使用(自定义)类加载器去获取类文件字节码字节类的过程，Class实例在这一步生成，作为方法区的各种数据类型的访问入口。</li>
<li>2、验证过程：JVM验证字节码的合法性。</li>
<li>3、准备过程：为类变量分配内存并且设置初始值。</li>
<li>4、解析过程：JVM把常量池中的符号替换为直接引用。</li>
<li>5、初始化过程：执行类构造器<code>&lt;cinit&gt;()</code>方法，<code>&lt;cinit&gt;()</code>方法是编译器自动收集所有类变量的赋值动作和静态代码块中的语句合并生成，收集顺序由语句在源文件中出现的顺序决定，JVM保证在子类<code>&lt;cinit&gt;()</code>方法调用前父类的<code>&lt;cinit&gt;()</code>方法已经执行完毕。</li>
</ul>
<p><code>ClassLoader#loadClass()</code>方法就是用于控制类加载过程的第一步-加载过程，也就是控制字节码字节数组和类名生成Class实例的过程。<code>ClassLoader</code>中还有一个<code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</code>方法用于指定全类名和字节码字节数组去定义一个类，我们再次看下<code>loadClass()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查类是否已经加载过，如果已经加载过，则直接返回</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="comment">// 委派父类加载器去加载类</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 委派父类加载器如果加载失败则调用findClass方法进行加载动作</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展点-1</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 扩展点-2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>loadClass()</code>方法留下了两个扩展点用于改变类加载的行为，而<code>findClass()</code>方法就是用于扩展父类加载器加载失败的情况下，子类加载器的行为。当然，实际上<code>Class&lt;?&gt; loadClass(String name, boolean resolve)</code>方法<strong>是非final的方法，可以整个方法覆写掉，这样子就有办法完全打破双亲委派机制</strong>。但是注意一点，即使打破双亲委派机制，子类加载器也不可能重新加载一些由Bootstrap类加载器加载的类库如<code>java.lang.String</code>，这些是由JVM验证和保证的。自定义类加载器的使用在下一节的&quot;类重新加载&quot;中详细展开。</p>
<p>最后还有两点十分重要：</p>
<ul>
<li>1、<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性</strong>，也就是一个类在JVM中的签名是加载它的类加载器和它本身，<strong>对于每一个类加载器，都拥有一个独立的类命名空间</strong>。</li>
<li>2、<strong>比较两个类是否&quot;相等&quot;，只有这两个类是由同一个类加载器加载的前提下才有意义</strong>。即使这两个类的全类名一致、来源于同一个字节码文件、被同一个Java虚拟机加载，但是加载它们的类加载器不同，那么它们必定不相等。这里相等的范畴包括：<code>Class</code>对象的<code>equals()</code>方法、<code>isAssignableForm()</code>方法、<code>isInstance()</code>方法的返回结果以及使用<code>instanceof</code>关键字做对象所属关系时候的判定等情况。</li>
</ul>
<h3 id="Class中的类加载">Class中的类加载</h3>
<p><code>java.lang.Class</code>中的类加载主要由<code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>方法完成，该方法可以指定全类名、是否初始化和类加载器实例。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">        <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">        caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">            <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sm.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                        ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt; caller) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>它最终调用的是JVM的本地接口方法，由于暂时没有能力分析JVM的源码，只能通过<code>forName</code>方法的注释理解方法的功能：</p>
<blockquote>
<p>返回给定字符串全限定名称、指定类加载器的类或者接口的Class实例，此方法会尝试对类或者接口进行locate、load and link操作，如果loader参数为null，则使用bootstrap类加载器进行加载，如果initialize参数为true同时类或者接口在早期没有被初始化，则会进行初始化操作。</p>
</blockquote>
<p>也就是说initialize参数对于已经初始化过的类或者接口来说是没有意义的。这个方法的特性还可以参考<a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html" target="_blank" rel="noopener">Java语言规范的12章中的内容</a>，这里不做展开。</p>
<p>虽然暂时没法分析JVM本地接口方法<code>native Class&lt;?&gt; forName0()</code>的功能，但是它依赖一个类加载器实例入参，可以大胆猜测它也是依赖于类加载器的<code>loadClass()</code>进行类加载的。</p>
<h2 id="类重新加载">类重新加载</h2>
<p>先提出一个实验，如果定义一个类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用字节码工具修改<code>say()</code>方法的内容为<code>System.out.println(&quot;Hello Throwable!&quot;);</code>，并且使用自定义的ClassLoader重新加载一个同类名的<code>Sample</code>类，那么通过<code>new</code>关键字实例化出来的<code>Sample</code>对象调用<code>say()</code>到底打印&quot;Hello Doge!“还是&quot;Hello Throwable!”？</p>
<p>先引入字节码工具javassist用于修改类的字节码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.24.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性使用的自定义类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">		CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">		<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">		Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">        <span class="comment">// 类路径中的Demo类</span></span><br><span class="line">		Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">		demo.say();</span><br><span class="line">		<span class="comment">// 新的Demo类</span></span><br><span class="line">		newDemoClass.getDeclaredMethod(<span class="string">"say"</span>).invoke(newDemoClass.newInstance());</span><br><span class="line">		<span class="comment">// 比较</span></span><br><span class="line">		System.out.println(newDemoClass.equals(Demo<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello Doge!</span><br><span class="line">Hello Throwable!</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>这里得出的结论是：</p>
<ul>
<li><code>new</code>关键字只能使用在当前类路径下的类的实例化，而这些类都是由应用类加载器加载，如果上面的例子中<code>newDemoClass.newInstance()</code>强制转换为Demo类型会报错。</li>
<li>通过自定义类加载器加载的和当前类路径相同名全类名的类只能通过反射去使用，而且即使全类名相同，由于类加载器隔离，它们其实是不相同的类。</li>
</ul>
<h3 id="如何避免类重新加载导致内存溢出">如何避免类重新加载导致内存溢出</h3>
<p>实际上，JDK没有提供方法去卸载一个已经加载的类，也就是类的生命周期是由JVM管理的，因此要解决类重新加载导致内存溢出的问题归根结底就是解决重新加载的类被回收的问题。由于创建出来是的<code>java.lang.Class</code>对象，如果需要回收它，则要考虑下面几点：</p>
<ul>
<li>1、<code>java.lang.Class</code>对象反射创建的实例需要被回收。</li>
<li>2、<code>java.lang.Class</code>对象不能被任何地方强引用。</li>
<li>3、加载<code>java.lang.Class</code>对象的<code>ClassLoder</code>已经被回收。</li>
</ul>
<p>基于这几点考虑可以做个试验验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里故意建立一个数组占用大量内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, List&lt;Class&lt;?&gt;&gt;&gt; CACHE = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">			CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">			<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">			Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">			add(classLoader, newDemoClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理类加载器和它加载过的类</span></span><br><span class="line">		clear();</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (CACHE.containsKey(classLoader)) &#123;</span><br><span class="line">			CACHE.get(classLoader).add(clazz);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			CACHE.put(classLoader, classes);</span><br><span class="line">			classes.add(clazz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CACHE.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用VM参数<code>-XX:+PrintGC -XX:+PrintGCDetails</code>执行上面的方法，JDK11默认使用G1收集器，由于Z收集器还在实验阶段，不是很建议使用，执行main方法后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11.374</span>s][info   ][gc,task       ] GC(<span class="number">17</span>) Using <span class="number">8</span> workers of <span class="number">8</span> <span class="keyword">for</span> full compaction</span><br><span class="line">[<span class="number">11.374</span>s][info   ][gc,start      ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>)</span></span><br><span class="line"><span class="function">[11.374s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,stringtable ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Cleaned string and symbol table, strings: 5637 processed, 0 removed, symbols: 135915 processed, 0 removed</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects 54.378ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction 0.422ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers 0.598ms</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap 0.362ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Eden regions: 44-&gt;0<span class="params">(<span class="number">9</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Survivor regions: 12-&gt;0<span class="params">(<span class="number">12</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Old regions: 146-&gt;7</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Humongous regions: 3-&gt;2</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,metaspace   ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Metaspace: 141897K-&gt;9084<span class="title">K</span><span class="params">(<span class="number">1062912</span>K)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc             ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 205M-&gt;3<span class="title">M</span><span class="params">(<span class="number">30</span>M)</span> 273.440ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.31</span>s Sys=<span class="number">0.08</span>s Real=<span class="number">0.27</span>s</span><br></pre></td></tr></table></figure>
<p>可见FullGC之后，元空间(Metaspace)回收了(141897-9084)KB，一共回收了202M的内存空间，初步可以认为元空间的内存被回收了，接下来注释掉main方法中调用的<code>clear()</code>方法，再调用一次main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,heap        ] GC(<span class="number">17</span>) Humongous regions: <span class="number">3</span>-&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,metaspace   ] GC(<span class="number">17</span>) Metaspace: <span class="number">141884</span>K-&gt;<span class="number">141884</span>K(<span class="number">1458176</span>K)</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc             ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 201M-&gt;166<span class="title">M</span><span class="params">(<span class="number">564</span>M)</span> 115.504ms</span></span><br><span class="line"><span class="function">[4.083s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.84</span>s Sys=<span class="number">0.00</span>s Real=<span class="number">0.12</span>s</span><br></pre></td></tr></table></figure>
<p>可见元空间在FullGC执行没有进行回收，而堆内存的回收率也比较低，由此可以得出一个经验性的结论：只需要通过ClassLoader对象做映射关系保存使用它加载出来的新的类，只需要确保这些类没有没强引用、类实例都已经销毁，那么只需要移除ClassLoader对象的引用，那么在JVM进行GC的时候会把ClassLoader对象以及使用它加载的类回收，这样做就可以避免元空间的内存泄漏。</p>
<h2 id="小结">小结</h2>
<p>通过一些资料和实验，深化了类加载过程的一些认识。</p>
<p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机-第二版》</li>
<li>JDK11部分源码</li>
</ul>
<p>(本文完 e-2018129 c-2-d r-20181212)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/08/java-reflection-dynamic-proxy/">
      深入分析Java反射(四)-动态代理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月8日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：27分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-08T20:25:34+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(四)-动态代理</h1>
<h2 id="动态代理的简介">动态代理的简介</h2>
<p>Java动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。Java动态代理实际上通过反射技术，把代理对象和被代理对象(真实对象)的代理关系建立延迟到程序运行之后，动态创建新的代理类去完成对真实对象的代理操作(可以改变原来真实对象的方法行为)，这一点成为了当前主流的AOP框架和延迟加载功能的基础。本文在查看和编写动态代理相关的代码使用的是JDK11，不过JDK动态代理相关的功能和接口已经相对稳定，不必担心JDK版本升级带来的兼容性问题，但是需要注意由于JDK9引入了模块概念，动态代理的源码也有不少的改动。下文先介绍设计模式中的代理模式，接着会分析JDK动态代理的核心类库、流程和机制，最后分析其底层源码级别实现。</p>
<h2 id="设计模式中的代理模式">设计模式中的代理模式</h2>
<p>代理模式是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-2.png" alt="j-r-d-p-2.png"></p>
<p>代理模式主要包括三种角色：</p>
<ul>
<li>Subject抽象主题角色：一般定义为抽象类或者接口，是作为功能的定义，提供一系列抽象的功能方法。</li>
<li>RealSubject具体(真实)主题角色：一般称为被委托角色或者被代理角色，它是Subject的一个具体实现。</li>
<li>ProxySubject代理主题角色：一般称为委托角色或者代理角色，一般ProxySubject也实现(或者继承)Subject，接收一个具体的Subject实例RealSubject，在RealSubject处理前后做预定义或者后置操作，甚至可以直接忽略RealSubject原来的方法。</li>
</ul>
<p>把上面的类图编写成代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"RealSubject doSomething..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.subject = subject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		subject.doSomething();</span><br><span class="line">		doOtherThing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ProxySubject doOtherThing..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(subject);</span><br><span class="line">		proxySubject.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>Client#main()</code>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealSubject doSomething...</span><br><span class="line">ProxySubject doOtherThing...</span><br></pre></td></tr></table></figure>
<p>代理模式在日常的场景中也经常碰到，比较常见的一个场景就是游戏代练，套进去上面的代码可以写个比较生动的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"操作Throwable游戏角色打怪升级"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Player player;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyPlayer</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.player = player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		login();</span><br><span class="line">		<span class="keyword">this</span>.player.playGame();</span><br><span class="line">		logout();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"登录Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"退出Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式有几个比较大的优点：</p>
<ul>
<li>职责清晰：也就是真实主题角色只需要实现具体的逻辑，不需关注代理类的职责，而代理类也只需要处理预处理和后置的逻辑，类的职责分明。</li>
<li>高扩展性：由于职责分明，也就是真实主题角色可以随时修改实现，这样就能通过更新或者替换真实主题的实现并且不改变代理主题角色的情况下改变具体功能。</li>
<li>高灵活性：主要体现在后面提到的动态代理。</li>
</ul>
<h2 id="JDK动态代理的核心API">JDK动态代理的核心API</h2>
<p>JDK动态代理提供外部使用的主要依赖两个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>：可以理解为代理类的工厂类(其实也是父类，见下文)。</li>
<li><code>java.lang.reflect.InvocationHandler</code>：代理实例需要实现的调用处理器接口。</li>
</ul>
<h3 id="Proxy">Proxy</h3>
<p><code>java.lang.reflect.Proxy</code>是JDK动态代理的核心类，它的核心功能是提供静态方法来为一组接口动态地生成代理类并且返回代理实例对象，类似于代理类实例的工厂类。<code>java.lang.reflect.Proxy</code>主要提供四个public静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>InvocationHandler getInvocationHandler(Object proxy)</code>：通过制定的代理类实例查找它关联的调用处理器实例。</li>
<li><code>Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>：用于获取关联于指定类装载器和一组接口的动态代理类的类对象，也就是获取<code>$ProxyXXX</code>的类型，此方法在JDK9以后标记为过期，原因是：在命名模块中生成的代理类是封闭的，模块外的代码无法访问这些类(违反模块规则调用了会抛异常)。</li>
<li><code>boolean isProxyClass(Class&lt;?&gt; cl)</code>：用于判断指定类是否是一个动态代理类。</li>
<li><code>Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code>：这个是JDK动态代理最核心的方法，用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，也就是生成<code>$ProxyXXX</code>的实例。此方法需要指定类加载器<code>java.lang.ClassLoader</code>，Proxy静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是在运行时动态生成的而非预存在于任何一个.class文件中。interfaces是Class数组，也就是需要使用InvocationHandler进行代理访问的接口类型数组，这里的h参数就是调用处理器的实例。</li>
</ul>
<h3 id="InvocationHandler">InvocationHandler</h3>
<p><code>java.lang.reflect.InvocationHandler</code>是调用处理器接口，它自定义了一个<code>invoke</code>方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>proxy：Object类型，此参数即是代理类实例，也就是<code>$ProxyXXX</code>的实例。</li>
<li>method：<code>java.lang.reflect.Method</code>类型，被调用的方法的实例。</li>
<li>args：Object[]类型，被调用方法的参数数组。</li>
</ul>
<p>实现<code>java.lang.reflect.InvocationHandler</code>接口，通过实现<code>invoke</code>方法即可添加代理访问的逻辑，在这个逻辑代码块中除了可以调用委托类的方法，还可以织入额外的自定义逻辑，AOP就是这样实现的。</p>
<h2 id="JDK动态代理的流程">JDK动态代理的流程</h2>
<p>JDK动态代理的使用流程如下：</p>
<ul>
<li>1、通过实现<code>java.lang.reflect.InvocationHandler</code>接口创建自定义的调用处理器。</li>
<li>2、通过为<code>java.lang.reflect.Proxy</code>类指定<code>ClassLoader</code>对象和一组interface来创建动态代理类。</li>
<li>3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型。</li>
<li>4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy为包括Interface接口在内的一组接口动态创建代理类的类对象</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span>, ... &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过反射从生成的类对象获得构造函数对象</span></span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数对象创建动态代理类实例</span></span><br><span class="line">Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的过程比较复杂，可以进行精简。简化后的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl实现了InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">handler</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="JDK动态代理的机制">JDK动态代理的机制</h2>
<p>首先是JDK动态代理生成的代理类本身的特点：</p>
<ul>
<li>1、<strong>包(或者JDK9引入的模块)</strong>：如果所代理的接口都是public的，那么它将被定义在包<code>com.sun.proxy</code>；如果所代理的接口中有非public的接口(因为接口不能被定义为protect或private，所以除public之外就是默认的package访问级别，修饰符为default)，那么它将被定义在该接口所在包(假设代理了<code>throwable.club</code>包中的某非public接口A，那么新生成的代理类所在的包就是<code>throwable.club</code>)，值得注意的是，<strong>如果接口数组中存在非public的接口，那么它们必须在同一个包路径下，否则会抛异常</strong>。这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问。</li>
<li>2、<strong>类修饰符</strong>：该代理类具有final和public修饰符，<strong>意味着它可以被所有的类访问，但是不能被再度继承</strong>。</li>
<li>3、<strong>类名</strong>：代理类名称格式是<code>$ProxyN</code>，其中N是一个逐一递增的阿拉伯数字，代表<code>java.lang.reflect.Proxy</code>类第N次生成的动态代理类，值得注意的一点是，并不是每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口(包括接口排列的顺序相同)试图重复创建动态代理类，它会从缓存中获取先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li>
<li>4、<strong>类继承关系</strong>：代理类的继承关系图如下：</li>
</ul>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-1.png" alt="j-r-d-p-1.png"></p>
<p>由图可知，<code>java.lang.reflect.Proxy</code>类是代理类的父类，这个规则适用于所有由<code>java.lang.reflect.Proxy</code>创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。</p>
<h3 id="代理类实例的特点">代理类实例的特点</h3>
<p>每个代理类实例都会关联一个调用处理器对象，可以通过<code>java.lang.reflect.Proxy</code>提供的静态方法<code>getInvocationHandler()</code>去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行，此外，值得注意的是，代理类的根类<code>java.lang.Object</code>中有三个方法也同样会被分派到调用处理器的<code>invoke</code>方法执行，它们是<code>hashCode</code>、<code>equals</code>和<code>toString</code>，可能的原因有：</p>
<ul>
<li>一、因为这些方法为public且非final类型，能够被代理类覆盖。</li>
<li>二、因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口(或继承于该接口的某子接口)的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。</li>
</ul>
<h3 id="被代理的一组接口的特点">被代理的一组接口的特点</h3>
<p>首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过65535，这是JVM设定的限制，这一点在代理类生成的时候也做了判断。</p>
<h3 id="异常处理">异常处理</h3>
<p>从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于Throwable接口，但事实是否如此呢？答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛Throwable异常。那么如果在invoke方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Jdk动态代理类已经为我们设计好了解决方法：它将会抛出<code>UndeclaredThrowableException</code> 异常。这个异常是一个<code>RuntimeException</code>类型，所以不会引起编译错误。通过该异常的<code>getCause</code>方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。</p>
<h2 id="JDK动态代理源码分析">JDK动态代理源码分析</h2>
<p>因为JDK动态代理核心逻辑都在<code>java.lang.reflect.Proxy</code>类中，下面简单分析一下这个类的源码。先看<code>Proxy</code>类中的几个重要的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口组中接口都为为public时候代理类创建的包路径：com.sun.proxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的构造方法参数类型数组，可见代理类的构造参数只有InvocationHandler类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存了所有已经调用过setAccessible(true)的代理类的构造(Constructor)实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这里注意到<code>ClassLoaderValue</code>，下文会调用到它的一个很复杂的调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intf是Class&lt;?&gt;类型</span></span><br><span class="line"><span class="comment">//loader是类加载器实例</span></span><br><span class="line"><span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">    loader,</span><br><span class="line">    (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BiFunction&lt;? <span class="keyword">super</span> ClassLoader,? <span class="keyword">super</span> CLV,? extends V&gt; mappingFunction)</span> </span></span><br><span class="line"><span class="function">						<span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>上面的<code>computeIfAbsent</code>中使用了函数式接口和Lambda表达式，如果Lambda表达式玩的比较熟练看起来应该没问题，它的功能可以解读为：通过接口类型和类加载器实例计算通过接口类型和类加载器实例构建<code>ProxyBuilder</code>实例并且调用<code>ProxyBuilder#build()</code>得到的结果，如果结果已经存在则直接返回缓存。其实<code>computeIfAbsent</code>在<code>Map</code>接口中也定义了同样的方法，功能是相似的。</p>
<p>接着看<code>Proxy</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此可以明确一点，既然所有动态代理类都是<code>java.lang.reflect.Proxy</code>的子类，那么它们一定具备一个包含<code>InvocationHandler</code>参数的构造器。接着查看``方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空判断									  </span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="comment">// 当前调用类获取</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">                                    ? <span class="keyword">null</span></span><br><span class="line">                                    : Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 获取代理类的构造器实例								</span></span><br><span class="line">    Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line">    <span class="comment">// 生成代理实例</span></span><br><span class="line">    <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看<code>getProxyConstructor</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; getProxyConstructor(Class&lt;?&gt; caller,</span><br><span class="line">                                                  ClassLoader loader,</span><br><span class="line">                                                  Class&lt;?&gt;... interfaces)&#123;</span><br><span class="line">    <span class="comment">// 这里需要区分代理接口数组中只有单个接口和多个接口的逻辑				  </span></span><br><span class="line">    <span class="comment">// 而基本的逻辑都是先校验当前调用类的权限，后续获取Constructor实例委托到ProxyBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length == <span class="number">1</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; intf = interfaces[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 接口克隆</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfsArray = interfaces.clone();</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intfsArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intfs).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明确，核心的逻辑都交给了<code>Proxy</code>的内部类<code>ProxyBuilder</code>完成，先看<code>ProxyBuilder</code>的静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的简单类名的前置字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成下一个代理类的数字计数器，记住它是静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了已经生成的代理类-Boolean的映射，已经生成过对应代理类则记录为true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Boolean&gt; reverseProxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个代理接口的情况，其实也是把接口转换为List</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, Class&lt;?&gt; intf) &#123;</span><br><span class="line">    <span class="keyword">this</span>(loader, Collections.singletonList(intf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个代理接口的情况</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    <span class="comment">// 通过JVM参数强制关闭动态代理功能则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isModuleSystemInited()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Proxy is not supported until "</span></span><br><span class="line">                + <span class="string">"module system is fully initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理接口数量不能超过65535，也就是最多代理65535个接口</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded: "</span></span><br><span class="line">                + interfaces.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集接口数组中所有接口的非静态方法的返回值类型、共享(shared)参数类型和共享(shared)异常类型，注释说是收集代理接口的方法签名</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; refTypes = referencedTypes(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保上一步得到的代理接口方法签名的类型都是"可见(其实就是类型都存在)"的，通过遍历调用Class.forName(type.getName(), false, ld)去判断</span></span><br><span class="line">    validateProxyInterfaces(loader, interfaces, refTypes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="comment">// 获取代理类最终生成的模块，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、所有代理接口的修饰符都为public，接口所在模块都能公开访问，则返回unnamed模块</span></span><br><span class="line">    <span class="comment">// 2、如果有任意的代理接口是包私有，则返回该包所在的模块		、</span></span><br><span class="line">    <span class="comment">// 3、所有代理接口的修饰符都为public，有任意至少一个接口所在模块不能公开访问，则返回该不能公开访问的模块，</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = mapToModule(loader, interfaces, refTypes);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getLoader</span><span class="params">(<span class="keyword">module</span>)</span> </span>== loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个构造器处理的逻辑也是相对复杂，主要是因为引入模块管理的概念，接着看<code>ProxyBuilder#build()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; build() &#123;</span><br><span class="line">    <span class="comment">// 定义代理类，实际上是动态生成代理类字节码和缓存它的类型的过程</span></span><br><span class="line">    Class&lt;?&gt; proxyClass = defineProxyClass(<span class="keyword">module</span>, interfaces);</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回代理类的构造</span></span><br><span class="line">        cons = proxyClass.getConstructor(constructorParams);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到逻辑最复杂的代理类的生成过程<code>ProxyBuilder#defineProxyClass()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">    <span class="comment">// 这里就是定义代理类包路径的逻辑，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、代理接口数组所有接口都是public修饰，则代理类包路径为com.sun.proxy</span></span><br><span class="line">    <span class="comment">// 2、代理接口数组有任意接口是包私有的，则代理类包路径为该私有包的路径			</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;  <span class="comment">// non-public, final</span></span><br><span class="line">            String pkg = intf.getPackageName();</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面几个if都是包路径的合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// all proxy interfaces are public</span></span><br><span class="line">        proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + <span class="string">"."</span> + m.getName()</span><br><span class="line">                               : PROXY_PACKAGE_PREFIX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proxyPkg.isEmpty() &amp;&amp; m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Unnamed package cannot be added to "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.getDescriptor().packages().contains(proxyPkg)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(proxyPkg + <span class="string">" not exist in "</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器加1返回新的计数值			</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    <span class="comment">// 生成代理类全类名，一个常见的格式是：com.sun.proxy.$Proxy1</span></span><br><span class="line">    String proxyName = proxyPkg.isEmpty()</span><br><span class="line">                            ? proxyClassNamePrefix + num</span><br><span class="line">                            : proxyPkg + <span class="string">"."</span> + proxyClassNamePrefix + num;</span><br><span class="line">    ClassLoader loader = getLoader(m);</span><br><span class="line">    trace(proxyName, m, loader, interfaces);</span><br><span class="line">    <span class="comment">// 动态生成代理类字节码字节数组			</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Unsafe定义代理类-这里是通过字节码定义新的类				</span></span><br><span class="line">        Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span><br><span class="line">                                         <span class="number">0</span>, proxyClassFile.length,</span><br><span class="line">                                         loader, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 缓存代理类已经生成过的标记												 </span></span><br><span class="line">        reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步为止，代理类的生成过程已经大致分析完毕，<code>ProxyGenerator</code>中涉及到大量字节码操作，这里就不深入分析了。那么回到最前面的方法，得到代理类和它的构造实例，接着就可以生成代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(Class&lt;?&gt; caller, // <span class="keyword">null</span> <span class="keyword">if</span> no SecurityManager</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Constructor&lt;?&gt; cons,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(caller, cons.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里简单反射调用Constructor#newInstance(h)</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结一下：</p>
<ul>
<li><strong>接口数组中所有接口元素的类修饰符最好一致为public。如果接口数组中存在非default修饰的接口元素，那么接口数组中的所有接口类都要放在同一个包下，并且都要使用default修饰。</strong></li>
<li>很少情况下我们修改接口的修饰符，默认为public，那么所有代理类的包路径都是<code>com.sun.proxy</code>，全类名是:<code>com.sun.proxy.$ProxyN</code>。</li>
<li>代理接口数量不能超过65535。</li>
</ul>
<h2 id="JDK动态代理类的源代码">JDK动态代理类的源代码</h2>
<p>前面已经分析完了代理类的生成过程，这里举个简单的使用例子，并且观察生成的动态代理类的源代码。</p>
<p><strong>使用例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before say hello...</span><br><span class="line">throwable say hello!</span><br><span class="line">After say hello...</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在被代理类<code>DefaultSimple</code>实例的方法调用前后织入了自定义的逻辑，这就是通过JDK动态代理实现AOP的底层原理。在JDK8中可以直接使用<code>sun.misc.ProxyGenerator</code>去输出代理类的class文件，但是JDK11中这个代理类生成器已经变成<code>java.lang.reflect.ProxyGenerator</code>，并且这个类是包私有的，我们无法使用，但是它提供了<code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>这个VM参数让我们可以保存代理类的class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># JVM参数</span><br><span class="line">-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>配置好VM参数后，再次调用mian方法就能看到在项目的顶层包路径下看到对应的类<code>com.sun.proxy.$Proxy0</code>，目前从<code>java.lang.reflect.ProxyGenerator</code>源码看无法控制代理类文件的输出路径，生成的代理类内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类的代码比较简单，有如下几个特点：</p>
<ul>
<li>1、代理类继承于<code>java.lang.reflect.Proxy</code>，实现了接口数组中的接口元素类，构造函数只有一个<code>InvocationHandler</code>类型的参数。</li>
<li>2、接口中的所有被代理方法包括<code>equals</code>、<code>toString</code>、<code>hashCode</code>都建立了一个对应的Method私有静态实例，在最后面的静态代码块中实例化。</li>
<li>3、所有代理方法都是用public final修饰，也就是代理类中的代理方法是不能覆盖的。</li>
<li>4、所有代理方法都是通过<code>InvocationHandler</code>实例的<code>invoke</code>方法进行调用的，记得第一个参数是代理类实例本身，如果用了在<code>InvocationHandler#invoke()</code>方法实现过程中使用了这个参数有可能造成死循环。</li>
</ul>
<h2 id="小结">小结</h2>
<p>诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的<strong>单继承机制</strong>注定了这些动态代理类们无法实现对class的动态代理(所以只能代理接口，实际上是基于反射对方法级别的逻辑进行编织)。有很多条理由，可以否定对class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。但是，不完美并不等于不伟大，伟大是一种本质，JDK动态代理就是佐例。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第1部分</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy2/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第2部分</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 e-20181208 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/blog/categories/Java/page/2/">
            <section class="post prev white-box card-shadow " >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          3 / 4
        </p>
        
          <a class="next" rel="next" href="/blog/categories/Java/page/4/">
            <section class="post next white-box card-shadow ">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  

</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
