<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: Java | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 10px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/cglib-dynamic-proxy-analyze/">
      CGLIB动态代理原理分析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Framework/Cglib/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Framework&nbsp;/&nbsp;Cglib</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：21分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T17:13:03+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>CGLIB动态代理原理分析</h1>
<h2 id="前提">前提</h2>
<p>前一篇文章介绍了CGLIB中常用的API，实际上使用了<code>Enhancer</code>和<code>MethodInterceptor</code>之后会生成代理子类，这篇文章就是分析一下CGLIB动态代理的原理。</p>
<h2 id="CGLIB动态代理原理分析">CGLIB动态代理原理分析</h2>
<p>我们经常说CGLIB的动态代理的底层通过被代理类生成代理子类实现的，那么下面我们就分析一下生成的子类到底是什么样的。开启CGLIB的debug模式，输出它生成的类到指定的目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebuggingCglibDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String METHOD_NAME = <span class="string">"sayHello"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String location = DebuggingCglibDemo.class.getResource("").getPath() + "debugging/";</span><br><span class="line">		System.out.println(<span class="string">"location -&gt; "</span> + location);</span><br><span class="line">		System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, location);</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				Object result;</span><br><span class="line">				<span class="keyword">if</span> (METHOD_NAME.equals(method.getName())) &#123;</span><br><span class="line">					System.out.println(<span class="string">"Before invoking sayHello..."</span>);</span><br><span class="line">					result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">					System.out.println(<span class="string">"After invoking sayHello..."</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location -&gt; /D:/Projects/cglib-seed/target/classes/club/throwable/cglib/debugging/</span><br><span class="line">CGLIB debugging enabled, writing to <span class="string">'/D:/Projects/cglib-seed/target/classes/club/throwable/cglib/debugging/'</span></span><br><span class="line">Before invoking sayHello...</span><br><span class="line">After invoking sayHello...</span><br><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<p>这个时候，看下target下面生成的类如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/c-d-p-1.png" alt="c-d-p-1"></p>
<p>一共有五个类：</p>
<p><code>../net.sf.cglib</code>包下：</p>
<p><code>MethodWrapper$MethodWrapperKey$$KeyFactoryByCGLIB$$d45e49f7.class</code><br>
<code>Enhancer$EnhancerKey$$KeyFactoryByCGLIB$$7fb24d72.class</code></p>
<p>这两个类主要很缓存的Key相关，这里不做详细展开。</p>
<p>用户自定义包<code>../club/throwable/cglib</code>包下：</p>
<ul>
<li><code>SampleClass$$EnhancerByCGLIB$$53c7afed$$FastClassByCGLIB$$da5c8621.class</code></li>
<li><code>SampleClass$$EnhancerByCGLIB$$53c7afed.class</code></li>
<li><code>SampleClass$$FastClassByCGLIB$$cf1a549b.class</code></li>
</ul>
<p>这三个就是实际使用到的子类，其中有一个是被代理类的直接子类<code>SampleClass$$EnhancerByCGLIB$$53c7afed</code>，其他的两个是<code>FastClass</code>。</p>
<p>接着我们先看一下SampleClass$$EnhancerByCGLIB$$53c7afed这个类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line">与Java原生代理类似，仍然以静态变量保存了指向代理方法的引用</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object CGLIB$FACTORY_DATA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object CGLIB$CALLBACK_FILTER;</span><br><span class="line">	<span class="comment">//每个函数有两个反射方法，一个是通过原生反射获得的，另外一个是通过Cglib构建的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$sayHello$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$sayHello$<span class="number">0</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$equals$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$equals$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$toString$<span class="number">2</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$toString$<span class="number">2</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$hashCode$<span class="number">3</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$hashCode$<span class="number">3</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$clone$<span class="number">4</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$clone$<span class="number">4</span>$Proxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里通过静态代码块初始化上面用到的静态变量，主要使用到反射</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        Class var0 = Class.forName(<span class="string">"club.throwable.cglib.SampleClass$$EnhancerByCGLIB$$53c7afed"</span>);</span><br><span class="line">        Class var1;</span><br><span class="line">        Method[] var10000 = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"hashCode"</span>, <span class="string">"()I"</span>, <span class="string">"clone"</span>, <span class="string">"()Ljava/lang/Object;"</span>&#125;, (var1 = Class.forName(<span class="string">"java.lang.Object"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$equals$<span class="number">1</span>$Method = var10000[<span class="number">0</span>];</span><br><span class="line">        CGLIB$equals$<span class="number">1</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"equals"</span>, <span class="string">"CGLIB$equals$1"</span>);</span><br><span class="line">        CGLIB$toString$<span class="number">2</span>$Method = var10000[<span class="number">1</span>];</span><br><span class="line">        CGLIB$toString$<span class="number">2</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"toString"</span>, <span class="string">"CGLIB$toString$2"</span>);</span><br><span class="line">        CGLIB$hashCode$<span class="number">3</span>$Method = var10000[<span class="number">2</span>];</span><br><span class="line">        CGLIB$hashCode$<span class="number">3</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"()I"</span>, <span class="string">"hashCode"</span>, <span class="string">"CGLIB$hashCode$3"</span>);</span><br><span class="line">        CGLIB$clone$<span class="number">4</span>$Method = var10000[<span class="number">3</span>];</span><br><span class="line">        CGLIB$clone$<span class="number">4</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"()Ljava/lang/Object;"</span>, <span class="string">"clone"</span>, <span class="string">"CGLIB$clone$4"</span>);</span><br><span class="line">        CGLIB$sayHello$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[]&#123;<span class="string">"sayHello"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>&#125;, (var1 = Class.forName(<span class="string">"club.throwable.cglib.SampleClass"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        CGLIB$sayHello$<span class="number">0</span>$Proxy = MethodProxy.create(var1, var0, <span class="string">"(Ljava/lang/String;)Ljava/lang/String;"</span>, <span class="string">"sayHello"</span>, <span class="string">"CGLIB$sayHello$0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法就是直接调用原来的被代理类(父类)的方法</span></span><br><span class="line">    <span class="keyword">final</span> String CGLIB$sayHello$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sayHello(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个方法就是通过方法代理进行回调，里面用到了Callback实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$sayHello$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$sayHello$<span class="number">0</span>$Proxy) : <span class="keyword">super</span>.sayHello(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> CGLIB$equals$<span class="number">1</span>(Object var1) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object var2 = var10000.intercept(<span class="keyword">this</span>, CGLIB$equals$<span class="number">1</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$equals$<span class="number">1</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> var2 == <span class="keyword">null</span> ? <span class="keyword">false</span> : (Boolean)var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.equals(var1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String CGLIB$toString$<span class="number">2</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$toString$<span class="number">2</span>$Method, CGLIB$emptyArgs, CGLIB$toString$<span class="number">2</span>$Proxy) : <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CGLIB$hashCode$<span class="number">3</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var10000 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object var1 = var10000.intercept(<span class="keyword">this</span>, CGLIB$hashCode$<span class="number">3</span>$Method, CGLIB$emptyArgs, CGLIB$hashCode$<span class="number">3</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="number">0</span> : ((Number)var1).intValue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object CGLIB$clone$<span class="number">4</span>() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? var10000.intercept(<span class="keyword">this</span>, CGLIB$clone$<span class="number">4</span>$Method, CGLIB$emptyArgs, CGLIB$clone$<span class="number">4</span>$Proxy) : <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(Signature var0) &#123;</span><br><span class="line">        String var10000 = var0.toString();</span><br><span class="line">        <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1816210712</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"sayHello(Ljava/lang/String;)Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$sayHello$<span class="number">0</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">508378822</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"clone()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$clone$<span class="number">4</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$equals$<span class="number">1</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$toString$<span class="number">2</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> CGLIB$hashCode$<span class="number">3</span>$Proxy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = var0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed var1 = (SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed)var0;</span><br><span class="line">        <span class="keyword">if</span> (!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            <span class="keyword">if</span> (var10000 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                var10000 = CGLIB$STATIC_CALLBACKS;</span><br><span class="line">                <span class="keyword">if</span> (CGLIB$STATIC_CALLBACKS == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var1);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Callback var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[]&#123;var1&#125;);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Class[] var1, Object[] var2, Callback[] var3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(var3);</span><br><span class="line">        SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed var10000 = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000.&lt;init&gt;();</span><br><span class="line">            CGLIB$SET_THREAD_CALLBACKS((Callback[])<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> var10000;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        MethodInterceptor var10000;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            var10000 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10000;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">int</span> var1, Callback var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[]&#123;<span class="keyword">this</span>.CGLIB$CALLBACK_0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(Callback[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类十分长，因为里面有很多的变量，它们都通过了静态代码块使用反射初始化。类的代码比JDK动态代理的子类多，因此生成效率会比较低。相关比较重要的注释已经写在类中，我们最主要关注两点：</p>
<ul>
<li>第一点：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$sayHello$<span class="number">0</span>$Method;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$sayHello$<span class="number">0</span>$Proxy;</span><br></pre></td></tr></table></figure>
<p>这两个静态变量都是指向<code>sayHello</code>这个方法，<code>CGLIB$sayHello$0$Method</code>直接指向父类方法，<code>CGLIB$sayHello$0$Proxy</code>是CGLIB生成的方法代理。</p>
<ul>
<li>第二点：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法就是直接调用原来的被代理类(父类)的方法</span></span><br><span class="line"><span class="keyword">final</span> String CGLIB$sayHello$<span class="number">0</span>(String var1) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.sayHello(var1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个方法就是通过方法代理进行回调，里面用到了Callback实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">sayHello</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">    MethodInterceptor var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.CGLIB$CALLBACK_0 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        var10000 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到Callback会直接调用父类的原方法</span></span><br><span class="line">    <span class="keyword">return</span> var10000 != <span class="keyword">null</span> ? (String)var10000.intercept(<span class="keyword">this</span>, CGLIB$sayHello$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[]&#123;var1&#125;, CGLIB$sayHello$<span class="number">0</span>$Proxy) : <span class="keyword">super</span>.sayHello(var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是如果想要启用CGLIB的回调，我们主观上应该是这样操作的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed sample = <span class="keyword">new</span> SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed();</span><br><span class="line">sample.sayHello(<span class="string">"doge"</span>);</span><br></pre></td></tr></table></figure>
<p>但是由于这个代理类是动态生成的，只能通过反射调用。</p>
<p>那么，剩下的两个<code>FastClass</code>的作用是什么？我们先看一下<code>MethodProxy</code>的<code>invoke()</code>和<code>invokeSuper()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//初始化FastClass中的index索引</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">         Object var1 = <span class="keyword">this</span>.initLock;</span><br><span class="line">         <span class="keyword">synchronized</span>(<span class="keyword">this</span>.initLock) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 MethodProxy.CreateInfo ci = <span class="keyword">this</span>.createInfo;</span><br><span class="line">                 MethodProxy.FastClassInfo fci = <span class="keyword">new</span> MethodProxy.FastClassInfo();</span><br><span class="line">                 fci.f1 = helper(ci, ci.c1);</span><br><span class="line">                 fci.f2 = helper(ci, ci.c2);</span><br><span class="line">                 fci.i1 = fci.f1.getIndex(<span class="keyword">this</span>.sig1);</span><br><span class="line">                 fci.i2 = fci.f2.getIndex(<span class="keyword">this</span>.sig2);</span><br><span class="line">                 <span class="keyword">this</span>.fastClassInfo = fci;</span><br><span class="line">                 <span class="keyword">this</span>.createInfo = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.init();</span><br><span class="line">         MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">         <span class="keyword">return</span> fci.f1.invoke(fci.i1, obj, args);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">         <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.fastClassInfo.i1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Protected method: "</span> + <span class="keyword">this</span>.sig1);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">throw</span> var5;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invokeSuper</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.init();</span><br><span class="line">         MethodProxy.FastClassInfo fci = <span class="keyword">this</span>.fastClassInfo;</span><br><span class="line">         <span class="keyword">return</span> fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InvocationTargetException var4) &#123;</span><br><span class="line">         <span class="keyword">throw</span> var4.getTargetException();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里，两个方法各自使用了不同的<code>FastClassInfo</code>实例<code>fci.f2</code>和<code>fci.f2</code>。其中，<code>SampleClass$$FastClassByCGLIB$$cf1a549b.class</code>是对应于父类，而<code>SampleClass$$EnhancerByCGLIB$$53c7afed$$FastClassByCGLIB$$da5c8621</code>是对应于CGLIB生成的被代理类的子类。下面展开<code>SampleClass$$EnhancerByCGLIB$$53c7afed$$FastClassByCGLIB$$da5c8621</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>$$<span class="title">EnhancerByCGLIB</span>$$53<span class="title">c7afed</span>$$<span class="title">FastClassByCGLIB</span>$$<span class="title">da5c8621</span> <span class="keyword">extends</span> <span class="title">FastClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> SampleClass$$EnhancerByCGLIB$$<span class="number">53</span>c7afed$$FastClassByCGLIB$$da5c8621(Class var1) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Signature var1)</span> </span>&#123;</span><br><span class="line">        String var10000 = var1.toString();</span><br><span class="line">        <span class="keyword">switch</span>(var10000.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">2055565910</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$SET_THREAD_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1882565338</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$equals$1(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1816210712</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"sayHello(Ljava/lang/String;)Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1457535688</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$STATICHOOK1()V"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1411842725</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$hashCode$3()I"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">894172689</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"newInstance(Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">623122092</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$findMethodProxy(Lnet/sf/cglib/core/Signature;)Lnet/sf/cglib/proxy/MethodProxy;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">508378822</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"clone()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">419626537</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"setCallbacks([Lnet/sf/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">560567118</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"setCallback(ILnet/sf/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">811063227</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"newInstance([Ljava/lang/Class;[Ljava/lang/Object;[Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">973717575</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"getCallbacks()[Lnet/sf/cglib/proxy/Callback;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1221173700</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"newInstance([Lnet/sf/cglib/proxy/Callback;)Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1230699260</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"getCallback(I)Lnet/sf/cglib/proxy/Callback;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1298742135</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$sayHello$0(Ljava/lang/String;)Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1306468936</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$toString$2()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1584330438</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$SET_STATIC_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1800494055</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"CGLIB$clone$4()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1826985398</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1913648695</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1984935277</span>:</span><br><span class="line">            <span class="keyword">if</span> (var10000.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(String var1, Class[] var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">2012993625</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"sayHello"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"java.lang.String"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1983192202</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$sayHello$0"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"java.lang.String"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1776922004</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"toString"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1295482945</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"equals"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"java.lang.Object"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1053468136</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"getCallbacks"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">124978609</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$equals$1"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"java.lang.Object"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">60403779</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$SET_STATIC_CALLBACKS"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"[Lnet.sf.cglib.proxy.Callback;"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">29025555</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$hashCode$3"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">85179481</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$SET_THREAD_CALLBACKS"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"[Lnet.sf.cglib.proxy.Callback;"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">94756189</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"clone"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">147696667</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"hashCode"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">161998109</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$STATICHOOK1"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">495524492</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"setCallbacks"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"[Lnet.sf.cglib.proxy.Callback;"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">13</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1154623345</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$findMethodProxy"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"net.sf.cglib.core.Signature"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1543336189</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$toString$2"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1811874389</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"newInstance"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    String var10001 = var2[<span class="number">0</span>].getName();</span><br><span class="line">                    <span class="keyword">switch</span>(var10001.hashCode()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> -<span class="number">845341380</span>:</span><br><span class="line">                        <span class="keyword">if</span> (var10001.equals(<span class="string">"net.sf.cglib.proxy.Callback"</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1730110032</span>:</span><br><span class="line">                        <span class="keyword">if</span> (var10001.equals(<span class="string">"[Lnet.sf.cglib.proxy.Callback;"</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"[Ljava.lang.Class;"</span>) &amp;&amp; var2[<span class="number">1</span>].getName().equals(<span class="string">"[Ljava.lang.Object;"</span>) &amp;&amp; var2[<span class="number">2</span>].getName().equals(<span class="string">"[Lnet.sf.cglib.proxy.Callback;"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1817099975</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"setCallback"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"int"</span>) &amp;&amp; var2[<span class="number">1</span>].getName().equals(<span class="string">"net.sf.cglib.proxy.Callback"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1905679803</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"getCallback"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (var2[<span class="number">0</span>].getName().equals(<span class="string">"int"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1951977610</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"CGLIB$clone$4"</span>)) &#123;</span><br><span class="line">                <span class="keyword">switch</span>(var2.length) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(Class[] var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(var1.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="number">53</span>c7afed var10000 = (<span class="number">53</span>c7afed)var2;</span><br><span class="line">        <span class="keyword">int</span> var10001 = var1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(var10001) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Boolean(var10000.equals(var3[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.toString();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Integer(var10000.hashCode());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.clone();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.newInstance((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.newInstance((Callback)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.newInstance((Class[])var3[<span class="number">0</span>], (Object[])var3[<span class="number">1</span>], (Callback[])var3[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.sayHello((String)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                var10000.setCallback(((Number)var3[<span class="number">0</span>]).intValue(), (Callback)var3[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="number">53</span>c7afed.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                <span class="number">53</span>c7afed.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.getCallbacks();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.getCallback(((Number)var3[<span class="number">0</span>]).intValue());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                var10000.setCallbacks((Callback[])var3[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">53</span>c7afed.CGLIB$findMethodProxy((Signature)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">                <span class="number">53</span>c7afed.CGLIB$STATICHOOK1();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.CGLIB$sayHello$<span class="number">0</span>((String)var3[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.CGLIB$clone$<span class="number">4</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Boolean(var10000.CGLIB$equals$<span class="number">1</span>(var3[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Integer(var10000.CGLIB$hashCode$<span class="number">3</span>());</span><br><span class="line">            <span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">return</span> var10000.CGLIB$toString$<span class="number">2</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot find matching method/constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> var1, Object[] var2)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="number">53</span>c7afed var10000 = <span class="keyword">new</span> <span class="number">53</span>c7afed;</span><br><span class="line">        <span class="number">53</span>c7afed var10001 = var10000;</span><br><span class="line">        <span class="keyword">int</span> var10002 = var1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(var10002) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                var10001.&lt;init&gt;();</span><br><span class="line">                <span class="keyword">return</span> var10000;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvocationTargetException(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot find matching method/constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类更加长，但是其实大部分都是<code>switch-case</code>的代码块，它的功能就是为方法的调用添加基于整型数字的索引，主要目的是为了减少反射调用的时间，将反射调用转化为直接调用。简单来说，<strong>invokeSuper的流程就是这样的</strong>：</p>
<ul>
<li>通过MethodProxy的init方法，用当前方法的Signature(签名)构建两个FastClass实例(当然，这里会做缓存)和当前方法对应的index，存放在FastClassInfo实例中。</li>
<li>通过FastClassInfo中的FastClass实例和index，在FastClass中找到对应的方法(在<code>switch-case</code>块中基于整数索引index进行查找)直接调用。</li>
</ul>
<p>直观来看，CGLIB在类生成期间的操作会相对耗时，而且生成的类数目比较多，会占据大量永久代或者元空间的内存。子类一旦生成，后面的方法调用就会变成搜索方法索引和直接调用，这样的操作在特定的条件下效率会比JDK的反射高。这里特定的场景是指CGLIB子类中的<code>switch-case</code>块不大并且当前调用的方法的index在switch-case块的前部而不是中后部(<strong>简单来说就是子类中的方法要尽量少从而提高switch-case中的搜寻效率</strong>)。详细可以参考这篇性能对比的文章：<a href="https://www.jianshu.com/p/1aaacf92e2cd" target="_blank" rel="noopener">cglib和jdk动态代理调用性能测</a></p>
<h2 id="小结">小结</h2>
<p>CGLIB提供了许多基于代码生成的高级功能的API，可以在通过上面的例子熟悉它的使用，并且在合适的场景用于实战中。可能最常用到的是基于Enhancer的动态代理，这里总结一下CGLIB和JDK动态代理的区别(老生常谈)：</p>
<ul>
<li>JDK动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类，但是该普通类必须能够被继承(不能用final修饰符)。</li>
<li>JDK动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行修改，使用了FastClass的特性，在某些情况下类的方法执行会比较高效。</li>
</ul>
<p>(本文完 e-a-20181216 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Cglib/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Cglib</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/cglib-api/">
      简述CGLIB常用API
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Framework/Cglib/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Framework&nbsp;/&nbsp;Cglib</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：5.5k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：24分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T16:55:12+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>简述CGLIB常用API</h1>
<h2 id="CGLIB简介">CGLIB简介</h2>
<p>CGLIB，即Code Generation Library，是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（例如Spring）中，用以提供方法拦截操作。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。CGLIB作为一个开源项目，其代码托管在github，地址为：<strong><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">https://github.com/cglib/cglib</a></strong>。</p>
<p>CGLIB的github简介：CGLIB - 字节码生成库，是用于生成和转换Java字节码的高级API。它被AOP、测试、数据访问框架用于生成动态代理对象和拦截字段访问。(原文：cglib - Byte Code Generation Library is high level API to generate and transform Java byte code. It is used by AOP, testing, data access frameworks to generate dynamic proxy objects and intercept field access.)</p>
<p>CGLIB提供两种类型的JAR包：</p>
<ul>
<li>cglib-nodep-x.x.x.jar：使用nodep包不需要关联ASM的jar包，也就是jar包内部包含ASM的类库。</li>
<li>cglib-x.x.x.jar：使用此jar包需要另外提供ASM的jar包，否则运行时报错，建议选用不包含ASM类库的jar包，可以方便控制ASM的。</li>
</ul>
<p>本文中使用的CGLIB依赖为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib-nodep<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="CGLIB基本原理">CGLIB基本原理</h2>
<ul>
<li>基本原理：动态生成一个要代理类的子类(<strong>被代理的类作为继承的父类</strong>)，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用Java反射的JDK动态代理要快，因为它采用了整形变量建立了方法索引。</li>
<li>底层实现：使用字节码处理框架ASM，用于转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求必须对JVM内部结构包括class文件的格式和JVM指令集都很熟悉，<strong>否则一旦出现错误将会是JVM崩溃级别的异常</strong>。</li>
<li>劣势：对于final方法或者final的类，无法进行代理。</li>
</ul>
<h2 id="CGLIB的包结构">CGLIB的包结构</h2>
<ul>
<li>net.sf.cglib.core：底层字节码处理类，它们大部分与ASM有关系，在使用者角度来看不需要过多关注此包。</li>
<li>net.sf.cglib.transform：编译期或运行期类和类文件的转换。</li>
<li>net.sf.cglib.proxy：实现创建代理和方法拦截器的类。</li>
<li>net.sf.cglib.reflect：反射相关工具类。</li>
<li>net.sf.cglib.util：集合排序等工具类。</li>
<li>net.sf.cglib.beans：JavaBean相关的工具类。</li>
</ul>
<h2 id="CGLIB常用API介绍">CGLIB常用API介绍</h2>
<p>下面介绍一下CGLIB中常用的API，先建立一个模特接口类和普通模特类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.format(<span class="string">"%s say hello!"</span>, name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SampleInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enhancer">Enhancer</h2>
<p>Enhancer，即(字节码)增强器。它是CGLIB库中最常用的一个类，功能JDK动态代理中引入的Proxy类差不多，但是Enhancer既能够代理普通的Java类，也能够代理接口。Enhancer创建一个被代理对象的子类并且拦截所有的方法调用（包括从Object中继承的toString和hashCode方法）。Enhancer不能够拦截final方法，例如Object.getClass()方法，这是由于final关键字的语义决定的。基于同样的道理，Enhancer也不能对fianl类进行代理操作。这也是Hibernate为什么不能持久化final关键字修饰的类的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancerClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//使用FixedValue，拦截返回值，每次返回固定值"Doge say hello!"</span></span><br><span class="line">		enhancer.setCallback((FixedValue) () -&gt; <span class="string">"Doge say hello!"</span>);</span><br><span class="line">		SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable-10086"</span>));</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable-doge"</span>));</span><br><span class="line">		System.out.println(sampleClass.toString());</span><br><span class="line">		System.out.println(sampleClass.getClass());</span><br><span class="line">		System.out.println(sampleClass.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doge say hello!</span><br><span class="line">Doge say hello!</span><br><span class="line">Doge say hello!</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">club</span>.<span class="title">throwable</span>.<span class="title">cglib</span>.<span class="title">SampleClass</span>$$<span class="title">EnhancerByCGLIB</span>$$6<span class="title">f6e7a68</span></span></span><br><span class="line">Exception in thread "main" java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Number</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>上述代码中，FixedValue用来对所有拦截的方法返回相同的值，从输出我们可以看出来，Enhancer对非final方法test()、toString()、hashCode()进行了拦截，没有对getClass进行拦截。由于hashCode()方法需要返回一个Number，但是我们返回的是一个String，这解释了上面的程序中为什么会抛出异常。</p>
<p><code>Enhancer3setSuperclass()</code>用来设置父类型，从<code>toString()</code>方法可以看出，使用CGLIB生成的类为被代理类的一个子类，类简写名称为<code>SampleClass$$EnhancerByCGLIB$$e3ea9b7</code>。</p>
<p><code>Enhancer#create(Class[] argumentTypes, Object[] arguments)</code>方法是用来创建增强对象的，其提供了很多不同参数的方法用来匹配被增强类的不同构造方法。我们也可以先使用<code>Enhancer#createClass()</code>来创建字节码(.class)，然后用字节码加载完成后的类动态生成增强后的对象。Enhancer中还有其他几个方法名为create的方法，提供不同的参数选择，具体可以自行查阅。</p>
<p>下面再举个例子说明一下使用Enhancer代理接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancerInterfaceDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;SampleInterface<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">		enhancer.setCallback((FixedValue) () -&gt; <span class="string">"Doge say hello!"</span>);</span><br><span class="line">		SampleInterface sampleInterface = (SampleInterface) enhancer.create();</span><br><span class="line">		System.out.println(sampleInterface.sayHello(<span class="string">"throwable-10086"</span>));</span><br><span class="line">		System.out.println(sampleInterface.sayHello(<span class="string">"throwable-doge"</span>));</span><br><span class="line">		System.out.println(sampleInterface.toString());</span><br><span class="line">		System.out.println(sampleInterface.getClass());</span><br><span class="line">		System.out.println(sampleInterface.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果和上一个例子一致。</p>
<h2 id="Callback">Callback</h2>
<p>Callback，即回调。值得注意的是，它是一个标识接口(空接口，没有任何方法)，它的回调时机是生成的代理类的方法被调用的时候。也就是说，生成的代理类的方法被调用的时候，Callback的实现逻辑就会被调用。Enhancer通过<code>setCallback()</code>和<code>setCallbacks()</code>设置<code>Callback</code>，<strong>设置了多个Callback实例将会按照设置的顺序进行回调</strong>。CGLIB中提供的Callback的子类有以下几种：</p>
<ul>
<li>NoOp</li>
<li>FixedValue</li>
<li>InvocationHandler</li>
<li>MethodInterceptor</li>
<li>Dispatcher</li>
<li>LazyLoader</li>
</ul>
<h3 id="NoOp">NoOp</h3>
<p>NoOp，No Operation，也就是不做任何操作。这个回调实现只是简单地把方法调用委托给了被代理类的原方法(也就是调用原始类的原始方法)，不做任何其它的操作，所以不能使用在接口代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoOpDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		enhancer.setCallback(NoOp.INSTANCE);</span><br><span class="line">		SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<h3 id="FixedValue">FixedValue</h3>
<p>FixedValue，Fixed Value，即固定值。它提供了一个<code>loadObject()</code>方法，不过这个方法返回的不是代理对象，而是原方法调用想要的结果。也就是说，在这个Callback里面，看不到任何原方法的信息，也就没有调用原方法的逻辑，不管原方法是什么都只会调用<code>loadObject()</code>并返回一个固定结果。需要注意的是，如果loadObject()方法的返回值并不能转换成原方法的返回值类型，那么会抛出类型转换异常(ClassCastException)。</p>
<p>最前面的Enhancer两个例子就是用FixedValue做分析的，这里不再举例。</p>
<h3 id="InvocationHandler">InvocationHandler</h3>
<p>InvocationHandler全类名为<code>net.sf.cglib.proxy.InvocationHandler</code>，它的功能和JDK动态代理中的<code>java.lang.reflect.InvocationHandler</code>类似，提供了一个<code>Object invoke(Object proxy, Method method, Object[] objects)</code>方法。需要注意的是：所有对invoke方法的参数proxy对象的方法调用都会被委托给同一个InvocationHandler，所以可能会导致无限循环(因为invoke中调用的任何原代理类方法，均会重新代理到invoke方法中)。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerDeadLoopDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> method.invoke(o, objects);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的main方法执行后会直接爆栈，因为<code>method#invoke()</code>方法会重新调用InvocationHandler的invoke方法，形成死循环。正确的使用例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (!Objects.equals(method.getDeclaringClass(), Object<span class="class">.<span class="keyword">class</span>) &amp;&amp; <span class="title">Objects</span>.<span class="title">equals</span>(<span class="title">String</span>.<span class="title">class</span>, <span class="title">method</span>.<span class="title">getReturnType</span>())) </span>&#123;</span><br><span class="line">					<span class="keyword">return</span> String.format(<span class="string">"%s say hello!"</span>, objects);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"No one say hello!"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<h3 id="MethodInterceptor">MethodInterceptor</h3>
<p>MethodInterceptor，即方法拦截器，这是一个功能很强大的接口，它可以实现类似于AOP编程中的环绕增强（Around Advice）。它只有一个方法<code>public Object intercept(Object obj,java.lang.reflect.Method method,Object[] args,MethodProxy methodProxy) throws Throwable</code>。设置了MethodInterceptor后，代理类的所有方法调用都会转而执行这个接口中的intercept方法而不是原方法。如果需要在intercept方法中执行原方法可以使用参数method基于代理实例obj进行反射调用，但是使用方法代理methodProxy效率会更高（反射调用比正常的方法调用的速度慢很多）。MethodInterceptor的生成效率不高，它的优势在于调用效率，它需要产生不同类型的字节码，并且需要生成一些运行时对象(InvocationHandler就不需要)。注意，在使用MethodProxy调用invokeSuper方法相当于通过方法代理直接调用原类的对应方法，如果调用MethodProxy的invoke会进入死循环导致爆栈，原因跟InvocationHandler差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInterceptorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		enhancer.setSuperclass(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Before invoking sayHello..."</span>);</span><br><span class="line">				Object result = methodProxy.invokeSuper(obj, objects);</span><br><span class="line">				System.out.println(<span class="string">"After invoking sayHello..."</span>);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		SampleClass sampleClass = (SampleClass) enhancer.create();</span><br><span class="line">		System.out.println(sampleClass.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before invoking sayHello...</span><br><span class="line">After invoking sayHello...</span><br><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<p>这个例子就是Spring的AOP中的环绕增强(Around Advice)的简化版，这里没有改变原来的方法的行为，只是在方法调用前和调用后织入额外的逻辑。</p>
<h3 id="Dispatcher">Dispatcher</h3>
<p>Dispatcher，即分发器，提供一个方法<code>Object loadObject() throws Exception;</code>，同样地返回一个代理对象，这个对象同样可以代理原方法的调用。Dispatcher的<code>loadObject()</code>方法在每次发生对原方法的调用时都会被调用并返回一个代理对象来调用原方法。Dispatcher可以类比为Spring中的Prototype类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		SampleInterfaceImpl impl = <span class="keyword">new</span> SampleInterfaceImpl();</span><br><span class="line">		enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;SampleInterface<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> Dispatcher() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				COUNTER.incrementAndGet();</span><br><span class="line">				<span class="keyword">return</span> impl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		SampleInterface sampleInterface = (SampleInterface) enhancer.create();</span><br><span class="line">		System.out.println(sampleInterface.sayHello(<span class="string">"throwable-1"</span>));</span><br><span class="line">		System.out.println(sampleInterface.sayHello(<span class="string">"throwable-2"</span>));</span><br><span class="line">		System.out.println(COUNTER.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">SampleInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SampleInterfaceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"SampleInterfaceImpl init..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Hello i am SampleInterfaceImpl!"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleInterfaceImpl init...</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>计数器输出为2，印证了每次调用方法都会回调Dispatcher中的实例进行调用。</p>
<h3 id="LazyLoader">LazyLoader</h3>
<p>LazyLoader，即懒加载器，它只提供了一个方法<code>Object loadObject() throws Exception;</code>，loadObject()方法会在第一次被代理类的方法调用时触发，它返回一个代理类的对象，这个对象会被存储起来然后负责所有被代理类方法的调用，就像它的名字说的那样，一种lazy加载模式。如果被代理类或者代理类的对象的创建比较麻烦，而且不确定它是否会被使用，那么可以选择使用这种lazy模式来延迟生成代理。LazyLoader可以类比为Spring中的Lazy模式的Singleton。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		SampleInterfaceImpl impl = <span class="keyword">new</span> SampleInterfaceImpl();</span><br><span class="line">		enhancer.setInterfaces(<span class="keyword">new</span> Class[]&#123;SampleInterface<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">		enhancer.setCallback(<span class="keyword">new</span> LazyLoader() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				COUNTER.incrementAndGet();</span><br><span class="line">				<span class="keyword">return</span> impl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		SampleInterface sampleInterface = (SampleInterface) enhancer.create();</span><br><span class="line">		System.out.println(sampleInterface.sayHello(<span class="string">"throwable-1"</span>));</span><br><span class="line">		System.out.println(sampleInterface.sayHello(<span class="string">"throwable-2"</span>));</span><br><span class="line">		System.out.println(COUNTER.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">SampleInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SampleInterfaceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"SampleInterfaceImpl init..."</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Hello i am SampleInterfaceImpl!"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SampleInterfaceImpl init...</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line">Hello i am SampleInterfaceImpl!</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>计数器输出为1，印证了LazyLoader中的实例只回调了1次，这就是懒加载。</p>
<h2 id="BeanCopier">BeanCopier</h2>
<p>JavaBean属性拷贝器，提供从一个JavaBean实例中拷贝属性到另一个JavaBean实例中，注意类型必须完全匹配属性才能拷贝成功(<strong>原始类型和其包装类不属于相同类型</strong>)。它还提供了一个<code>net.sf.cglib.core.Converter</code>转换器回调接口让使用者控制拷贝的过程。注意，BeanCopier内部使用了缓存和基于ASM动态生成BeanCopier的子类实现的转换方法中直接使用实例的Getter和Setter方法，拷贝速度极快(<strong>BeanCopier属性拷贝比直接的Setter、Getter稍慢，稍慢的原因在于首次需要动态生成BeanCopier的子类，一旦子类生成完成之后就和直接的Setter、Getter效率一致，但是效率远远高于其他使用反射的工具类库</strong>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanCopierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, BeanCopier&gt; CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//这里useConverter设置为false,调用copy方法的时候不能传入转换器实例</span></span><br><span class="line">		BeanCopier beanCopier;</span><br><span class="line">		String key = generateCacheKey(Person<span class="class">.<span class="keyword">class</span>, <span class="title">Person</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (CACHE.containsKey(key)) &#123;</span><br><span class="line">			beanCopier = CACHE.get(key);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			beanCopier = BeanCopier.create(Person<span class="class">.<span class="keyword">class</span>, <span class="title">Person</span>.<span class="title">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line">			CACHE.put(key, beanCopier);</span><br><span class="line">		&#125;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.setId(<span class="number">10086L</span>);</span><br><span class="line">		person.setName(<span class="string">"throwable"</span>);</span><br><span class="line">		person.setAge(<span class="number">25</span>);</span><br><span class="line">		Person newPerson = <span class="keyword">new</span> Person();</span><br><span class="line">		beanCopier.copy(person, newPerson, <span class="keyword">null</span>); <span class="comment">//这里转换器实例要传null</span></span><br><span class="line">		System.out.println(newPerson);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">generateCacheKey</span><span class="params">(Class&lt;?&gt; source, Class&lt;?&gt; target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> String.format(<span class="string">"%s-%s"</span>, source.getName(), target.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ToString</span></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Long id;</span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">		<span class="keyword">private</span> Integer age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanCopierDemo.Person(id=<span class="number">10086</span>, name=throwable, age=<span class="number">25</span>)</span><br></pre></td></tr></table></figure>
<p>在使用BeanCopier时候最好缓存BeanCopier实例，因为构造BeanCopier实例是一个耗时的操作。</p>
<h2 id="ImmutableBean">ImmutableBean</h2>
<p>ImmutableBean，即不可变的Bean。ImmutableBean允许创建一个原来对象的包装类，这个包装类是不可变的，任何改变底层对象的包装类操作都会抛出IllegalStateException。但是我们可以通过直接操作底层对象来改变包装类对象。这有点类似于Guava中的不可变视图或者JDK中的不可变集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableBeanDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.setName(<span class="string">"throwable"</span>);</span><br><span class="line">		Person immutablePerson = (Person) ImmutableBean.create(person);</span><br><span class="line">		System.out.println(immutablePerson.getName());</span><br><span class="line">		person.setName(<span class="string">"doge"</span>);</span><br><span class="line">		System.out.println(immutablePerson.getName());</span><br><span class="line">		immutablePerson.setName(<span class="string">"throwable-doge"</span>);</span><br><span class="line">		System.out.println(immutablePerson.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">throwable</span><br><span class="line">doge</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalStateException: Bean is immutable</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="BeanGenerator">BeanGenerator</h2>
<p>BeanGenerator，即Bean生成器，使用它能够在运行时动态的创建一个JavaBean。可以直接设置父类，生成的JavaBean就是父类类型的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanGeneratorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		BeanGenerator beanGenerator = <span class="keyword">new</span> BeanGenerator();</span><br><span class="line">		beanGenerator.addProperty(<span class="string">"name"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		Object target = beanGenerator.create();</span><br><span class="line">		Method setter = target.getClass().getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		Method getter = target.getClass().getDeclaredMethod(<span class="string">"getName"</span>);</span><br><span class="line">		setter.invoke(target, <span class="string">"throwable"</span>);</span><br><span class="line">		System.out.println(getter.invoke(target));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable</span><br></pre></td></tr></table></figure>
<h2 id="BulkBean">BulkBean</h2>
<p>相比于BeanCopier，BulkBean创建时候依赖于确定的目标类型，Setter和Getter方法名称列表以及参数类型，它将copy的动作拆分为<code>getPropertyValues()</code>和<code>setPropertyValues()</code>两个方法，允许自定义处理属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BulkBeanDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		BulkBean bulkBean = BulkBean.create(</span><br><span class="line">				Person<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">				new String[]&#123;"getName"&#125;,</span><br><span class="line">				<span class="keyword">new</span> String[]&#123;<span class="string">"setName"</span>&#125;,</span><br><span class="line">				<span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.setName(<span class="string">"throwable"</span>);</span><br><span class="line">		Object[] propertyValues = bulkBean.getPropertyValues(person);</span><br><span class="line">		System.out.println(Arrays.toString(propertyValues));</span><br><span class="line">		bulkBean.setPropertyValues(person, <span class="keyword">new</span> Object[]&#123;<span class="string">"doge"</span>&#125;);</span><br><span class="line">		System.out.println(person.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[throwable]</span><br><span class="line">doge</span><br></pre></td></tr></table></figure>
<h2 id="BeanMap">BeanMap</h2>
<p>BeanMap类实现了JDK的<code>java.util.Map</code>接口，将一个JavaBean对象中的所有属性转换为一个String-To-Obejct的Map实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.setName(<span class="string">"throwable"</span>);</span><br><span class="line">		BeanMap beanMap = BeanMap.create(person);</span><br><span class="line">		System.out.println(beanMap);</span><br><span class="line">		System.out.println(beanMap.get(<span class="string">"name"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;name=throwable&#125;</span><br><span class="line">throwable</span><br></pre></td></tr></table></figure>
<h2 id="KeyFactory">KeyFactory</h2>
<p>KeyFactory源码中的注释是：Generates classes to handle multi-valued keys, for use in things such as Maps and Sets. Code for equals and hashCode methods follow the the rules laid out in Effective Java by Joshua Bloch.(翻译一下：通过生成类来处理多值键，以便在诸如Map和集合之类的东西中使用。equals和hashCode方法的代码遵循Joshua Bloch在《Effective Java》中列出的规则)。</p>
<p><strong>什么叫multi-valued keys?</strong></p>
<p>就是有多个键的组合，一起作为一个Key。</p>
<p>比如[a b c]是一个组合，一起作为一个key，[2 3]也可以是作为一个key。</p>
<p>KeyFactory就是用来生成这样一组Key的，通过两组的equals，hashCode等方法判断是否为同一组key的场景。为了描述Key的组合，需要定义一个接口，仅提供一个方法，叫做<code>newInstance()</code>，且返回值为Object，这个是使用KeyFactory的要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyFactoryDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		KeyFactoryInterface keyFactoryInterface1 = (KeyFactoryInterface) KeyFactory.create(KeyFactoryInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		KeyFactoryInterface keyFactoryInterface2 = (KeyFactoryInterface) KeyFactory.create(KeyFactoryInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(keyFactoryInterface1 == keyFactoryInterface2);</span><br><span class="line">		System.out.println(keyFactoryInterface1.equals(keyFactoryInterface2));</span><br><span class="line">		Object key1 = keyFactoryInterface1.newInstance(<span class="number">1</span>, <span class="string">"doge"</span>);</span><br><span class="line">		Object key2 = keyFactoryInterface1.newInstance(<span class="number">1</span>, <span class="string">"doge"</span>);</span><br><span class="line">		System.out.println(key1.equals(key2));</span><br><span class="line">		key2 = keyFactoryInterface1.newInstance(<span class="number">1</span>, <span class="string">"doge10086"</span>);</span><br><span class="line">		System.out.println(key1.equals(key2));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">KeyFactoryInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function">Object <span class="title">newInstance</span><span class="params">(Integer a, String b)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="Mixin">Mixin</h2>
<p>Mixin能够让我们将多个接口的多个实现合并到同一个接口的单个实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MixinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">InterfaceFirst</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function">String <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">InterfaceSecond</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function">String <span class="title">second</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplFirst</span> <span class="keyword">implements</span> <span class="title">InterfaceFirst</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"I am first"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplSecond</span> <span class="keyword">implements</span> <span class="title">InterfaceSecond</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">second</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"I am second"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">MixinImpl</span> <span class="keyword">extends</span> <span class="title">InterfaceFirst</span>, <span class="title">InterfaceSecond</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Mixin mixin = Mixin.create(<span class="keyword">new</span> Class[]&#123;InterfaceFirst<span class="class">.<span class="keyword">class</span>, <span class="title">InterfaceSecond</span>.<span class="title">class</span>, <span class="title">MixinImpl</span>.<span class="title">class</span>&#125;,</span></span><br><span class="line">				new Object[]&#123;new ImplFirst(), new ImplSecond()&#125;);</span><br><span class="line">		MixinImpl mixinImpl = (MixinImpl) mixin;</span><br><span class="line">		System.out.println(mixinImpl.first());</span><br><span class="line">		System.out.println(mixinImpl.second());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am first</span><br><span class="line">I am second</span><br></pre></td></tr></table></figure>
<h2 id="StringSwitcher">StringSwitcher</h2>
<p>用来模拟一个String到int类型的Map类型。如果在Java7以后的版本中，类似一个switch块的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringSwitcherDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		StringSwitcher stringSwitcher = StringSwitcher.create(<span class="keyword">new</span> String[]&#123;<span class="string">"one"</span>, <span class="string">"two"</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="keyword">true</span>);</span><br><span class="line">		System.out.println(stringSwitcher.intValue(<span class="string">"one"</span>));</span><br><span class="line">		System.out.println(stringSwitcher.intValue(<span class="string">"two"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="InterfaceMaker">InterfaceMaker</h2>
<p>接口生成器，底层依赖ASM的相关API。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceMakerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Signature signature = <span class="keyword">new</span> Signature(<span class="string">"foo"</span>, Type.DOUBLE_TYPE, <span class="keyword">new</span> Type[]&#123;Type.INT_TYPE&#125;);</span><br><span class="line">		InterfaceMaker interfaceMaker = <span class="keyword">new</span> InterfaceMaker();</span><br><span class="line">		interfaceMaker.add(signature, <span class="keyword">new</span> Type[<span class="number">0</span>]);</span><br><span class="line">		Class&lt;?&gt; clazz = interfaceMaker.create();</span><br><span class="line">		Method[] methods = clazz.getMethods();</span><br><span class="line">		System.out.println(methods.length);</span><br><span class="line">		Method foo = methods[<span class="number">0</span>];</span><br><span class="line">		System.out.println(foo.getReturnType());</span><br><span class="line">		System.out.println(Arrays.toString(foo.getParameterTypes()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">[<span class="keyword">int</span>]</span><br></pre></td></tr></table></figure>
<p>上述的InterfaceMaker创建的接口中只含有一个方法，签名为<code>double foo(int)</code>。InterfaceMaker与上面介绍的其他类不同，它依赖ASM中的Type类型。由于接口仅仅只用做在编译时期进行类型检查，因此在一个运行的应用中动态的创建接口没有什么作用。但是InterfaceMaker可以用来自动生成接口代码，为以后的开发做准备。</p>
<h2 id="MethodDelegate">MethodDelegate</h2>
<p>方法代理，个人认为作用不太大，这里仅举例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDelegateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">MethodDelegateInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function">String <span class="title">getValueFromDelegate</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Delegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Delegate <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Delegate delegate = <span class="keyword">new</span> Delegate();</span><br><span class="line">		delegate.setValue(<span class="string">"throwable"</span>);</span><br><span class="line">		MethodDelegate methodDelegate = MethodDelegate.create(delegate, <span class="string">"getValue"</span>, MethodDelegateInterface<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		MethodDelegateInterface delegateInterface = (MethodDelegateInterface) methodDelegate;</span><br><span class="line">		System.out.println(delegateInterface.getValueFromDelegate());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable</span><br></pre></td></tr></table></figure>
<h2 id="MulticastDelegate">MulticastDelegate</h2>
<p>多重代理，个人认为作用不太大，这里仅举例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MulticastDelegateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DelegateProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MulticastBean</span> <span class="keyword">implements</span> <span class="title">DelegateProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		MulticastDelegate multicastDelegate = MulticastDelegate.create(DelegateProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		MulticastBean first = <span class="keyword">new</span> MulticastBean();</span><br><span class="line">		MulticastBean second = <span class="keyword">new</span> MulticastBean();</span><br><span class="line">		multicastDelegate = multicastDelegate.add(first);</span><br><span class="line">		multicastDelegate = multicastDelegate.add(second);</span><br><span class="line">		DelegateProvider provider = (DelegateProvider) multicastDelegate;</span><br><span class="line">		provider.setValue(<span class="string">"throwable"</span>);</span><br><span class="line">		System.out.println(first.getValue());</span><br><span class="line">		System.out.println(second.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">throwable</span><br><span class="line">throwable</span><br></pre></td></tr></table></figure>
<h2 id="ConstructorDelegate">ConstructorDelegate</h2>
<p>构造器代理，个人认为作用不太大，这里仅举例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorDelegateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstructorInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function">Object <span class="title">newInstance</span><span class="params">(String value)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ConstructorImpl</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ConstructorImpl <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ConstructorInterface constructorInterface =</span><br><span class="line">				(ConstructorInterface) ConstructorDelegate.create(ConstructorImpl<span class="class">.<span class="keyword">class</span>, <span class="title">ConstructorInterface</span>.<span class="title">class</span>)</span>;</span><br><span class="line">		ConstructorImpl constructorImpl = (ConstructorImpl) constructorInterface.newInstance(<span class="string">"throwable"</span>);</span><br><span class="line">		System.out.println(ConstructorImpl<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">constructorImpl</span>.<span class="title">getClass</span>()))</span>;</span><br><span class="line">		System.out.println(constructorImpl.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line">throwable</span><br></pre></td></tr></table></figure>
<h2 id="ParallelSorter">ParallelSorter</h2>
<p>并行排序器，能够对多个数组同时进行排序，目前实现的算法有归并排序(mergeSort)和快速排序(quickSort)，查看源码的时候发现Float和Double类的比较直接用大于或者小于，有可能造成这两个类型的数据排序不准确(应该使用Float或Double的compare方法进行比较)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallelSorterDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Integer[][] array = <span class="keyword">new</span> Integer[][]&#123;</span><br><span class="line">				&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">0</span>&#125;,</span><br><span class="line">				&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		ParallelSorter.create(array).quickSort(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (Integer[] row : array) &#123;</span><br><span class="line">			System.out.println(Arrays.toString(row));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<h2 id="FastClass">FastClass</h2>
<p>FastClass就是对Class对象进行特定的处理，认知上可以理解为索引类，比如通过数组保存method引用，因此FastClass引出了一个index下标的新概念，比如<code>getIndex(String name, Class[] parameterTypes)</code>就是以前的获取method的方法。通过数组存储method，constructor等class信息，从而将原先的反射调用，转化为class.index的直接调用以提高效率，从而体现所谓的FastClass。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FastClass fastClass = FastClass.create(SampleClass<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		FastMethod fastMethod = fastClass.getMethod(<span class="string">"sayHello"</span>, <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">		SampleClass sampleClass = <span class="keyword">new</span> SampleClass();</span><br><span class="line">		System.out.println(fastMethod.invoke(sampleClass, <span class="keyword">new</span> Object[]&#123;<span class="string">"throwable"</span>&#125;));</span><br><span class="line">		System.out.println(fastMethod.getIndex());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>实际上，在接口或者代理类的方法比较少的时候，使用<code>FastClass</code>进行方法调用有可能比原生反射方法调用<code>Method#invoke()</code>高，但是实际还是需要进行测试和分析，不能盲目一概而论。</p>
<h2 id="小结">小结</h2>
<p>本文简单分析了一下CGLIB中的常用API，其实在实现AOP、动态代理和反射调用的时候，最常用的是字节码增强器Enhancer、回调(Callback)以及快类(FastClass)，掌握它们的使用方式有利于进行AOP编程以及反射性能创新性提升。</p>
<p>(本文完 r-a-20181216 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Cglib/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Cglib</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/java-reflection-optimal-performance/">
      深入分析Java反射(八)-优化反射调用性能
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：8分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T12:01:22+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(八)-优化反射调用性能</h1>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>前一篇文章已经介绍了反射调用的底层原理，其实在实际中对大多数Java使用者来说更关系的是如何提升反射调用的性能，本文主要提供几个可行的方案。另外，由于方法调用时频率最高的反射操作，会着重介绍方法的反射调用优化。</p>
<h2 id="方法一：选择合适的API">方法一：选择合适的API</h2>
<p>选择合适的API主要是在获取反射相关元数据的时候尽量避免使用遍历的方法，例如：</p>
<ul>
<li>获取Field实例：尽量避免频繁使用<code>Class#getDeclaredFields()</code>或者<code>Class#getFields()</code>，应该根据Field的名称直接调用<code>Class#getDeclaredField()</code>或者<code>Class#getField()</code>。</li>
<li>获取Method实例：尽量避免频繁使用<code>Class#getDeclaredMethods()</code>或者<code>Class#getMethods()</code>，应该根据Method的名称和参数类型数组调用<code>Class#getDeclaredMethod()</code>或者<code>Class#getMethod()</code>。</li>
<li>获取Constructor实例：尽量避免频繁使用<code>Class#getDeclaredConstructors()</code>或者<code>Class#getConstructors()</code>，应该根据Constructor参数类型数组调用<code>Class#getDeclaredConstructor()</code>或者<code>Class#getConstructor()</code>。</li>
</ul>
<p>其实思路很简单，除非我们想要获取Class的所有Field、Method或者Constructor，否则应该避免使用返回一个集合或者数组的API，这样子能减少遍历或者判断带来的性能损耗。</p>
<h2 id="方法二：缓存反射操作相关元数据">方法二：缓存反射操作相关元数据</h2>
<p>使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的，这里列举几个相对耗时的场景：</p>
<ul>
<li>获取Class实例：<code>Class#forName()</code>，此方法可以查看源码，耗时相对其他方法高得多。</li>
<li>获取Field实例：<code>Class#getDeclaredField()</code>、<code>Class#getDeclaredFields()</code>、<code>Class#getField()</code>、<code>Class#getFields()</code>。</li>
<li>获取Method实例：<code>Class#getDeclaredMethod()</code>、<code>Class#getDeclaredMethods()</code>、<code>Class#getMethod()</code>、<code>Class#getMethods()</code>。</li>
<li>获取Constructor实例：<code>Class#getDeclaredConstructor()</code>、<code>Class#getDeclaredConstructors()</code>、<code>Class#getConstructor()</code>、<code>Class#getConstructors()</code>。</li>
</ul>
<p>这里举个简单的例子，需要反射调用一个普通JavaBean的Setter和Getter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;ReflectionMetadata&gt;&gt; METADATA = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; CLASSES = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析的时候尽量放在&lt;cinit&gt;里面</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = JavaBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		CLASSES.put(clazz.getName(), clazz);</span><br><span class="line">		List&lt;ReflectionMetadata&gt; metadataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		METADATA.put(clazz, metadataList);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (Field f : clazz.getDeclaredFields()) &#123;</span><br><span class="line">				ReflectionMetadata metadata = <span class="keyword">new</span> ReflectionMetadata();</span><br><span class="line">				metadataList.add(metadata);</span><br><span class="line">				metadata.setTargetClass(clazz);</span><br><span class="line">				metadata.setField(f);</span><br><span class="line">				String name = f.getName();</span><br><span class="line">				Class&lt;?&gt; type = f.getType();</span><br><span class="line">				metadata.setReadMethod(clazz.getDeclaredMethod(String.format(<span class="string">"get%s%s"</span>, Character.toUpperCase(name.charAt(<span class="number">0</span>)), name.substring(<span class="number">1</span>))));</span><br><span class="line">				metadata.setWriteMethod(clazz.getDeclaredMethod(String.format(<span class="string">"set%s%s"</span>, Character.toUpperCase(name.charAt(<span class="number">0</span>)), name.substring(<span class="number">1</span>)), type));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String fieldName = <span class="string">"name"</span>;</span><br><span class="line">		Class&lt;JavaBean&gt; javaBeanClass = JavaBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		JavaBean javaBean = <span class="keyword">new</span> JavaBean();</span><br><span class="line">		invokeSetter(javaBeanClass, javaBean, fieldName , <span class="string">"Doge"</span>);</span><br><span class="line">		System.out.println(invokeGetter(javaBeanClass,javaBean, fieldName));</span><br><span class="line">		invokeSetter(javaBeanClass.getName(), javaBean, fieldName , <span class="string">"Throwable"</span>);</span><br><span class="line">		System.out.println(invokeGetter(javaBeanClass.getName(),javaBean, fieldName));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeSetter</span><span class="params">(String className, Object target, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		METADATA.get(CLASSES.get(className)).forEach(each -&gt; &#123;</span><br><span class="line">			Field field = each.getField();</span><br><span class="line">			<span class="keyword">if</span> (field.getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					each.getWriteMethod().invoke(target, value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeSetter</span><span class="params">(Class&lt;?&gt; clazz, Object target, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		METADATA.get(clazz).forEach(each -&gt; &#123;</span><br><span class="line">			Field field = each.getField();</span><br><span class="line">			<span class="keyword">if</span> (field.getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					each.getWriteMethod().invoke(target, value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invokeGetter</span><span class="params">(String className, Object target, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ReflectionMetadata metadata : METADATA.get(CLASSES.get(className))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.getField().getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> metadata.getReadMethod().invoke(target);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invokeGetter</span><span class="params">(Class&lt;?&gt; clazz, Object target, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ReflectionMetadata metadata : METADATA.get(clazz)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.getField().getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> metadata.getReadMethod().invoke(target);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Class&lt;?&gt; targetClass;</span><br><span class="line">		<span class="keyword">private</span> Field field;</span><br><span class="line">		<span class="keyword">private</span> Method readMethod;</span><br><span class="line">		<span class="keyword">private</span> Method writeMethod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，解析反射元数据进行缓存的操作最好放在静态代码块或者首次调用的时候(也就是懒加载)，这样能够避免真正调用的时候总是需要重新加载一次反射相关元数据。</p>
<h2 id="方法三：反射操作转变为直接调用">方法三：反射操作转变为直接调用</h2>
<p>&quot;反射操作转变为直接调用&quot;并不是完全不依赖于反射的类库，这里的做法是把反射操作相关元数据直接放置在类的成员变量中，这样就能省去从缓存中读取反射相关元数据的消耗，而所谓&quot;直接调用&quot;一般是通过继承或者实现接口实现。有一些高性能的反射类库也会使用一些创新的方法：例如使用成员属性缓存反射相关元数据，并且把方法调用通过数字建立索引[Number-&gt;Method]或者建立索引类(像<code>CGLIB</code>的<code>FastClass</code>)，<strong>这种做法在父类或者接口方法比较少的时候会有一定的性能提升，但是实际上性能评估需要从具体的场景通过测试分析结果而不能盲目使用</strong>，使用这个思想的类库有<code>CGLIB</code>、<code>ReflectASM</code>等。&quot;反射操作转变为直接调用&quot;的最典型的实现就是JDK的动态代理，这里翻出之前动态代理那篇文章的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的话<code>Simple</code>接口实例虽然最终是通过反射调用<code>sayHello(String var1)</code>方法，但是相关元数据在静态代码块中创建并且已经缓存在类成员属性中，那么反射调用方法的性能已经优化到极致，剩下的都只是Native方法的耗时，这一点使用者在编码层面已经没有办法优化，只能通过升级JVM(JDK)、使用JIT编译器等非编码层面的手段提升反射性能。</p>
<h2 id="小结">小结</h2>
<p>本文主要从编码层面分析反射操作一些性能优化的可行经验或者方案，或许有其他更好的优化方案，具体还是需要看使用场景。</p>
<p>(本文完 e-a-20181216 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/java-reflection-implementance/">
      深入分析Java反射(七)-简述反射调用的底层实现
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：14分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T01:09:52+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(七)-简述反射调用的底层实现</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射调用的底层实现，当然还没有能力分析JVM的实现，这里只分析到最终Native方法的调用点。底层会依赖到Unsafe类，可以的话可以看下笔者之前写的一篇文章《神奇的魔法类和双刃剑-Unsafe》。</p>
<h2 id="反射调用的底层实现探究">反射调用的底层实现探究</h2>
<p>主要考虑下面的情况：</p>
<ul>
<li>属性操作：<code>java.lang.reflect.Field#set(Object obj, Object value)</code>和<code>java.lang.reflect.Field#get(Object obj)</code>。</li>
<li>构造器调用：<code>java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>。</li>
<li>方法调用：<code>java.lang.reflect.Method#invoke(Object obj, Object... args)</code>。</li>
</ul>
<h3 id="处理属性操作的底层实现">处理属性操作的底层实现</h3>
<p>属性操作方法<code>Field#set(Object obj, Object value)</code>和<code>Field#get(Object obj)</code>底层都是委托到<code>jdk.internal.reflect.FieldAccessor</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FieldAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setByte</span><span class="params">(Object obj, <span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChar</span><span class="params">(Object obj, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShort</span><span class="params">(Object obj, <span class="keyword">short</span> s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(Object obj, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FieldAccessor</code>接口有很多的实现，<code>FieldAccessor</code>接口实例是通过<code>jdk.internal.reflect.ReflectionFactory</code>这个工厂构造的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field field, <span class="keyword">boolean</span> override)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    Field root = langReflectAccess.getRoot(field);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// FieldAccessor will use the root unless the modifiers have</span></span><br><span class="line">        <span class="comment">// been overrridden</span></span><br><span class="line">        <span class="keyword">if</span> (root.getModifiers() == field.getModifiers() || !override) &#123;</span><br><span class="line">            field = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UnsafeFieldAccessorFactory.newFieldAccessor(field, override);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终委托到<code>UnsafeFieldAccessorFactory#newFieldAccessor()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeFieldAccessorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field field, <span class="keyword">boolean</span> override)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; type = field.getType();</span><br><span class="line">        <span class="keyword">boolean</span> isStatic = Modifier.isStatic(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isFinal = Modifier.isFinal(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isVolatile = Modifier.isVolatile(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isQualified = isFinal || isVolatile;</span><br><span class="line">        <span class="keyword">boolean</span> isReadOnly = isFinal &amp;&amp; (isStatic || !override);</span><br><span class="line">        <span class="keyword">if</span> (isStatic) &#123;</span><br><span class="line">            <span class="comment">// This code path does not guarantee that the field's</span></span><br><span class="line">            <span class="comment">// declaring class has been initialized, but it must be</span></span><br><span class="line">            <span class="comment">// before performing reflective operations.</span></span><br><span class="line">            UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(field.getDeclaringClass());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isQualified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticBooleanFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticByteFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticShortFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticCharacterFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticIntegerFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticLongFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticFloatFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticDoubleFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticObjectFieldAccessorImpl(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticBooleanFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticByteFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticShortFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticCharacterFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticIntegerFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticLongFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticFloatFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticDoubleFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticObjectFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isQualified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeBooleanFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeByteFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeShortFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeCharacterFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeIntegerFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeLongFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeFloatFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeDoubleFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeObjectFieldAccessorImpl(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedBooleanFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedByteFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedShortFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedCharacterFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedIntegerFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedLongFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedFloatFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedDoubleFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedObjectFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意一下属性修饰符的判断：</p>
<ul>
<li>isStatic：静态属性，也就是static关键字修饰的属性。</li>
<li>isFinal：final关键字修饰的属性。</li>
<li>isVolatile：valatile关键字修饰的属性。</li>
<li>isQualified：valatile关键字或者final关键字修饰的属性。</li>
<li>isReadOnly：是否只读属性，final关键字修饰的属性或者static关键字修饰并且不能覆盖(override = false)的属性。</li>
</ul>
<p>通过上面修饰符做判断，得到最终的<code>FieldAccessor</code>实现。这里挑一个例子进行分析，例如<strong>一个普通非静态没有volatile和final关键字修饰属性</strong>最终就会得到<code>UnsafeObjectFieldAccessorImpl</code>的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeObjectFieldAccessorImpl</span> <span class="keyword">extends</span> <span class="title">UnsafeFieldAccessorImpl</span> </span>&#123;</span><br><span class="line">    UnsafeObjectFieldAccessorImpl(Field field) &#123;</span><br><span class="line">        <span class="keyword">super</span>(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ensureObj(obj);</span><br><span class="line">        <span class="keyword">return</span> unsafe.getObject(obj, fieldOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>&#123;</span><br><span class="line">        ensureObj(obj);</span><br><span class="line">        <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">            throwFinalFieldIllegalAccessException(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!field.getType().isAssignableFrom(value.getClass())) &#123;</span><br><span class="line">                throwSetIllegalArgumentException(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.putObject(obj, fieldOffset, value);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> newGetBooleanIllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> newGetByteIllegalArgumentException();</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他直接抛出异常的方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>UnsafeObjectFieldAccessorImpl</code>中除了<code>get(Object obj)</code>和<code>set(Object obj, Object value)</code>方法，其他方法都是直接抛出IllegalArgumentException。而<code>get(Object obj)</code>和<code>set(Object obj, Object value)</code>底层分别依赖于<code>jdk.internal.misc.Unsafe</code>的<code>putObject(obj, fieldOffset, value)</code>和<code>getObject(obj, fieldOffset)</code>方法。而属性的内存偏移地址是在<code>UnsafeObjectFieldAccessorImpl</code>的父类<code>UnsafeFieldAccessorImpl</code>的构造函数中计算出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFieldAccessorImpl</span> <span class="keyword">extends</span> <span class="title">FieldAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Field   field;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span>    fieldOffset;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFinal;</span><br><span class="line"></span><br><span class="line">    UnsafeFieldAccessorImpl(Field field) &#123;</span><br><span class="line">        <span class="keyword">this</span>.field = field;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers()))</span><br><span class="line">            fieldOffset = unsafe.staticFieldOffset(field);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fieldOffset = unsafe.objectFieldOffset(field);</span><br><span class="line">        isFinal = Modifier.isFinal(field.getModifiers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以做个小结，属性反射操作<code>Field</code>的<code>setXX</code>和<code>getXX</code>方法最终委托到<code>jdk.internal.misc.Unsafe</code>的<code>putXX</code>和<code>getXX</code>方法，而属性的内存偏移地址是通过<code>jdk.internal.misc.Unsafe</code>的<code>staticFieldBase()</code>、<code>staticFieldOffset</code>和<code>objectFieldOffset</code>几个方法计算的。</p>
<h3 id="处理构造器调用的底层实现">处理构造器调用的底层实现</h3>
<p><code>Constructor#newInstance()</code>方法调用依赖到<code>ConstructorAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, clazz, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConstructorAccessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstructorAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Constructor&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而获取<code>ConstructorAccessor</code>实例也是通过反射工厂类<code>ReflectionFactory</code>，具体是<code>ReflectionFactory#newConstructorAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConstructorAccessor <span class="title">newConstructorAccessor</span><span class="params">(Constructor&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Class&lt;?&gt; declaringClass = c.getDeclaringClass();</span><br><span class="line">    <span class="comment">// 抽象方法会进入此if分支</span></span><br><span class="line">    <span class="keyword">if</span> (Modifier.isAbstract(declaringClass.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationExceptionConstructorAccessorImpl(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 宿主类直接是Class类型，则无法实例化</span></span><br><span class="line">    <span class="keyword">if</span> (declaringClass == Class<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationExceptionConstructorAccessorImpl</span><br><span class="line">            (<span class="string">"Can not instantiate java.lang.Class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the root Constructor that will not cache caller class</span></span><br><span class="line">    Constructor&lt;?&gt; root = langReflectAccess.getRoot(c);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前声明构造的宿主类是ConstructorAccessorImpl的子类</span></span><br><span class="line">    <span class="keyword">if</span> (Reflection.isSubclassOf(declaringClass,</span><br><span class="line">                                ConstructorAccessorImpl<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BootstrapConstructorAccessorImpl(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                c.getParameterTypes(),</span><br><span class="line">                                c.getExceptionTypes(),</span><br><span class="line">                                c.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeConstructorAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeConstructorAccessorImpl(c);</span><br><span class="line">        DelegatingConstructorAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingConstructorAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见最终得到的<code>ConstructorAccessor</code>实例为<code>DelegatingConstructorAccessorImpl</code>，而<code>DelegatingConstructorAccessorImpl</code>只是一个委托实现，底层是调用<code>NativeConstructorAccessorImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeConstructorAccessorImpl</span> <span class="keyword">extends</span> <span class="title">ConstructorAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;?&gt; c;</span><br><span class="line">    <span class="keyword">private</span> DelegatingConstructorAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeConstructorAccessorImpl(Constructor&lt;?&gt; c) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate a constructor belonging to a vm-anonymous class</span></span><br><span class="line">        <span class="comment">// because that kind of class can't be referred to by name, hence can't</span></span><br><span class="line">        <span class="comment">// be found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">            ConstructorAccessorImpl acc = (ConstructorAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                        c.getParameterTypes(),</span><br><span class="line">                                        c.getExceptionTypes(),</span><br><span class="line">                                        c.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newInstance0(c, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingConstructorAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个就是最终构造实例化对象的native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newInstance0</span><span class="params">(Constructor&lt;?&gt; c, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NativeConstructorAccessorImpl#newInstance0()</code>就是最终构造实例化对象的Native方法。当然有例外的情况，例如非正常调用下，如果构造器的宿主类是一个抽象类，那么最终会返回一个<code>InstantiationExceptionConstructorAccessorImpl</code>实例，里面直接抛出InstantiationException异常。</p>
<h3 id="处理方法调用的底层实现">处理方法调用的底层实现</h3>
<p><code>Method#invoke()</code>调用依赖于<code>MethodAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodAccessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz,</span><br><span class="line">                        Modifier.isStatic(modifiers) ? <span class="keyword">null</span> : obj.getClass(),</span><br><span class="line">                        modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">        MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>获取<code>MethodAccessor</code>实例的逻辑和前两节类似，是通过<code>ReflectionFactory#newMethodAccessor()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Reflection.isCallerSensitive(method)) &#123;</span><br><span class="line">        Method altMethod = findMethodForReflection(method);</span><br><span class="line">        <span class="keyword">if</span> (altMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            method = altMethod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the root Method that will not cache caller class</span></span><br><span class="line">    Method root = langReflectAccess.getRoot(method);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        method = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeMethodAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">        DelegatingMethodAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会委托到<code>NativeMethodAccessorImpl#invoke(Object obj, Object[] args)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>NativeMethodAccessorImpl#invoke0()</code>就是方法调用的最终调用的Native方法。</p>
<h2 id="小结">小结</h2>
<p>学习知识过程总是阶梯式上升的，JDK中的类库设计也类似这样，如果提前熟悉<code>Unsafe</code>类的相关方法，其实反射调用的底层实现也能够相对轻易地理解。属性、构造和方法反射调用底层的实现(<strong>只考虑正常调用的情况下</strong>)如下：</p>
<ul>
<li>对于属性(Field)：<code>Field#setXX()</code>和<code>Field#getXX()</code>分别对应<code>Unsafe</code>的<code>putXX()</code>和<code>getXX()</code>方法，也就是说完全依赖<code>Unsafe</code>中的Native方法。</li>
<li>对于构造(Constructor)：<code>Constructor#newInstance()</code>底层调用<code>NativeConstructorAccessorImpl#newInstance0()</code>。</li>
<li>对于方法(Method)：<code>Method#invoke()</code>底层调用<code>NativeMethodAccessorImpl#invoke0()</code></li>
</ul>
<p>(本文完 e-a-20181216 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/15/java-reflection-handle-exception/">
      深入分析Java反射(六)-反射调用异常处理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月15日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：6分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-08T00:04:20+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(六)-反射调用异常处理</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍一个使用反射一定会遇到的问题-反射调用异常处理。</p>
<h2 id="反射调用异常处理">反射调用异常处理</h2>
<p>反射调用出现异常的方法主要考虑下面的情况：</p>
<ul>
<li>属性操作：<code>java.lang.reflect.Field#set(Object obj, Object value)</code>和<code>java.lang.reflect.Field#get(Object obj)</code>。</li>
<li>构造器调用：<code>java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>。</li>
<li>方法调用：<code>java.lang.reflect.Method#invoke(Object obj, Object... args)</code>。</li>
</ul>
<h3 id="处理属性操作异常">处理属性操作异常</h3>
<p>先看设置属性的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br></pre></td></tr></table></figure>
<p>实际上，通过方法注释可以得知会抛出四种异常：</p>
<ul>
<li>IllegalAccessException：非法访问异常，<strong>注意它是检查(checked)异常</strong>，也就是需要显示捕获，此异常会在修饰符禁用访问的时候抛出，可以通过<code>setAccessible(true)</code>抑制修饰符检查来避免抛出此异常。</li>
<li>IllegalArgumentException：非法参数异常，它是运行时异常，当入参实例obj不是当前Field所在类(包括父类、子类和接口)的时候会抛出此异常。</li>
<li>NullPointerException：空指针异常，当入参实例obj为null的时候会抛出此异常。</li>
<li>ExceptionInInitializerError：初始化器调用异常导致的错误，如果由于<code>set(Object obj, Object value)</code>方法引发的初始化失败会包装成ExceptionInInitializerError，此异常的父类为Error，常见的发生情况就是静态成员或者静态代码块依赖到反射属性设置。</li>
</ul>
<p>前面三种异常都很好理解，最后一个ExceptionInInitializerError可能有点陌生，它的抛出条件是：在静态代码块初始化解析过程总抛出异常或者静态变量初始化的时候抛出异常。笔者尝试了很多例子都没办法造出案例，从Stackoverflow找到一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = Fail.class.getDeclaredField("number");</span><br><span class="line">        field.set(<span class="keyword">null</span>, <span class="number">42</span>); <span class="comment">// Fail class isn't initialized at this point</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> val = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); <span class="comment">// causes initialization to end with an exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是：静态代码块和静态变量的初始化顺序和它们在类文件编写的顺序是一致的，如果一个类未初始化直接使用它的静态代码块和静态变量通过<code>Field#set(Object obj, Object value)</code>调用就会出现ExceptionInInitializerError异常。</p>
<p>属性的获取方法抛出的异常和设置值方法是一致的，这里不做详细展开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br></pre></td></tr></table></figure>
<h3 id="处理构造器调用异常">处理构造器调用异常</h3>
<p>构造器调用主要是用于对象的实例化，先看<code>newInstance</code>方法的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InstantiationException：实例化异常，抛出此异常的一般情况是：当前构造所在类型为一个抽象类型。</li>
<li>IllegalAccessException：非法访问异常。</li>
<li>IllegalArgumentException：非法参数异常，下面的情况会抛出此异常：参数数量或者类型不匹配，参数列表为原始类型但是实际使用了包装类型、参数列表为原始类型但是实际使用了包装类型、构造所在的类是枚举类型等。</li>
<li>InvocationTargetException：目标调用异常，这个是需要处理的重点异常，在下一节&quot;处理方法调用异常&quot;详细探讨。</li>
</ul>
<p>这里只举个例子说明一下InstantiationException出现的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Constructor&lt;AbstractSample&gt; declaredConstructor = AbstractSample<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">		declaredConstructor.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面的抽象类<code>AbstractSample</code>包含一个默认的公有构造，使用<code>Constructor#newInstance()</code>会抛出InstantiationException异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.InstantiationException</span><br><span class="line">	at java.base/jdk.internal.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:<span class="number">48</span>)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">490</span>)</span><br><span class="line">	at club.throwable.jdk.sample.reflection.reflect.AbstractSample.main(AbstractSample.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<h3 id="处理方法调用异常">处理方法调用异常</h3>
<p>方法调用是反射中使用频率最高的反射操作，主要是<code>Method#invoke(Object obj, Object... args)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<p>主要包括以下几种异常：</p>
<ul>
<li>IllegalAccessException：非法访问异常。</li>
<li>IllegalArgumentException：非法参数异常，下面的情况会抛出此异常：入参obj并不是当前实例方法对应的实例对象、参数数量或者类型不匹配，参数列表为原始类型但是实际使用了包装类型、参数列表为原始类型但是实际使用了包装类型等等。</li>
<li>NullPointerException：空指针异常，入参obj为null时候会抛出此异常。</li>
<li>ExceptionInInitializerError：初始化器调用异常导致的错误。</li>
<li>InvocationTargetException：目标调用异常。</li>
</ul>
<p>重点看InvocationTargetException(继承自ReflectiveOperationException，而ReflectiveOperationException继承自Exception，<strong>也就是它是checked异常，必须显式捕获</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 持有的目标异常实例</span></span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);  <span class="comment">// Disallow initCause</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);  <span class="comment">// Disallow initCause</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中得知：方法(Method)或者构造(Constructor)调用异常会抛出此InvocationTargetException异常，用于包装源异常，源异常实例作为目标被InvocationTargetException通过成员target持有，可以通过<code>InvocationTargetException#getTargetException()</code>或者<code>InvocationTargetException#getCause()</code>获取原始的目标异常。这里注意到，InvocationTargetException在覆盖父类构造的时候使用了null，所以调用其<code>getMessage()</code>方法会得到null。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetExceptionMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		InvocationTargetExceptionMain main = <span class="keyword">new</span> InvocationTargetExceptionMain();</span><br><span class="line">		Method method = InvocationTargetExceptionMain.class.getDeclaredMethod("method");</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			method.invoke(main);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">			<span class="comment">//no-op</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"InvocationTargetException#message:"</span> + e.getMessage());</span><br><span class="line">			<span class="keyword">if</span> (e.getTargetException() <span class="keyword">instanceof</span> NullPointerException) &#123;</span><br><span class="line">				NullPointerException nullPointerException = (NullPointerException) e.getTargetException();</span><br><span class="line">				System.out.println(<span class="string">"NullPointerException#message:"</span> + nullPointerException.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvocationTargetException#message:null</span><br><span class="line">NullPointerException#message:Null</span><br></pre></td></tr></table></figure>
<p>构造器<code>Constructor#newInstance()</code>中抛出InvocationTargetException的场景是类似的。</p>
<h2 id="小结">小结</h2>
<p>在反射操作中，方法调用的频次是最高的，其次是通过构造器实例化对象。需要重点关注这两个地方的异常处理，特别是异常类型<code>InvocationTargetException</code>，紧记需要获取原始目标异常类型再进行判断，否则很容易导致逻辑错误(最近笔者在做一个功能的时候刚好踩了这个坑)。</p>
<p>(本文完 e-a-20181215 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/13/java-magic-unsafe/">
      神奇的魔法类和双刃剑-Unsafe
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月13日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：5.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：20分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-13T23:47:39+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月13日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>神奇的魔法类和双刃剑-Unsafe</h1>
<h2 id="前提">前提</h2>
<p>JDK9或者以后，<code>sun.misc</code>包的源码也可以上传到JDK类库中，可以直接导入IDE进行注释的阅读，这一点是比较好的改进。本文基于JDK11的源码阅读Unsafe类的注释，介绍一下这个类的使用方式。</p>
<h2 id="Unsafe简介">Unsafe简介</h2>
<p>在JDK9之后，<code>sun.misc.Unsafe</code>被移动到<code>jdk.unsupported</code>模块中，同时在<code>java.base</code>模块克隆了一个<code>jdk.internal.misc.Unsafe</code>类，代替了JDK8以前的<code>sun.misc.Unsafe</code>的功能，<code>jdk.internal</code>包不开放给开发者调用。</p>
<p>Unsafe是用于在实质上扩展Java语言表达能力、便于在更高层（Java层）代码里实现原本要在更低层（C层）实现的核心库功能用的。这些功能包括裸内存的申请/释放/访问，低层硬件的atomic/volatile支持，创建未初始化对象等。它原本的设计就只应该被标准库使用。</p>
<p>为了让开发者有机会过渡到尽量不使用<code>sun.misc.Unsafe</code>，默认不允许Java应用代码访问<code>sun.misc.Unsafe</code>类，同时在<code>java.base</code>模块克隆了一个不能被外部访问的<code>jdk.internal.misc.Unsafe</code>类用于JDK内部API演进。</p>
<h2 id="获取Unsafe实例">获取Unsafe实例</h2>
<p><code>sun.misc.Unsafe</code>提供了一个静态方法来获取其实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VM类中的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSystemDomainLoader</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loader == <span class="keyword">null</span> || loader == ClassLoader.getPlatformClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个静态方法<code>getUnsafe()</code>必须在当前调用的类对应的类加载器为null(<strong>类加载器为null也就是当前调用的类必须使用Bootstrap类加载器加载</strong>)或者为<code>PlatformClassLoader</code>才不会抛出<code>SecurityException</code>异常。由于对<code>PlatformClassLoader</code>理解不深入，所以我们可以用VM参数<code>-Xbootclasspath:</code>让当前的调用类被Bootstrap类加载器加载。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-unsafe-1.png" alt="j-unsafe-1"></p>
<p>但是试验了一下(其实文档中已经提到此参数已经失效，不过这里还是试了下)，发现这个参数在JDK9之后已经不支持，使用的时候会导致JVM启动失败，异常信息是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">-Xbootclasspath is no longer a supported option.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure>
<p>此特性暂时在JDK9以后找不到替代的VM参数，所以这里只能选择其他可行方法。查看<code>sun.misc.Unsafe</code>所在模块的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> jdk.unsupported &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.sun.nio.file;</span><br><span class="line">    <span class="keyword">exports</span> sun.misc;</span><br><span class="line">    <span class="keyword">exports</span> sun.reflect;</span><br><span class="line"></span><br><span class="line">    opens sun.misc;</span><br><span class="line">    opens sun.reflect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>sun.misc</code>是opens修饰的，可以使用反射直接调用。因此可以像下面这样获取<code>sun.misc.Unsafe</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">		f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有特殊的技巧可以直接暴露<code>jdk.internal.misc.Unsafe</code>所在的模块让它可以直接使用反射调用，只需要使用参数<code>addExports:java.base/jdk.internal.misc=ALL-UNAMED</code>，这样子就可以反射获取<code>jdk.internal.misc.Unsafe</code>的实例，不过推荐这种做法，毕竟<code>jdk.internal.misc.Unsafe</code>中提供更多底层的方法，能力越大越容易失去控制。</p>
<h2 id="Unsafe的使用建议">Unsafe的使用建议</h2>
<p>使用Unsafe要注意以下几个问题：</p>
<p>1、Unsafe有可能在未来的JDK版本移除或者不允许Java应用代码使用，这一点可能导致使用了Unsafe的应用无法运行在高版本的JDK。<br>
2、Unsafe的不少方法中必须提供原始地址(内存地址)和被替换对象的地址，偏移量要自己计算，一旦出现问题就是JVM崩溃级别的异常，会导致整个JVM实例崩溃，表现为应用程序直接crash掉(<strong>其实这个很好理解，JVM是C语言写出来的软件，如果操作一个不存在的内存地址，在C程序中就是引发程序崩溃的操作</strong>)。<br>
3、Unsafe提供的直接内存访问的方法中使用的内存不受JVM管理(无法被GC)，需要手动管理，一旦出现疏忽很有可能成为内存泄漏的源头。</p>
<p>暂时总结出以上三点问题。Unsafe在JUC(java.util.concurrent)包中大量使用(主要是CAS)，在netty中方便使用直接内存，还有一些高并发的交易系统为了提高CAS的效率也有可能直接使用到Unsafe。总而言之，Unsafe类是魔法类，也可以说是一把双刃剑。</p>
<h2 id="Unsafe的核心方法">Unsafe的核心方法</h2>
<p><code>sun.misc.Unsafe</code>一共提供了89个public修饰的方法，下面针对核心方法按功能分组简单介绍一下。</p>
<h3 id="类操作">类操作</h3>
<p>类操作相关主要和类实例化、属性地址获取等等操作，原来存在一个<code>defineClass</code>方法，已经被移除，但是该方法在<code>jdk.internal.misc.Unsafe</code>中依然存在。</p>
<p><strong>ensureClassInitialized</strong></p>
<ul>
<li><code>public boolean shouldBeInitialized(Class&lt;?&gt; c)</code></li>
</ul>
<p>检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。</p>
<p><strong>shouldBeInitialized</strong></p>
<ul>
<li><code>public boolean shouldBeInitialized(Class&lt;?&gt; c)</code></li>
</ul>
<p>检测给定的类是否需要初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。 此方法当且仅当<code>ensureClassInitialized</code>方法不生效的时候才返回false。</p>
<p><strong>defineAnonymousClass</strong></p>
<ul>
<li>
<p><code>public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches)</code></p>
<ul>
<li>hostClass：宿主类。</li>
<li>data：字节码字节数组。</li>
<li>cpPatches：替换常量池(Constant Pool)中的字面量得到的引用数组。</li>
</ul>
</li>
</ul>
<p>这个方法的使用可以看R大的知乎回答：<a href="https://www.zhihu.com/question/51132462" target="_blank" rel="noopener">JVM crashes at libjvm.so</a>，下面截取一点内容解释此方法。</p>
<ul>
<li>1、VM Anonymous Class可以看作一种模板机制，如果程序要动态生成很多结构相同、只是若干变量不同的类的话，可以先创建出一个包含占位符常量的正常类作为模板，然后利用<code>sun.misc.Unsafe#defineAnonymousClass()</code>方法，传入该类(host class，宿主类或者模板类)以及一个作为&quot;constant pool path&quot;的数组来替换指定的常量为任意值，结果得到的就是一个替换了常量的<code>VM Anonymous Class</code>。</li>
<li>2、<code>VM Anonymous Class</code>从VM的角度看是真正的&quot;没有名字&quot;的，在构造出来之后只能通过<code>Unsafe#defineAnonymousClass()</code>返回出来一个Class实例来进行反射操作。</li>
</ul>
<p>还有其他几点看以自行阅读。这个方法虽然翻译为&quot;定义匿名类&quot;，但是它所定义的类和实际的匿名类有点不相同，因此一般情况下我们不会用到此方法。在JDK中Lambda表达式的构造依赖到此方法，可以看<code>InnerClassLambdaMetafactory</code>这个类。<strong>方法的注释：定义一个不被类加载器系统或者系统字典感知的类型</strong>。</p>
<p><strong>allocateInstance</strong></p>
<ul>
<li><code>public native Object allocateInstance(Class&lt;?&gt; cls)</code></li>
</ul>
<p>注意此方法是JVM本地接口方法，通过Class对象创建一个类的实例，不需要调用其构造函数、初始化代码、JVM安全检查等等。同时，它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化。</p>
<p><strong>staticFieldBase</strong></p>
<ul>
<li><code>public Object staticFieldBase(Field f)</code></li>
</ul>
<p>返回给定的静态属性所在的位置(其实就是所在的对象的内存快照)，配合<code>staticFieldOffset</code>方法使用。实际上，这个方法返回值就是静态属性所在的Class对象的一个内存快照。注释中说到，此方法返回的Object有可能为null，它只是一个’cookie’而不是真实的对象，不要直接使用的它的实例中的获取属性和设置属性的方法，它的作用只是方便调用像<code>getInt(Object,long)</code>等等的任意方法。</p>
<p><strong>staticFieldOffset</strong></p>
<ul>
<li><code>public long staticFieldOffset(Field f)</code></li>
</ul>
<p>返回给定的<strong>静态属性</strong>在它的类的内存分配中的位置(内存偏移地址)。不要在这个偏移量上执行任何类型的算术运算，它只是一个被传递给不安全的堆内存访问器的cookie。注意：这个方法仅仅针对静态属性，使用在非静态属性上会抛异常。</p>
<p><strong>objectFieldOffset</strong></p>
<ul>
<li><code>public long staticFieldOffset(Field f)</code></li>
</ul>
<p>返回给定的<strong>非静态属性</strong>在它的类的内存分配中的位置(内存偏移地址)。不要在这个偏移量上执行任何类型的算术运算，它只是一个被传递给不安全的堆内存访问器的cookie。注意：这个方法仅仅针对非静态属性，使用在静态属性上会抛异常。</p>
<p><strong>defineClass</strong></p>
<ul>
<li><code>public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain)</code></li>
</ul>
<p>这个方法位于<code>jdk.internal.misc.Unsafe</code>，也就是开发者无法直接使用。作用是：绕过安全检查告知JVM定义一个类。默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例应该来源于调用者。</p>
<h3 id="基于内存地址直接存取属性">基于内存地址直接存取属性</h3>
<p>前一节中提供了一些方法可以直接获取静态或者非静态成员属性的内存地址，这一节介绍的API可以基于成员属性内存地址直接获取或者设置其值。</p>
<p><strong>getObject</strong></p>
<ul>
<li><code>public Object getObject(Object o, long offset)</code></li>
</ul>
<p>通过给定的Java对象和属性内存地址获取引用值。这里实际上是获取一个Java对象o中，获取偏移地址为offset的属性的值，此方法可以突破修饰符的抑制，也就是无视private、protected和default修饰符。类似的方法有<code>getInt</code>、<code>getDouble</code>等等。</p>
<p><strong>putObject</strong></p>
<ul>
<li>
<p><code>public void putObject(Object o, long offset, Object x)</code></p>
<ul>
<li>o：当前操作的对象。</li>
<li>offset：成员属性的内存地址。</li>
<li>x：需要设置的目标属性值。</li>
</ul>
</li>
</ul>
<p>将引用值存储到给定的Java变量中。这里实际上是设置一个Java对象o中偏移地址为offset的属性的值为x，此方法可以突破修饰符的抑制，也就是无视private、protected和default修饰符。类似的方法有putInt、putDouble等等。</p>
<p><strong>getObjectVolatile</strong></p>
<ul>
<li><code>public Object getObjectVolatile(Object o, long offset)</code></li>
</ul>
<p>此方法和上面的<code>getObject</code>功能类似，不过附加了<code>volatile</code>关键字加载语义，也就是强制从主存中获取属性值。类似的方法有<code>getIntVolatile</code>、<code>getDoubleVolatile</code>等等。这个方法要求被使用的属性被volatile修饰，否则功能和<code>getObject</code>方法相同。</p>
<p><strong>putObjectVolatile</strong></p>
<ul>
<li><code>public void putObjectVolatile(Object o, long offset, Object x)</code></li>
</ul>
<p>此方法和上面的<code>putObject</code>功能类似，不过附加了<code>volatile</code>关键字加载语义，也就是设置值的时候强制(JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后)更新到主存，从而保证这些变更对其他线程是可见的。类似的方法有<code>putIntVolatile</code>、<code>putDoubleVolatile</code>等等。这个方法要求被使用的属性被volatile修饰，否则功能和putObject方法相同。</p>
<p><strong>putOrderedObject</strong></p>
<ul>
<li><code>public void putOrderedObject(Object o, long offset, Object x)</code></li>
</ul>
<p>设置o对象中offset偏移地址offset对应的Object型field的值为指定值x。这是一个有序或者有延迟的<code>putObjectVolatile</code>方法，并且不保证值的改变被其他线程立即看到。只有在属性被volatile修饰并且期望被修改的时候使用才会生效。类似的方法有<code>putOrderedInt</code>和<code>putOrderedLong</code>。方法注释中提到：相当于C11中的<code>atomic_store_explicit(..., memory_order_release)</code>。</p>
<h3 id="数组操作">数组操作</h3>
<p><strong>arrayBaseOffset</strong></p>
<ul>
<li><code>public int arrayBaseOffset(Class&lt;?&gt; arrayClass)</code></li>
</ul>
<p>返回数组类型的第一个元素的偏移地址(基础偏移地址)。如果arrayIndexScale方法返回的比例因子不为0，你可以通过结合基础偏移地址和比例因子访问数组的所有元素。Unsafe中已经初始化了很多类似的常量如<code>ARRAY_BOOLEAN_BASE_OFFSET</code>等。</p>
<p><strong>arrayIndexScale</strong></p>
<ul>
<li><code>public int arrayIndexScale(Class&lt;?&gt; arrayClass)</code></li>
</ul>
<p>返回数组类型的比例因子(其实就是数据中元素偏移地址的增量，因为数组中的元素的地址是连续的)。此方法不适用于数组类型为&quot;narrow&quot;类型的数组，&quot;narrow&quot;类型的数组类型使用此方法会返回0(这里narrow应该是狭义的意思，但是具体指哪些类型暂时不明确，笔者查了很多资料也没找到结果)。Unsafe中已经初始化了很多类似的常量如<code>ARRAY_BOOLEAN_INDEX_SCALE</code>等。</p>
<h3 id="低级同步原语">低级同步原语</h3>
<p>低级同步原语的相关方法在JDK8还能通过<code>sun.misc.Unsafe</code>使用，在JDK9以后<code>sun.misc.Unsafe</code>和<code>jdk.internal.misc.Unsafe</code>都移除了相关的方法。低级同步原语主要包括监视器锁定、解锁方法。</p>
<p><strong>monitorEnter</strong></p>
<ul>
<li><code>public native void monitorEnter(Object o)</code></li>
</ul>
<p>锁定对象，必须通过monitorExit方法才能解锁。此方法经过实验是可以重入的，也就是可以多次调用，然后通过多次调用monitorExit进行解锁。</p>
<p><strong>monitorExit</strong></p>
<ul>
<li><code>public native void monitorExit(Object o)</code></li>
</ul>
<p>解锁对象，前提是对象必须已经调用monitorEnter进行加锁，否则抛出IllegalMonitorStateException异常。</p>
<p><strong>tryMonitorEnter</strong></p>
<ul>
<li><code>public native boolean tryMonitorEnter(Object o)</code></li>
</ul>
<p>尝试锁定对象，如果加锁成功返回true，否则返回false。必须通过monitorExit方法才能解锁。</p>
<h3 id="线程挂起与恢复">线程挂起与恢复</h3>
<p>JDK1.5引入了并发包<code>java.util.concurrent</code>中组件控制线程挂起和恢复就是依赖于<code>java.util.concurrent.locks.LockSupport</code>完成，而<code>LockSupport</code>底层依赖于<code>sun.misc.Unsafe</code>中下面提到线程的挂起和恢复方法完成的。相关方法主要是用于替代线程类<code>Thread</code>中过时并且不安全的<code>suspend</code>和<code>resume</code>方法。</p>
<p><strong>park</strong></p>
<ul>
<li>
<p><code>public void park(boolean isAbsolute, long time)</code></p>
<ul>
<li>time：时间长度，单位由isAbsolute控制，0表示永久阻塞。</li>
<li>isAbsolute：如果isAbsolute为true，time是相对于新纪元之后的毫秒，否则time表示纳秒。</li>
</ul>
</li>
</ul>
<p>注释：阻塞当前线程直到一个<code>unpark</code>方法出现(被调用)、一个用于<code>unpark</code>方法已经出现过(在此<code>park</code>方法调用之前已经调用过)、线程被中断或者time时间到期(也就是阻塞超时)。在time非零的情况下，如果isAbsolute为true，time是相对于新纪元之后的毫秒，否则time表示纳秒。这个方法执行时也可能不合理地返回(没有具体原因)。</p>
<p><strong>unpark</strong></p>
<ul>
<li><code>public void unpark(Object thread)</code></li>
</ul>
<p>释放被<code>park</code>创建的在一个线程上的阻塞。这个方法也可以被使用来终止一个先前调用<code>park</code>导致的阻塞。这个操作是不安全的，因此必须保证线程是存活的(thread has not been destroyed)。从Java代码中判断一个线程是否存活的是显而易见的，所以解除阻塞的时候需要对线程的存活性做判断。</p>
<p><strong>重点注意：</strong></p>
<ul>
<li><code>unpark</code>方法调用多次，实际上只有一次会生效，可以简单理解为它是一个只有0和1两个值的计数器，调用<code>unpark</code>多次，计数仍然为1。</li>
<li><code>park</code>方法总是针对当前线程，如果预先已经调用过一次<code>unpark</code>方法后再调用<code>park</code>方法，那么<strong>将不会进入阻塞状态直接释放</strong>。</li>
</ul>
<h3 id="CAS操作">CAS操作</h3>
<p>CAS，也就是Compare And Swap，也就是在一个原子操作中完成比较和交互。</p>
<p><strong>compareAndSwapObject</strong></p>
<ul>
<li>
<p><code>public final boolean compareAndSwapObject(Object o, long offset, Object expected, Object x)</code></p>
<ul>
<li>o：目标Java变量引用。</li>
<li>offset：目标Java变量中的目标属性的偏移地址。</li>
<li>expected：目标Java变量中的目标属性的期望的当前值。</li>
<li>x：目标Java变量中的目标属性的目标更新值。</li>
</ul>
</li>
</ul>
<p>针对Object对象进行CAS操作。即是对应Java变量引用o，原子性地更新o中偏移地址为offset的属性的值为x，当且仅的偏移地址为offset的属性的当前值为expected才会更新成功返回true，否则返回false。类似的方法有<code>compareAndSwapInt</code>和<code>compareAndSwapLong</code>，在Jdk8中基于CAS扩展出来的相关方法有<code>getAndAddInt</code>、<code>getAndAddLong</code>、<code>getAndSetInt</code>、<code>getAndSetLong</code>、<code>getAndSetObject</code>，它们的作用都是：通过CAS设置新的值，返回旧的值。</p>
<p><strong>getAndSetObject</strong></p>
<ul>
<li><code>public final Object getAndSetObject(Object o, long offset, Object newValue)</code></li>
</ul>
<p>见<strong>compareAndSwapObject</strong>中的描述。</p>
<h3 id="内存管理">内存管理</h3>
<p><strong>addressSize</strong></p>
<ul>
<li><code>public int addressSize();</code></li>
</ul>
<p>获取本地指针的大小(单位是byte)，通常值为4或者8。常量ADDRESS_SIZE就是调用此方法。</p>
<p><strong>pageSize</strong></p>
<ul>
<li><code>public int pageSize();</code></li>
</ul>
<p>获取本地内存的页数，此值为2的幂次方。</p>
<p><strong>allocateMemory</strong></p>
<ul>
<li><code>public long allocateMemory(long bytes);</code></li>
</ul>
<p>分配一块新的本地内存，通过bytes指定内存块的大小(单位是byte)，返回新开辟的内存的地址。如果内存块的内容不被初始化，那么它们一般会变成内存垃圾。生成的本机指针永远不会为零，并将对所有值类型进行对齐。可以通过<code>freeMemory</code>方法释放内存块，或者通过<code>reallocateMemory</code>方法调整内存块大小。bytes值为负数或者过大会抛出IllegalArgumentException异常，如果系统拒绝分配内存会抛出OutOfMemoryError异常。</p>
<p><strong>reallocateMemory</strong></p>
<ul>
<li><code>public long reallocateMemory(long address, long bytes);</code></li>
</ul>
<p>通过指定的内存地址address重新调整本地内存块的大小，调整后的内存块大小通过bytes指定(单位为byte)。可以通过<code>freeMemory</code>方法释放内存块，或者通过<code>reallocateMemory</code>方法调整内存块大小。bytes值为负数或者过大会抛出IllegalArgumentException异常，如果系统拒绝分配内存会抛出OutOfMemoryError异常。</p>
<p><strong>setMemory</strong></p>
<ul>
<li><code>public void setMemory(Object o, long offset, long bytes, byte value);</code></li>
</ul>
<p>将给定内存块中的所有字节设置为固定值(通常是0)。内存块的地址由对象引用o和偏移地址共同决定，如果对象引用o为null，offset就是绝对地址。第三个参数就是内存块的大小，如果使用<code>allocateMemory</code>进行内存开辟的话，这里的值应该和<code>allocateMemory</code>的参数一致。value就是设置的固定值，一般为0(这里可以参考netty的DirectByteBuffer)。一般而言，o为null，所有有个重载方法是<code>public void setMemory(long offset, long bytes, byte value);</code>，等效于<code>setMemory(null, long offset, long bytes, byte value);</code>。</p>
<p><strong>copyMemory</strong></p>
<ul>
<li><code>public void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes) </code></li>
</ul>
<p>拷贝给定内存地址的字节长度对应的字节到指定内存地址中。如果srcBase或者destBase为null，则srcOffset或者destOffset分别指代绝对地址。</p>
<h3 id="内存屏障">内存屏障</h3>
<p>内存屏障相关的方法是在Jdk8添加的。内存屏障相关的知识可以先自行查阅，笔者目前也没有深入了解相关知识。</p>
<p><strong>loadFence</strong></p>
<ul>
<li><code>public void loadFence();</code></li>
</ul>
<p>在该方法之前的所有读操作，一定在load屏障之前执行完成。</p>
<p><strong>storeFence</strong></p>
<ul>
<li><code>public void storeFence();</code></li>
</ul>
<p>在该方法之前的所有写操作，一定在store屏障之前执行完成</p>
<p><strong>fullFence</strong></p>
<ul>
<li><code>public void fullFence();</code></li>
</ul>
<p>在该方法之前的所有读写操作，一定在full屏障之前执行完成，这个内存屏障相当于上面两个(load屏障和store屏障)的合体功能。</p>
<h3 id="其它">其它</h3>
<p><strong>invokeCleaner</strong></p>
<ul>
<li><code>public void invokeCleaner(java.nio.ByteBuffer directBuffer)</code></li>
</ul>
<p>清空使用了堆外内存的<code>ByteBuffer</code>实例占据的内存，一般是<code>DirectBuffer</code>的子类。</p>
<p><strong>throwException</strong></p>
<ul>
<li><code>public void throwException(Throwable ee)</code></li>
</ul>
<p>绕过检测机制直接抛出异常。</p>
<p><strong>getLoadAverage</strong></p>
<ul>
<li><code>public int getLoadAverage(double[] loadavg, int nelems);</code></li>
</ul>
<p>获取系统的平均负载值，loadavg这个double数组将会存放负载值的结果，nelems决定样本数量，nelems只能取值为1到3，分别代表最近1、5、15分钟内系统的平均负载。如果无法获取系统的负载，此方法返回-1，否则返回获取到的样本数量(loadavg中有效的元素个数)。实验中这个方法一直返回-1，其实完全可以使用<strong>JMX</strong>中的相关方法替代此方法。</p>
<h2 id="使用例子">使用例子</h2>
<p>先封装一下获取<code>Unsafe</code>实例的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Field f = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">	f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过内存地址直接操作属性">通过内存地址直接操作属性</h3>
<p>通过<code>staticFieldOffset</code>和<code>objectFieldOffset</code>可以获取静态和非静态成员属性的偏移地址，然后直接进行存取值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Integer STATIC_INT = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">   Long longField = <span class="number">1024L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Unsafe unsafe = getUnsafe();</span><br><span class="line">		Field staticInt = Simple.class.getDeclaredField("STATIC_INT");</span><br><span class="line">		staticInt.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		Object staticFieldBase = unsafe.staticFieldBase(staticInt);</span><br><span class="line">		<span class="keyword">long</span> staticFieldOffset = unsafe.staticFieldOffset(staticInt);</span><br><span class="line">		<span class="comment">// 注意这里一定要getObject,getInt是针对原始类型int,包装类型要自己强转</span></span><br><span class="line">		System.out.println(<span class="string">"Sample初始化前,STATIC_INT = "</span> + unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line">		Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">		System.out.println(<span class="string">"Sample初始化后,STATIC_INT = "</span> + unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line"></span><br><span class="line">		Field longField = Simple.class.getDeclaredField("longField");</span><br><span class="line">		longField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">long</span> objectFieldOffset = unsafe.objectFieldOffset(longField);</span><br><span class="line">		System.out.println(<span class="string">"Sample初始化后,longField = "</span> + unsafe.getObject(simple, objectFieldOffset));</span><br><span class="line">		unsafe.putObject(simple,objectFieldOffset, <span class="number">4201L</span>);</span><br><span class="line">		System.out.println(<span class="string">"Sample属性被覆盖后,longField = "</span> + simple.longField);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line">Sample初始化前,STATIC_INT = <span class="keyword">null</span></span><br><span class="line">Sample初始化后,STATIC_INT = <span class="number">10086</span></span><br><span class="line">Sample初始化后,longField = <span class="number">1024</span></span><br><span class="line">Sample属性被覆盖后,longField = <span class="number">4201</span></span><br></pre></td></tr></table></figure>
<h3 id="线程挂起和恢复">线程挂起和恢复</h3>
<p>主要介绍一下<code>park</code>和<code>unpark</code>的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Unsafe unsafe = getUnsafe();</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"线程park!"</span>);</span><br><span class="line">				unsafe.park(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">				System.out.println(<span class="string">"线程恢复运行!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">"主线程unpark阻塞着的线程!"</span>);</span><br><span class="line">		unsafe.unpark(thread);</span><br><span class="line">		TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行后输出：</span></span><br><span class="line">线程park!</span><br><span class="line">主线程unpark阻塞着的线程!</span><br><span class="line">线程恢复运行!</span><br></pre></td></tr></table></figure>
<h3 id=""></h3>
<h2 id="小结">小结</h2>
<p>存在即合理，虽然不推荐使用<code>Unsafe</code>，但是如果有需要的还是要挥动这把双刃剑。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/29266773?sort=created" target="_blank" rel="noopener">为什么JUC中大量使用了sun.misc.Unsafe 这个类，但官方却不建议开发者使用？</a></li>
<li>JDK11相关源码</li>
<li><a href="http://ifeve.com/sun-misc-unsafe/" target="_blank" rel="noopener">Java Magic. Part 4: sun.misc.Unsafe</a></li>
</ul>
<p>(本文完 e-a-20181213 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/09/java-reflection-class-load/">
      深入分析Java反射(五)-类实例化和类加载
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月9日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：15分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-12T00:45:32+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月12日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(五)-类实例化和类加载</h1>
<h2 id="前提">前提</h2>
<p>其实在前面写过的《深入分析Java反射(一)-核心类库和方法》已经介绍过通过类名或者<code>java.lang.Class</code>实例去实例化一个对象，在《浅析Java中的资源加载》中也比较详细地介绍过类加载过程中的双亲委派模型，这篇文章主要是加深一些对类实例化和类加载的认识。</p>
<h2 id="类实例化">类实例化</h2>
<p>在反射类库中，用于实例化对象只有两个方法：</p>
<ul>
<li><code>T java.lang.Class#newInstance()</code>：这个方法只需要提供<code>java.lang.Class&lt;T&gt;</code>的实例就可以实例化对象，如果提供的是无限定类型<code>Class&lt;?&gt;</code>则得到的是Object类型的返回值，可以进行强转。这个方法不支持任何入参，底层实际上也是依赖无参数的构造器Constructor进行实例化。</li>
<li><code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>：这个方法需要提供<code>java.lang.reflect.Constructor&lt;T&gt;</code>实例和一个可变参数数组进行对象的实例化，上面提到的<code>T java.lang.Class#newInstance()</code>底层也是依赖此方法。这个方法除了可以传入构造参数之外，还有一个好处就是可以通过``抑制修饰符访问权限检查，也就是私有的构造器也可以用于实例化对象。</li>
</ul>
<p>在编写反射类库的时候，优先选择<code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>进行对象实例化，目前参考很多优秀的框架(例如Spring)都是用这个方法进行对象实例化。</p>
<h2 id="类加载">类加载</h2>
<p>类加载实际上由类加载器(ClassLoader)完成，<code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>方法提现了类加载过程中遵循了双亲委派模型，实际上，我们可以覆写此方法完全不遵循双亲委派模型，实现同一个类(这里指的是全类名完全相同)重新加载。JDK中提供类加载相关的特性有两个方法：</p>
<ul>
<li><code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>：通过类加载器实例去加载类，一般应用类路径下的类是由<code>jdk.internal.loader.ClassLoaders$AppClassLoader</code>加载，也可以自行继承<code>java.lang.ClassLoader</code>实现自己的类加载器。</li>
<li><code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>：通过全类名进行类加载，可以通过参数控制类初始化行为。</li>
</ul>
<h3 id="ClassLoader中的类加载">ClassLoader中的类加载</h3>
<p>类加载过程其实是一个很复杂的过程，主要包括下面的步骤：</p>
<ul>
<li>1、加载过程：使用(自定义)类加载器去获取类文件字节码字节类的过程，Class实例在这一步生成，作为方法区的各种数据类型的访问入口。</li>
<li>2、验证过程：JVM验证字节码的合法性。</li>
<li>3、准备过程：为类变量分配内存并且设置初始值。</li>
<li>4、解析过程：JVM把常量池中的符号替换为直接引用。</li>
<li>5、初始化过程：执行类构造器<code>&lt;cinit&gt;()</code>方法，<code>&lt;cinit&gt;()</code>方法是编译器自动收集所有类变量的赋值动作和静态代码块中的语句合并生成，收集顺序由语句在源文件中出现的顺序决定，JVM保证在子类<code>&lt;cinit&gt;()</code>方法调用前父类的<code>&lt;cinit&gt;()</code>方法已经执行完毕。</li>
</ul>
<p><code>ClassLoader#loadClass()</code>方法就是用于控制类加载过程的第一步-加载过程，也就是控制字节码字节数组和类名生成Class实例的过程。<code>ClassLoader</code>中还有一个<code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</code>方法用于指定全类名和字节码字节数组去定义一个类，我们再次看下<code>loadClass()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查类是否已经加载过，如果已经加载过，则直接返回</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="comment">// 委派父类加载器去加载类</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 委派父类加载器如果加载失败则调用findClass方法进行加载动作</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展点-1</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 扩展点-2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>loadClass()</code>方法留下了两个扩展点用于改变类加载的行为，而<code>findClass()</code>方法就是用于扩展父类加载器加载失败的情况下，子类加载器的行为。当然，实际上<code>Class&lt;?&gt; loadClass(String name, boolean resolve)</code>方法<strong>是非final的方法，可以整个方法覆写掉，这样子就有办法完全打破双亲委派机制</strong>。但是注意一点，即使打破双亲委派机制，子类加载器也不可能重新加载一些由Bootstrap类加载器加载的类库如<code>java.lang.String</code>，这些是由JVM验证和保证的。自定义类加载器的使用在下一节的&quot;类重新加载&quot;中详细展开。</p>
<p>最后还有两点十分重要：</p>
<ul>
<li>1、<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性</strong>，也就是一个类在JVM中的签名是加载它的类加载器和它本身，<strong>对于每一个类加载器，都拥有一个独立的类命名空间</strong>。</li>
<li>2、<strong>比较两个类是否&quot;相等&quot;，只有这两个类是由同一个类加载器加载的前提下才有意义</strong>。即使这两个类的全类名一致、来源于同一个字节码文件、被同一个Java虚拟机加载，但是加载它们的类加载器不同，那么它们必定不相等。这里相等的范畴包括：<code>Class</code>对象的<code>equals()</code>方法、<code>isAssignableForm()</code>方法、<code>isInstance()</code>方法的返回结果以及使用<code>instanceof</code>关键字做对象所属关系时候的判定等情况。</li>
</ul>
<h3 id="Class中的类加载">Class中的类加载</h3>
<p><code>java.lang.Class</code>中的类加载主要由<code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>方法完成，该方法可以指定全类名、是否初始化和类加载器实例。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">        <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">        caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">            <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sm.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                        ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt; caller) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>它最终调用的是JVM的本地接口方法，由于暂时没有能力分析JVM的源码，只能通过<code>forName</code>方法的注释理解方法的功能：</p>
<blockquote>
<p>返回给定字符串全限定名称、指定类加载器的类或者接口的Class实例，此方法会尝试对类或者接口进行locate、load and link操作，如果loader参数为null，则使用bootstrap类加载器进行加载，如果initialize参数为true同时类或者接口在早期没有被初始化，则会进行初始化操作。</p>
</blockquote>
<p>也就是说initialize参数对于已经初始化过的类或者接口来说是没有意义的。这个方法的特性还可以参考<a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html" target="_blank" rel="noopener">Java语言规范的12章中的内容</a>，这里不做展开。</p>
<p>虽然暂时没法分析JVM本地接口方法<code>native Class&lt;?&gt; forName0()</code>的功能，但是它依赖一个类加载器实例入参，可以大胆猜测它也是依赖于类加载器的<code>loadClass()</code>进行类加载的。</p>
<h2 id="类重新加载">类重新加载</h2>
<p>先提出一个实验，如果定义一个类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用字节码工具修改<code>say()</code>方法的内容为<code>System.out.println(&quot;Hello Throwable!&quot;);</code>，并且使用自定义的ClassLoader重新加载一个同类名的<code>Sample</code>类，那么通过<code>new</code>关键字实例化出来的<code>Sample</code>对象调用<code>say()</code>到底打印&quot;Hello Doge!“还是&quot;Hello Throwable!”？</p>
<p>先引入字节码工具javassist用于修改类的字节码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.24.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性使用的自定义类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">		CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">		<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">		Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">        <span class="comment">// 类路径中的Demo类</span></span><br><span class="line">		Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">		demo.say();</span><br><span class="line">		<span class="comment">// 新的Demo类</span></span><br><span class="line">		newDemoClass.getDeclaredMethod(<span class="string">"say"</span>).invoke(newDemoClass.newInstance());</span><br><span class="line">		<span class="comment">// 比较</span></span><br><span class="line">		System.out.println(newDemoClass.equals(Demo<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello Doge!</span><br><span class="line">Hello Throwable!</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>这里得出的结论是：</p>
<ul>
<li><code>new</code>关键字只能使用在当前类路径下的类的实例化，而这些类都是由应用类加载器加载，如果上面的例子中<code>newDemoClass.newInstance()</code>强制转换为Demo类型会报错。</li>
<li>通过自定义类加载器加载的和当前类路径相同名全类名的类只能通过反射去使用，而且即使全类名相同，由于类加载器隔离，它们其实是不相同的类。</li>
</ul>
<h3 id="如何避免类重新加载导致内存溢出">如何避免类重新加载导致内存溢出</h3>
<p>实际上，JDK没有提供方法去卸载一个已经加载的类，也就是类的生命周期是由JVM管理的，因此要解决类重新加载导致内存溢出的问题归根结底就是解决重新加载的类被回收的问题。由于创建出来是的<code>java.lang.Class</code>对象，如果需要回收它，则要考虑下面几点：</p>
<ul>
<li>1、<code>java.lang.Class</code>对象反射创建的实例需要被回收。</li>
<li>2、<code>java.lang.Class</code>对象不能被任何地方强引用。</li>
<li>3、加载<code>java.lang.Class</code>对象的<code>ClassLoder</code>已经被回收。</li>
</ul>
<p>基于这几点考虑可以做个试验验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里故意建立一个数组占用大量内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, List&lt;Class&lt;?&gt;&gt;&gt; CACHE = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">			CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">			<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">			Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">			add(classLoader, newDemoClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理类加载器和它加载过的类</span></span><br><span class="line">		clear();</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (CACHE.containsKey(classLoader)) &#123;</span><br><span class="line">			CACHE.get(classLoader).add(clazz);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			CACHE.put(classLoader, classes);</span><br><span class="line">			classes.add(clazz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CACHE.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用VM参数<code>-XX:+PrintGC -XX:+PrintGCDetails</code>执行上面的方法，JDK11默认使用G1收集器，由于Z收集器还在实验阶段，不是很建议使用，执行main方法后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11.374</span>s][info   ][gc,task       ] GC(<span class="number">17</span>) Using <span class="number">8</span> workers of <span class="number">8</span> <span class="keyword">for</span> full compaction</span><br><span class="line">[<span class="number">11.374</span>s][info   ][gc,start      ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>)</span></span><br><span class="line"><span class="function">[11.374s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,stringtable ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Cleaned string and symbol table, strings: 5637 processed, 0 removed, symbols: 135915 processed, 0 removed</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects 54.378ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction 0.422ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers 0.598ms</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap 0.362ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Eden regions: 44-&gt;0<span class="params">(<span class="number">9</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Survivor regions: 12-&gt;0<span class="params">(<span class="number">12</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Old regions: 146-&gt;7</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Humongous regions: 3-&gt;2</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,metaspace   ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Metaspace: 141897K-&gt;9084<span class="title">K</span><span class="params">(<span class="number">1062912</span>K)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc             ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 205M-&gt;3<span class="title">M</span><span class="params">(<span class="number">30</span>M)</span> 273.440ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.31</span>s Sys=<span class="number">0.08</span>s Real=<span class="number">0.27</span>s</span><br></pre></td></tr></table></figure>
<p>可见FullGC之后，元空间(Metaspace)回收了(141897-9084)KB，一共回收了202M的内存空间，初步可以认为元空间的内存被回收了，接下来注释掉main方法中调用的<code>clear()</code>方法，再调用一次main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,heap        ] GC(<span class="number">17</span>) Humongous regions: <span class="number">3</span>-&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,metaspace   ] GC(<span class="number">17</span>) Metaspace: <span class="number">141884</span>K-&gt;<span class="number">141884</span>K(<span class="number">1458176</span>K)</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc             ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 201M-&gt;166<span class="title">M</span><span class="params">(<span class="number">564</span>M)</span> 115.504ms</span></span><br><span class="line"><span class="function">[4.083s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.84</span>s Sys=<span class="number">0.00</span>s Real=<span class="number">0.12</span>s</span><br></pre></td></tr></table></figure>
<p>可见元空间在FullGC执行没有进行回收，而堆内存的回收率也比较低，由此可以得出一个经验性的结论：只需要通过ClassLoader对象做映射关系保存使用它加载出来的新的类，只需要确保这些类没有没强引用、类实例都已经销毁，那么只需要移除ClassLoader对象的引用，那么在JVM进行GC的时候会把ClassLoader对象以及使用它加载的类回收，这样做就可以避免元空间的内存泄漏。</p>
<h2 id="小结">小结</h2>
<p>通过一些资料和实验，深化了类加载过程的一些认识。</p>
<p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机-第二版》</li>
<li>JDK11部分源码</li>
</ul>
<p>(本文完 e-2018129 c-2-d r-20181212)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/08/java-reflection-dynamic-proxy/">
      深入分析Java反射(四)-动态代理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月8日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：27分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-08T20:25:34+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(四)-动态代理</h1>
<h2 id="动态代理的简介">动态代理的简介</h2>
<p>Java动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。Java动态代理实际上通过反射技术，把代理对象和被代理对象(真实对象)的代理关系建立延迟到程序运行之后，动态创建新的代理类去完成对真实对象的代理操作(可以改变原来真实对象的方法行为)，这一点成为了当前主流的AOP框架和延迟加载功能的基础。本文在查看和编写动态代理相关的代码使用的是JDK11，不过JDK动态代理相关的功能和接口已经相对稳定，不必担心JDK版本升级带来的兼容性问题，但是需要注意由于JDK9引入了模块概念，动态代理的源码也有不少的改动。下文先介绍设计模式中的代理模式，接着会分析JDK动态代理的核心类库、流程和机制，最后分析其底层源码级别实现。</p>
<h2 id="设计模式中的代理模式">设计模式中的代理模式</h2>
<p>代理模式是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-2.png" alt="j-r-d-p-2.png"></p>
<p>代理模式主要包括三种角色：</p>
<ul>
<li>Subject抽象主题角色：一般定义为抽象类或者接口，是作为功能的定义，提供一系列抽象的功能方法。</li>
<li>RealSubject具体(真实)主题角色：一般称为被委托角色或者被代理角色，它是Subject的一个具体实现。</li>
<li>ProxySubject代理主题角色：一般称为委托角色或者代理角色，一般ProxySubject也实现(或者继承)Subject，接收一个具体的Subject实例RealSubject，在RealSubject处理前后做预定义或者后置操作，甚至可以直接忽略RealSubject原来的方法。</li>
</ul>
<p>把上面的类图编写成代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"RealSubject doSomething..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.subject = subject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		subject.doSomething();</span><br><span class="line">		doOtherThing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ProxySubject doOtherThing..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(subject);</span><br><span class="line">		proxySubject.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>Client#main()</code>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealSubject doSomething...</span><br><span class="line">ProxySubject doOtherThing...</span><br></pre></td></tr></table></figure>
<p>代理模式在日常的场景中也经常碰到，比较常见的一个场景就是游戏代练，套进去上面的代码可以写个比较生动的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"操作Throwable游戏角色打怪升级"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Player player;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyPlayer</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.player = player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		login();</span><br><span class="line">		<span class="keyword">this</span>.player.playGame();</span><br><span class="line">		logout();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"登录Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"退出Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式有几个比较大的优点：</p>
<ul>
<li>职责清晰：也就是真实主题角色只需要实现具体的逻辑，不需关注代理类的职责，而代理类也只需要处理预处理和后置的逻辑，类的职责分明。</li>
<li>高扩展性：由于职责分明，也就是真实主题角色可以随时修改实现，这样就能通过更新或者替换真实主题的实现并且不改变代理主题角色的情况下改变具体功能。</li>
<li>高灵活性：主要体现在后面提到的动态代理。</li>
</ul>
<h2 id="JDK动态代理的核心API">JDK动态代理的核心API</h2>
<p>JDK动态代理提供外部使用的主要依赖两个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>：可以理解为代理类的工厂类(其实也是父类，见下文)。</li>
<li><code>java.lang.reflect.InvocationHandler</code>：代理实例需要实现的调用处理器接口。</li>
</ul>
<h3 id="Proxy">Proxy</h3>
<p><code>java.lang.reflect.Proxy</code>是JDK动态代理的核心类，它的核心功能是提供静态方法来为一组接口动态地生成代理类并且返回代理实例对象，类似于代理类实例的工厂类。<code>java.lang.reflect.Proxy</code>主要提供四个public静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>InvocationHandler getInvocationHandler(Object proxy)</code>：通过制定的代理类实例查找它关联的调用处理器实例。</li>
<li><code>Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>：用于获取关联于指定类装载器和一组接口的动态代理类的类对象，也就是获取<code>$ProxyXXX</code>的类型，此方法在JDK9以后标记为过期，原因是：在命名模块中生成的代理类是封闭的，模块外的代码无法访问这些类(违反模块规则调用了会抛异常)。</li>
<li><code>boolean isProxyClass(Class&lt;?&gt; cl)</code>：用于判断指定类是否是一个动态代理类。</li>
<li><code>Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code>：这个是JDK动态代理最核心的方法，用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，也就是生成<code>$ProxyXXX</code>的实例。此方法需要指定类加载器<code>java.lang.ClassLoader</code>，Proxy静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是在运行时动态生成的而非预存在于任何一个.class文件中。interfaces是Class数组，也就是需要使用InvocationHandler进行代理访问的接口类型数组，这里的h参数就是调用处理器的实例。</li>
</ul>
<h3 id="InvocationHandler">InvocationHandler</h3>
<p><code>java.lang.reflect.InvocationHandler</code>是调用处理器接口，它自定义了一个<code>invoke</code>方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>proxy：Object类型，此参数即是代理类实例，也就是<code>$ProxyXXX</code>的实例。</li>
<li>method：<code>java.lang.reflect.Method</code>类型，被调用的方法的实例。</li>
<li>args：Object[]类型，被调用方法的参数数组。</li>
</ul>
<p>实现<code>java.lang.reflect.InvocationHandler</code>接口，通过实现<code>invoke</code>方法即可添加代理访问的逻辑，在这个逻辑代码块中除了可以调用委托类的方法，还可以织入额外的自定义逻辑，AOP就是这样实现的。</p>
<h2 id="JDK动态代理的流程">JDK动态代理的流程</h2>
<p>JDK动态代理的使用流程如下：</p>
<ul>
<li>1、通过实现<code>java.lang.reflect.InvocationHandler</code>接口创建自定义的调用处理器。</li>
<li>2、通过为<code>java.lang.reflect.Proxy</code>类指定<code>ClassLoader</code>对象和一组interface来创建动态代理类。</li>
<li>3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型。</li>
<li>4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy为包括Interface接口在内的一组接口动态创建代理类的类对象</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span>, ... &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过反射从生成的类对象获得构造函数对象</span></span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数对象创建动态代理类实例</span></span><br><span class="line">Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的过程比较复杂，可以进行精简。简化后的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl实现了InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">handler</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="JDK动态代理的机制">JDK动态代理的机制</h2>
<p>首先是JDK动态代理生成的代理类本身的特点：</p>
<ul>
<li>1、<strong>包(或者JDK9引入的模块)</strong>：如果所代理的接口都是public的，那么它将被定义在包<code>com.sun.proxy</code>；如果所代理的接口中有非public的接口(因为接口不能被定义为protect或private，所以除public之外就是默认的package访问级别，修饰符为default)，那么它将被定义在该接口所在包(假设代理了<code>throwable.club</code>包中的某非public接口A，那么新生成的代理类所在的包就是<code>throwable.club</code>)，值得注意的是，<strong>如果接口数组中存在非public的接口，那么它们必须在同一个包路径下，否则会抛异常</strong>。这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问。</li>
<li>2、<strong>类修饰符</strong>：该代理类具有final和public修饰符，<strong>意味着它可以被所有的类访问，但是不能被再度继承</strong>。</li>
<li>3、<strong>类名</strong>：代理类名称格式是<code>$ProxyN</code>，其中N是一个逐一递增的阿拉伯数字，代表<code>java.lang.reflect.Proxy</code>类第N次生成的动态代理类，值得注意的一点是，并不是每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口(包括接口排列的顺序相同)试图重复创建动态代理类，它会从缓存中获取先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li>
<li>4、<strong>类继承关系</strong>：代理类的继承关系图如下：</li>
</ul>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-1.png" alt="j-r-d-p-1.png"></p>
<p>由图可知，<code>java.lang.reflect.Proxy</code>类是代理类的父类，这个规则适用于所有由<code>java.lang.reflect.Proxy</code>创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。</p>
<h3 id="代理类实例的特点">代理类实例的特点</h3>
<p>每个代理类实例都会关联一个调用处理器对象，可以通过<code>java.lang.reflect.Proxy</code>提供的静态方法<code>getInvocationHandler()</code>去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行，此外，值得注意的是，代理类的根类<code>java.lang.Object</code>中有三个方法也同样会被分派到调用处理器的<code>invoke</code>方法执行，它们是<code>hashCode</code>、<code>equals</code>和<code>toString</code>，可能的原因有：</p>
<ul>
<li>一、因为这些方法为public且非final类型，能够被代理类覆盖。</li>
<li>二、因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口(或继承于该接口的某子接口)的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。</li>
</ul>
<h3 id="被代理的一组接口的特点">被代理的一组接口的特点</h3>
<p>首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过65535，这是JVM设定的限制，这一点在代理类生成的时候也做了判断。</p>
<h3 id="异常处理">异常处理</h3>
<p>从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于Throwable接口，但事实是否如此呢？答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛Throwable异常。那么如果在invoke方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Jdk动态代理类已经为我们设计好了解决方法：它将会抛出<code>UndeclaredThrowableException</code> 异常。这个异常是一个<code>RuntimeException</code>类型，所以不会引起编译错误。通过该异常的<code>getCause</code>方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。</p>
<h2 id="JDK动态代理源码分析">JDK动态代理源码分析</h2>
<p>因为JDK动态代理核心逻辑都在<code>java.lang.reflect.Proxy</code>类中，下面简单分析一下这个类的源码。先看<code>Proxy</code>类中的几个重要的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口组中接口都为为public时候代理类创建的包路径：com.sun.proxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的构造方法参数类型数组，可见代理类的构造参数只有InvocationHandler类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存了所有已经调用过setAccessible(true)的代理类的构造(Constructor)实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这里注意到<code>ClassLoaderValue</code>，下文会调用到它的一个很复杂的调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intf是Class&lt;?&gt;类型</span></span><br><span class="line"><span class="comment">//loader是类加载器实例</span></span><br><span class="line"><span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">    loader,</span><br><span class="line">    (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BiFunction&lt;? <span class="keyword">super</span> ClassLoader,? <span class="keyword">super</span> CLV,? extends V&gt; mappingFunction)</span> </span></span><br><span class="line"><span class="function">						<span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>上面的<code>computeIfAbsent</code>中使用了函数式接口和Lambda表达式，如果Lambda表达式玩的比较熟练看起来应该没问题，它的功能可以解读为：通过接口类型和类加载器实例计算通过接口类型和类加载器实例构建<code>ProxyBuilder</code>实例并且调用<code>ProxyBuilder#build()</code>得到的结果，如果结果已经存在则直接返回缓存。其实<code>computeIfAbsent</code>在<code>Map</code>接口中也定义了同样的方法，功能是相似的。</p>
<p>接着看<code>Proxy</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此可以明确一点，既然所有动态代理类都是<code>java.lang.reflect.Proxy</code>的子类，那么它们一定具备一个包含<code>InvocationHandler</code>参数的构造器。接着查看``方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空判断									  </span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="comment">// 当前调用类获取</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">                                    ? <span class="keyword">null</span></span><br><span class="line">                                    : Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 获取代理类的构造器实例								</span></span><br><span class="line">    Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line">    <span class="comment">// 生成代理实例</span></span><br><span class="line">    <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看<code>getProxyConstructor</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; getProxyConstructor(Class&lt;?&gt; caller,</span><br><span class="line">                                                  ClassLoader loader,</span><br><span class="line">                                                  Class&lt;?&gt;... interfaces)&#123;</span><br><span class="line">    <span class="comment">// 这里需要区分代理接口数组中只有单个接口和多个接口的逻辑				  </span></span><br><span class="line">    <span class="comment">// 而基本的逻辑都是先校验当前调用类的权限，后续获取Constructor实例委托到ProxyBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length == <span class="number">1</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; intf = interfaces[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 接口克隆</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfsArray = interfaces.clone();</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intfsArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intfs).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明确，核心的逻辑都交给了<code>Proxy</code>的内部类<code>ProxyBuilder</code>完成，先看<code>ProxyBuilder</code>的静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的简单类名的前置字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成下一个代理类的数字计数器，记住它是静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了已经生成的代理类-Boolean的映射，已经生成过对应代理类则记录为true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Boolean&gt; reverseProxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个代理接口的情况，其实也是把接口转换为List</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, Class&lt;?&gt; intf) &#123;</span><br><span class="line">    <span class="keyword">this</span>(loader, Collections.singletonList(intf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个代理接口的情况</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    <span class="comment">// 通过JVM参数强制关闭动态代理功能则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isModuleSystemInited()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Proxy is not supported until "</span></span><br><span class="line">                + <span class="string">"module system is fully initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理接口数量不能超过65535，也就是最多代理65535个接口</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded: "</span></span><br><span class="line">                + interfaces.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集接口数组中所有接口的非静态方法的返回值类型、共享(shared)参数类型和共享(shared)异常类型，注释说是收集代理接口的方法签名</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; refTypes = referencedTypes(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保上一步得到的代理接口方法签名的类型都是"可见(其实就是类型都存在)"的，通过遍历调用Class.forName(type.getName(), false, ld)去判断</span></span><br><span class="line">    validateProxyInterfaces(loader, interfaces, refTypes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="comment">// 获取代理类最终生成的模块，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、所有代理接口的修饰符都为public，接口所在模块都能公开访问，则返回unnamed模块</span></span><br><span class="line">    <span class="comment">// 2、如果有任意的代理接口是包私有，则返回该包所在的模块		、</span></span><br><span class="line">    <span class="comment">// 3、所有代理接口的修饰符都为public，有任意至少一个接口所在模块不能公开访问，则返回该不能公开访问的模块，</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = mapToModule(loader, interfaces, refTypes);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getLoader</span><span class="params">(<span class="keyword">module</span>)</span> </span>== loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个构造器处理的逻辑也是相对复杂，主要是因为引入模块管理的概念，接着看<code>ProxyBuilder#build()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; build() &#123;</span><br><span class="line">    <span class="comment">// 定义代理类，实际上是动态生成代理类字节码和缓存它的类型的过程</span></span><br><span class="line">    Class&lt;?&gt; proxyClass = defineProxyClass(<span class="keyword">module</span>, interfaces);</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回代理类的构造</span></span><br><span class="line">        cons = proxyClass.getConstructor(constructorParams);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到逻辑最复杂的代理类的生成过程<code>ProxyBuilder#defineProxyClass()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">    <span class="comment">// 这里就是定义代理类包路径的逻辑，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、代理接口数组所有接口都是public修饰，则代理类包路径为com.sun.proxy</span></span><br><span class="line">    <span class="comment">// 2、代理接口数组有任意接口是包私有的，则代理类包路径为该私有包的路径			</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;  <span class="comment">// non-public, final</span></span><br><span class="line">            String pkg = intf.getPackageName();</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面几个if都是包路径的合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// all proxy interfaces are public</span></span><br><span class="line">        proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + <span class="string">"."</span> + m.getName()</span><br><span class="line">                               : PROXY_PACKAGE_PREFIX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proxyPkg.isEmpty() &amp;&amp; m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Unnamed package cannot be added to "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.getDescriptor().packages().contains(proxyPkg)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(proxyPkg + <span class="string">" not exist in "</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器加1返回新的计数值			</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    <span class="comment">// 生成代理类全类名，一个常见的格式是：com.sun.proxy.$Proxy1</span></span><br><span class="line">    String proxyName = proxyPkg.isEmpty()</span><br><span class="line">                            ? proxyClassNamePrefix + num</span><br><span class="line">                            : proxyPkg + <span class="string">"."</span> + proxyClassNamePrefix + num;</span><br><span class="line">    ClassLoader loader = getLoader(m);</span><br><span class="line">    trace(proxyName, m, loader, interfaces);</span><br><span class="line">    <span class="comment">// 动态生成代理类字节码字节数组			</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Unsafe定义代理类-这里是通过字节码定义新的类				</span></span><br><span class="line">        Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span><br><span class="line">                                         <span class="number">0</span>, proxyClassFile.length,</span><br><span class="line">                                         loader, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 缓存代理类已经生成过的标记												 </span></span><br><span class="line">        reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步为止，代理类的生成过程已经大致分析完毕，<code>ProxyGenerator</code>中涉及到大量字节码操作，这里就不深入分析了。那么回到最前面的方法，得到代理类和它的构造实例，接着就可以生成代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(Class&lt;?&gt; caller, // <span class="keyword">null</span> <span class="keyword">if</span> no SecurityManager</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Constructor&lt;?&gt; cons,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(caller, cons.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里简单反射调用Constructor#newInstance(h)</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结一下：</p>
<ul>
<li><strong>接口数组中所有接口元素的类修饰符最好一致为public。如果接口数组中存在非default修饰的接口元素，那么接口数组中的所有接口类都要放在同一个包下，并且都要使用default修饰。</strong></li>
<li>很少情况下我们修改接口的修饰符，默认为public，那么所有代理类的包路径都是<code>com.sun.proxy</code>，全类名是:<code>com.sun.proxy.$ProxyN</code>。</li>
<li>代理接口数量不能超过65535。</li>
</ul>
<h2 id="JDK动态代理类的源代码">JDK动态代理类的源代码</h2>
<p>前面已经分析完了代理类的生成过程，这里举个简单的使用例子，并且观察生成的动态代理类的源代码。</p>
<p><strong>使用例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before say hello...</span><br><span class="line">throwable say hello!</span><br><span class="line">After say hello...</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在被代理类<code>DefaultSimple</code>实例的方法调用前后织入了自定义的逻辑，这就是通过JDK动态代理实现AOP的底层原理。在JDK8中可以直接使用<code>sun.misc.ProxyGenerator</code>去输出代理类的class文件，但是JDK11中这个代理类生成器已经变成<code>java.lang.reflect.ProxyGenerator</code>，并且这个类是包私有的，我们无法使用，但是它提供了<code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>这个VM参数让我们可以保存代理类的class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># JVM参数</span><br><span class="line">-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>配置好VM参数后，再次调用mian方法就能看到在项目的顶层包路径下看到对应的类<code>com.sun.proxy.$Proxy0</code>，目前从<code>java.lang.reflect.ProxyGenerator</code>源码看无法控制代理类文件的输出路径，生成的代理类内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类的代码比较简单，有如下几个特点：</p>
<ul>
<li>1、代理类继承于<code>java.lang.reflect.Proxy</code>，实现了接口数组中的接口元素类，构造函数只有一个<code>InvocationHandler</code>类型的参数。</li>
<li>2、接口中的所有被代理方法包括<code>equals</code>、<code>toString</code>、<code>hashCode</code>都建立了一个对应的Method私有静态实例，在最后面的静态代码块中实例化。</li>
<li>3、所有代理方法都是用public final修饰，也就是代理类中的代理方法是不能覆盖的。</li>
<li>4、所有代理方法都是通过<code>InvocationHandler</code>实例的<code>invoke</code>方法进行调用的，记得第一个参数是代理类实例本身，如果用了在<code>InvocationHandler#invoke()</code>方法实现过程中使用了这个参数有可能造成死循环。</li>
</ul>
<h2 id="小结">小结</h2>
<p>诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的<strong>单继承机制</strong>注定了这些动态代理类们无法实现对class的动态代理(所以只能代理接口，实际上是基于反射对方法级别的逻辑进行编织)。有很多条理由，可以否定对class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。但是，不完美并不等于不伟大，伟大是一种本质，JDK动态代理就是佐例。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第1部分</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy2/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第2部分</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 e-20181208 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/05/java-reflection-generics/">
      深入分析Java反射(三)-泛型
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月5日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：28分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-05T23:20:21+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月5日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(三)-泛型</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射中一个比较难的问题-泛型。</p>
<h2 id="泛型的简介">泛型的简介</h2>
<p>泛型是在2004年JavaSE 5.0(JDK1.5)版本中添加到Java编程语言中的泛型编程工具。泛型的设计是为了应用在Java的类型系统，<strong>提供&quot;用类型或者方法操作各种类型的对象从而提供编译期的类型安全功能(原文：a type or method to operate on objects of various types while providing compile-time type safety)&quot;</strong>。但是在2016年的一些研究表明，泛型并不是在所有的情况下都能保证编译期的类型安全，例如切面(Aspect)编程的编译期类型安全并没有完全实现。</p>
<p><strong>泛型的一个最大的优点就是：提供编译期的类型安全</strong>。举个很简单的例子，在引入泛型之前，<code>ArrayList</code>内部只维护了一个Object数组引用，这种做法有两个问题：</p>
<ul>
<li>从数组列表获取一个元素的时候必须进行类型的强转。</li>
<li>向数组列表中可以添加任何类型的对象，导致无法得知数组列表中存放了什么类型的元素。</li>
</ul>
<p>引入泛型之后，我们可以通过类型参数明确定义<code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaSE 7以后的版本中构造函数可以省略类型，编译器可以推导出实际类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>下面先列举出Java中泛型的一些事实：</p>
<ul>
<li><strong>Java虚拟机中不存在泛型，只有普通的类和方法，但是字节码中存放着泛型相关的信息</strong>。</li>
<li>所有的类型参数都使用它们的限定类型替换。</li>
<li>桥方法(Bridge Method)由编译器合成，用于保持多态(<strong>Java虚拟机利用方法的参数类型、方法名称和方法返回值类型确定一个方法</strong>)。</li>
<li>为了保持类型的安全性，必要时需要进行类型的强制转换。</li>
</ul>
<h2 id="理解类型擦除">理解类型擦除</h2>
<h3 id="类型擦除是什么">类型擦除是什么</h3>
<p>类型擦除(或者更多时候喜欢称为&quot;<strong>泛型擦除</strong>&quot;)的具体表现是：无论何时定义一个泛型类型，都自动提供一个相应的原始类型(Raw Type，这里的原始类型并不是指int、boolean等基本数据类型)，原始类型的类名称就是带有泛型参数的类删去泛型参数后的类型名称，而原始类型会擦除(Erased)类型变量，并且把它们替换为限定类型(如果没有指定限定类型，则擦除为Object类型)，举个例子<code>Pair&lt;T&gt;</code>带有泛型参数的类型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>擦除类型后的<code>Pair&lt;T&gt;</code>的原始类型为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个更复杂的例子，如果泛型参数类型是有上限的，变量会擦除为上限的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T lower;</span><br><span class="line">	<span class="keyword">private</span> T upper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T lower, T upper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lower = lower;</span><br><span class="line">		<span class="keyword">this</span>.upper = upper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除后的<code>Interval&lt;T extends Comparable &amp; Serializable&gt;</code>原始类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Comparable lower;</span><br><span class="line">	<span class="keyword">private</span> Comparable upper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable lower, Comparable upper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lower = lower;</span><br><span class="line">		<span class="keyword">this</span>.upper = upper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种多个泛型上限的类型，应该尽量把标识接口上限类型放在边界列表的尾部，这样做可以提高效率。</p>
<h3 id="为什么需要擦除类型">为什么需要擦除类型</h3>
<p>在JDK1.5之前，也就是在泛型出现之前，所有的类型包括基本数据类型(int、byte等)、包装类型、其他自定义的类型等等都可以使用类文件(.class)字节码对应的<code>java.lang.Class</code>描述，也就是<code>java.lang.Class</code>类的一个具体实例对象就可以代表任意一个指定类型的原始类型。这里把泛型出现之前的所有类型暂时称为&quot;历史原始类型&quot;。</p>
<p>在JDK1.5之后，数据类型得到了扩充，出历史原始类型扩充了四种泛型类型：参数化类型(ParameterizedType)、类型变量类型(TypeVariable)、限定符类型(WildcardType)、泛型数组类型(GenericArrayType)。历史原始类型和新扩充的泛型类型都应该统一成各自的字节码文件类型对象，也就应该把泛型类型归并进去<code>java.lang.Class</code>中。但是由于JDK已经迭代了很多版本，泛型并不属于当前Java中的基本成分，如果JVM中引入真正的泛型类型，那么必须涉及到JVM指令集和字节码文件的修改(这个修改肯定不是小的修改，因为JDK当时已经迭代了很多年，而类型是编程语言的十分基础的特性，引入泛型从项目功能迭代角度看可能需要整个JVM项目做回归测试)，这个功能的代价十分巨大，所以Java没有在Java虚拟机层面引入泛型。</p>
<p>Java为了使用泛型，于是使用了类型擦除的机制引入了&quot;泛型的使用&quot;，并没有真正意义上引入和实现泛型。Java中的泛型实现的是编译期的类型安全，也就是泛型的类型安全检查是在编译期由编译器(常见的是javac)实现的，这样就能够确保数据基于类型上的安全性并且避免了强制类型转换的麻烦(实际上，强制类型转换是由编译器完成了，只是不需要人为去完成而已)。<strong>一旦编译完成，所有的泛型类型都会被擦除，如果没有指定上限，就会擦除为Object类型，否则擦除为上限类型。</strong></p>
<p>既然Java虚拟机中不存在泛型，那么为什么可以从JDK中的一些类库获取泛型信息？这是因为类文件(.class)或者说字节码文件本身存储了泛型的信息，相关类库(可以是JDK的类库，也可以是第三方的类库)读取泛型信息的时候可以从字节码文件中提取，例如比较常用的字节码操作类库ASM就可以读取字节码中的信息甚至改造字节码动态生成类。例如前面提到的<code>Interval&lt;T extends Comparable &amp; Serializable&gt;</code>类，使用<code>javap -c -v</code>命令查看其反编译得到的字节码信息，可以看到其签名如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature: #22                          // &lt;T::Ljava/lang/Comparable;:Ljava/io/Serializable;&gt;Ljava/lang/Object;Ljava/io/Serializable;</span><br></pre></td></tr></table></figure>
<p>这里的签名信息实际上是保存在常量池中的，关于字节码文件的解析将来会出一个系列文章详细展开。</p>
<h2 id="Type体系">Type体系</h2>
<p>前文提到了在JDK1.5中引入了四种新的泛型类型<code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code>、<code>java.lang.reflect.GenericArrayType</code>，包括原来存在的<code>java.lang.Class</code>，一共存在五种类型。为了程序的扩展性，引入了<code>java.lang.reflect.Type</code>类作为这五种类型的公共父接口，这样子就可以使用<code>java.lang.reflect.Type</code>类型参数去接收以上五种子类型的实参或者返回值，由此从逻辑上统一了泛型相关的类型和原始存在的<code>java.lang.Class</code>描述的类型。Type体系如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-g-1.png" alt="j-r-g-1.png"></p>
<p>注意：</p>
<ul>
<li>ParameterizedType、TypeVariable、WildcardType、GenericArrayType都是接口，它们位于<code>java.lang.reflect</code>包中。</li>
<li>ParameterizedTypeImpl、TypeVariableImpl、WildcardTypeImpl、GenericArrayTypeImpl是四种泛型类型的实现，位于<code>sun.reflect.generics.reflectiveObjects</code>包中。</li>
</ul>
<p>Type体系虽然看似很美好解决了泛型相关的类型和原始存在的<code>java.lang.Class</code>描述的类型的统一问题，但是引入了新的问题：如果一个方法返回值为<code>java.lang.reflect.Type</code>类型，或者一个方法的入参类型为<code>java.lang.reflect.Type</code>类型，这两种情况下，可能需要对<code>java.lang.reflect.Type</code>类型的对象做子类型判断，因为它的子类型有可能是上面提到的五种类型中的其中一种，这一点提高了编码的复杂性。</p>
<h3 id="ParameterizedType">ParameterizedType</h3>
<p>ParameterizedType，parameterized type，也就是参数化类型，注释里面说到<code>ParameterizedType</code>表示一个参数化类型，例如<code>Collection&lt;String&gt;</code>，实际上只要带有参数化(泛型)标签<code>&lt;ClassName&gt;</code>的参数或者属性，都属于ParameterizedType。例如下面的类型都是ParameterizedType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set;</span><br><span class="line">Class&lt;Integer&gt; clazz;</span><br><span class="line">MyClass&lt;String&gt; myClass;</span><br><span class="line">List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而像下面的忽略泛型参数或者基本数据类型和基本数据类型的包装类都不是ParameterizedType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"throwbale"</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">Set set;</span><br><span class="line">List list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.lang.reflect.ParameterizedType</code>接口继承自<code>java.lang.reflect.Type</code>接口，实现类是<code>sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</code>，其实，必要的时候，我们也可以自行实现ParameterizedType，像一些Json解析工具都是自行实现ParameterizedType的。ParameterizedType接口的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getActualTypeArguments()：返回这个ParameterizedType类型的参数的实际类型Type数组，Type数组里面的元素有可能是Class、ParameterizedType、TypeVariable、GenericArrayType或者WildcardType之一。值得注意的是，无论泛型符号<code>&lt;&gt;</code>中有几层<code>&lt;&gt;</code>嵌套，这个方法仅仅脱去最外层的<code>&lt;&gt;</code>，之后剩下的内容就作为这个方法的返回值。</li>
<li>Type getRawType()：返回的是当前这个ParameterizedType的原始类型，从ParameterizedTypeImpl的源码看来，原始类型rawType一定是一个<code>Class&lt;?&gt;</code>实例。举个例子，<code>List&lt;Person&gt;</code>通过<code>getRawType()</code>获取到的Type实例实际上是<code>Class&lt;?&gt;</code>实例，和List.class等价。</li>
<li>Type getOwnerType()：获取原始类型所属的类型，从ParameterizedTypeImpl的源码看来，就是调用了原始类型rawType的<code>getDeclaringClass()</code>方法，而像rawType为<code>List&lt;T&gt;</code>、<code>Map&lt;T&gt;</code>这些类型的getOwnerType()实际上就是调用List.class.getDeclaringClass()，Map.class.getDeclaringClass()，返回值都是null。</li>
</ul>
<p>举个关于ParameterizedType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main13</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Sub&gt; subClass = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Type genericSuperclass = subClass.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">            <span class="comment">//获取父类泛型类型数组</span></span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type type : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(type + <span class="string">" is ParameterizedType -&gt; "</span> + (type <span class="keyword">instanceof</span> ParameterizedType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Field field = subClass.getDeclaredField(<span class="string">"clazz"</span>);</span><br><span class="line">        Type genericType = field.getGenericType();</span><br><span class="line">        System.out.println(genericType + <span class="string">" is ParameterizedType -&gt; "</span> + (genericType <span class="keyword">instanceof</span> ParameterizedType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span>&lt;<span class="title">String</span>, <span class="title">List</span>&lt;<span class="title">Person</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">false</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">util</span>.<span class="title">List</span>&lt;<span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main13</span>$<span class="title">Person</span>&gt; <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">true</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>&lt;?&gt; <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">true</span></span></span><br></pre></td></tr></table></figure>
<h3 id="TypeVariable">TypeVariable</h3>
<p>TypeVariable，type variable，也就是类型变量，它是各种类型变量的公共父接口，它主要用来表示带有上界的泛型参数的信息，它和ParameterizedType不同的地方是，ParameterizedType表示的参数的最外层一定是已知具体类型的(如<code>List&lt;String&gt;</code>)，而TypeVariable面向的是K、V、E等这些泛型参数字面量的表示。常见的TypeVariable的表示形式是<code>&lt;T extends KnownType-1 &amp; KnownType-2&gt;</code>。TypeVariable接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获得泛型的上限，若未明确声明上边界则默认为Object</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    <span class="comment">//获取声明该类型变量实体(即获得类、方法或构造器名)</span></span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得名称，即K、V、E之类名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得注解类型的上限，若未明确声明上边界则默认为长度为0的数组</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getBounds()：获得该类型变量的上限(上边界)，若无显式定义(extends)，默认为Object，类型变量的上限可能不止一个，因为可以用&amp;符号限定多个（这其中有且只能有一个为类或抽象类，且必须放在extends后的第一个，即若有多个上边界，则第一个&amp;之后的必为接口）。</li>
<li>D getGenericDeclaration：获得声明(定义)这个类型变量的类型及名称，会使用泛型的参数字面量表示，如<code>public void club.throwable.Main.query(java.util.List&lt;club.throwable.Person&gt;)</code>。</li>
<li>String getName()：获取泛型参数的字面量名称，即K、V、E之类名称。</li>
<li>AnnotatedType[] getAnnotatedBounds()：Jdk1.8新增的方法，用于获得注解类型的上限，若未明确声明上边界则默认为长度为0的数组。</li>
</ul>
<p>举个关于TypeVariable的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main14</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; subClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        TypeVariable&lt;Class&lt;Supper&gt;&gt;[] typeParameters = subClass.getTypeParameters();</span><br><span class="line">        <span class="keyword">for</span> (TypeVariable&lt;Class&lt;Supper&gt;&gt; typeVariable : typeParameters) &#123;</span><br><span class="line">            System.out.println(<span class="string">"getBounds --&gt; "</span> + Arrays.toString(typeVariable.getBounds()));</span><br><span class="line">            System.out.println(<span class="string">"getGenericDeclaration  --&gt; "</span> + typeVariable.getGenericDeclaration());</span><br><span class="line">            System.out.println(<span class="string">"getName --&gt; "</span> + typeVariable.getName());</span><br><span class="line">            AnnotatedType[] annotatedBounds = typeVariable.getAnnotatedBounds();</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"getAnnotatedBounds --&gt; "</span>);</span><br><span class="line">            <span class="keyword">for</span> (AnnotatedType annotatedType : annotatedBounds) &#123;</span><br><span class="line">                java.lang.annotation.Annotation[] annotations = annotatedType.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span> (java.lang.annotation.Annotation annotation : annotations) &#123;</span><br><span class="line">                    stringBuilder.append(annotation).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(stringBuilder.toString());</span><br><span class="line">            System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Annotation &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">InterFace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Person</span> &amp; <span class="title">InterFace</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getBounds --&gt; [class org.throwable.inherited.Main14$Person, interface org.throwable.inherited.Main14$InterFace]</span><br><span class="line">getGenericDeclaration  --&gt; <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main14</span>$<span class="title">Supper</span></span></span><br><span class="line"><span class="class"><span class="title">getName</span> --&gt; <span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">getAnnotatedBounds</span> --&gt;</span></span><br><span class="line"><span class="class"></span>===================</span><br><span class="line">getBounds --&gt; [interface org.throwable.inherited.Main14$Annotation]</span><br><span class="line">getGenericDeclaration  --&gt; <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main14</span>$<span class="title">Supper</span></span></span><br><span class="line"><span class="class"><span class="title">getName</span> --&gt; <span class="title">E</span></span></span><br><span class="line"><span class="class"><span class="title">getAnnotatedBounds</span> --&gt;</span></span><br><span class="line"><span class="class"></span>===================</span><br></pre></td></tr></table></figure>
<h3 id="WildcardType">WildcardType</h3>
<p>WildcardType用于表示通配符(?)类型的表达式的泛型参数，例如<code>&lt;? extends Number&gt;</code>等。根据WildcardType注释提示：现阶段通配符表达式仅仅接受一个上边界或者下边界，这个和定义类型变量时候可以指定多个上边界是不一样。但是为了保持扩展性，这里返回值类型写成了数组形式。实际上现在返回的数组的大小就是1。WildcardType接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WildcardType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getUpperBounds();</span><br><span class="line"></span><br><span class="line">    Type[] getLowerBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getUpperBounds()：获取泛型通配符的上限类型Type数组，实际上目前该数组只有一个元素，也就是说只能有一个上限类型。</li>
<li>Type[] getLowerBounds()：获取泛型通配符的下限类型Type数组，实际上目前该数组只有一个元素，也就是说只能有一个下限类型。</li>
</ul>
<p>举个关于WildcardType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main16</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Main16&gt; clazz = Main16<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"print"</span>.equals(method.getName())) &#123;</span><br><span class="line">                Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (Type type : genericParameterTypes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                        ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                        <span class="keyword">for</span> (Type actualType : actualTypeArguments) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (actualType <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">                                WildcardType wildcardType = (WildcardType) actualType;</span><br><span class="line">                                System.out.println(<span class="string">"WildcardType --&gt; "</span> + wildcardType + <span class="string">" getUpperBounds--&gt; "</span></span><br><span class="line">                                        + Arrays.toString(wildcardType.getUpperBounds()) + <span class="string">" getLowerBounds--&gt; "</span> + Arrays.toString(wildcardType.getLowerBounds()));</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Not WildcardType --&gt; "</span> + actualType);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;? extends Number&gt; list, Set&lt;? <span class="keyword">super</span> Person&gt; persons)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WildcardType --&gt; ? extends java.lang.Number getUpperBounds--&gt; [class java.lang.Number] getLowerBounds--&gt; []</span><br><span class="line">WildcardType --&gt; ? super org.throwable.inherited.Main16$Person getUpperBounds--&gt; [class java.lang.Object] getLowerBounds--&gt; [interface org.throwable.inherited.Main16$Person]</span><br></pre></td></tr></table></figure>
<p>这里注意的是<code>List&lt;? extends Number&gt; list</code>这个参数整体来看是ParameterizedType类型，剥掉第一次List之后的<code>? extends Number</code>是WildcardType类型。</p>
<h3 id="GenericArrayType">GenericArrayType</h3>
<p>GenericArrayType，generic array type，也就是泛型数组，也就是元素类型为泛型类型的数组实现了该接口。它要求元素的类型是ParameterizedType或TypeVariable(实际中发现元素是GenericArrayType也是允许的)。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] listArray; <span class="comment">//是GenericArrayType,元素是List&lt;String&gt;类型，也就是ParameterizedType类型</span></span><br><span class="line">T[] tArray; <span class="comment">//是GenericArrayType,元素是T类型，也就是TypeVariable类型</span></span><br><span class="line"></span><br><span class="line">Person[] persons; <span class="comment">//不是GenericArrayType</span></span><br><span class="line">List&lt;String&gt; strings; <span class="comment">//不是GenericArrayType</span></span><br></pre></td></tr></table></figure>
<p>GenericArrayType接口的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericArrayType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type getGenericComponentType()：获取泛型数组中元素的类型。注意无论从左向右有几个<code>[]</code>并列，这个方法仅仅脱去最右边的<code>[]</code>之后剩下的内容就作为这个方法的返回值。</li>
</ul>
<p>举个关于GenericArrayType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main15</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method[] methods = Main15<span class="class">.<span class="keyword">class</span>.<span class="title">getMethods</span>()</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"method"</span>.equals(method.getName())) &#123;</span><br><span class="line">                Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (Type type : genericParameterTypes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"GenericArrayType --&gt; "</span> + type + <span class="string">" getGenericComponentType --&gt; "</span></span><br><span class="line">                                + ((GenericArrayType) type).getGenericComponentType());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Not GenericArrayType --&gt; "</span> + type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String[] strings, List&lt;String&gt; ls, List&lt;String&gt;[] lsa, T[] ts, List&lt;T&gt;[] tla, T[][] tts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Not GenericArrayType --&gt; class [Ljava.lang.String;</span><br><span class="line">Not GenericArrayType --&gt; java.util.List&lt;java.lang.String&gt;</span><br><span class="line">GenericArrayType --&gt; java.util.List&lt;java.lang.String&gt;[] getGenericComponentType --&gt; java.util.List&lt;java.lang.String&gt;</span><br><span class="line">GenericArrayType --&gt; T[] getGenericComponentType --&gt; T</span><br><span class="line">GenericArrayType --&gt; java.util.List&lt;T&gt;[] getGenericComponentType --&gt; java.util.List&lt;T&gt;</span><br><span class="line">GenericArrayType --&gt; T[][] getGenericComponentType --&gt; T[]</span><br></pre></td></tr></table></figure>
<p>这里分析一下：</p>
<ul>
<li><code>String[] strings</code>：数组是Class类型。</li>
<li><code>List&lt;String&gt; ls</code>：列表是ParameterizedType类型。</li>
<li><code>List&lt;String&gt;[] lsa</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是<code>java.util.List&lt;java.lang.String&gt;</code>，也就是数组元素是ParameterizedType类型。</li>
<li><code>T[] ts</code>：s数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是T，也就是数组元素是TypeVariable类型。</li>
<li><code>List&lt;T&gt;[] tla</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是<code>java.util.List&lt;T&gt;</code>，也就是数组元素是ParameterizedType类型。</li>
<li><code>T[][] tts</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型T[]，也就是数组元素是GenericArrayType类型。</li>
</ul>
<h2 id="泛型的约束">泛型的约束</h2>
<p>使用Java泛型的时候需要考虑一些限制，这些限制大多数是由泛型类型擦除引起的。</p>
<ul>
<li>1、不能用基本类型实例化类型参数，也就是8种基本类型不能作为泛型参数，例如<code>Pair&lt;int&gt;</code>是非法的，会导致编译错误，而<code>Pair&lt;Integer&gt;</code>是合法的。</li>
<li>2、运行时的类型查询只能适用于原始类型(非参数化类型)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的两种做法是错误的</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;)  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair)  <span class="comment">//Right</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3、不能创建参数化类型的数组，例如<code>Pair&lt;String&gt;[] arr = new Pair&lt;String&gt;[10]</code>是非法的。</li>
<li>4、不能实例化类型变量或者类型变量数组，例如<code>T t = new T()</code>或者<code>T[] arr = new T[10]</code>都是非法的。</li>
<li>5、Varargs警告，这是因为第4点原因导致的，一般会发生在泛型类型变量作为可变参数的情况，例如<code>public static &lt;T&gt; addAll(Collection&lt;T&gt; con,T ... ts)</code>，第二个参数实际上就是泛型类型变量数组，但是这种情况是合法的，不过会受到编译器的警告，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解或者<code>@SafeVarargs</code>注解标注该方法以消除警告。</li>
<li>6、不能在静态域或者方法中引用类型变量，例如<code>private static T singleInstance;</code>这样是非法的。</li>
<li>7、不能抛出或者抛出或者捕获泛型类型变量，但是如果在异常规范中使用泛型类型变量则是允许的，举两个例子仔细品味一下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(T t)&#123;  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable e)&#123;  </span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8、通过使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解可以消除Java类型系统的部分基本限制，一般使用在强制转换原始类型为泛型类型(只是在编译层面告知编译器)的情况，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加此注解会收到编译器的警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有泛型的继承规则和通配符规则(可以看下前面介绍的Type的子类型)等等，这里不详细展开。</p>
<h2 id="再议泛型数组的问题">再议泛型数组的问题</h2>
<p>在Java泛型约束中，无法实例化参数化类型数组，例如<code>Pair&lt;Integer&gt;[] table = new Pair&lt;Integer&gt;[10];</code>是非法的。根本原因在于泛型类型的擦除和数组会记录元素类型的特性。举个例子，假设可以实例化参数化类型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>上面的参数化类型数组在泛型擦除之后，数组实例table的类型为<code>Pair[]</code>，数组元素类型为<code>Pair</code>，可以强转为<code>Object[]</code>类型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArray = table;</span><br></pre></td></tr></table></figure>
<p>基于泛型擦除，数组objArray可以任意赋值<code>Pair&lt;AnyType&gt;</code>的泛型化实例，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objArray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Integer&gt;();</span><br><span class="line">objArray[<span class="number">1</span>] = <span class="keyword">new</span> Pair&lt;Long&gt;();</span><br><span class="line">objArray[<span class="number">2</span>] = <span class="keyword">new</span> Pair&lt;String&gt;();</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><strong>这样子能够通过数组存储元素的检查，后续操作数组元素随时会出现ClassCastException。基于以上的原因，Java从编译层面直接拒绝创建参数化类型数组</strong>。</p>
<p>另外，类型变量数组的实例化也是非法的，如<code>T[] tt = new T[10];</code>，这是因为类型变量仅仅是编译期的字面量，其实和Java的类型体系是不相关的。</p>
<p>但是要注意一点：<strong>参数化类型数组和类型变量数组可以作为方法入参变量或者类的成员变量</strong>。例如下面的做法是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Pair&lt;T&gt;[] attr;</span><br><span class="line">	<span class="keyword">private</span> T[] ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Pair&lt;T&gt; pair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T[] ts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一点，可以查看前一篇文章，其实<strong>可以使用反射创建泛型数组</strong>。</p>
<h2 id="无限定通配符">无限定通配符</h2>
<p>泛型中支持无限定通配符<code>&lt;?&gt;</code>，使用无限定通配符类型的实例有以下限制：</p>
<ul>
<li>所有的Getter方法只能返回Object类型的值。</li>
<li>所有的Setter方法只能赋值null，其他类型的值的设置都是非法的。</li>
</ul>
<p>无限定通配符类型可以看做原始类型的一个影子类型，它屏蔽了除了null之外的设值操作，所有获取值的方法只能返回Object类型结果，这种特性使得通过无限定通配符类型进行一些简单的操作变得十分方便，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果反射用得比较熟的话，<code>java.lang.Class</code>也有类似的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = ...;</span><br><span class="line">Object instance = <span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="桥方法-Bridge-Method">桥方法(Bridge Method)</h2>
<p>先说明一下什么是桥方法，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Supper</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类<code>Supper&lt;T&gt;</code>在泛型擦除后原始类型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Object t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类<code>Sub</code>虽然实现了父类<code>Supper</code>，但是它只实现了<code>void method(Integer value)</code>而没有实现父类中的<code>void method(Object t)</code>，这个时候，编译期编译器会为子类<code>Sub</code>创建此方法，也就是子类<code>Sub</code>会变成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Supper</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.method((Integer) value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你直接这样编写一个子类<code>Sub</code>是会编译报错，而上面这里编译器生成的<code>void method(Object value)</code>方法就是桥方法。可以用反射验证一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Method[] declaredMethods = Sub<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethods</span>()</span>;</span><br><span class="line">	List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">		<span class="keyword">if</span> (method.getName().equals(<span class="string">"method"</span>)) &#123;</span><br><span class="line">			methods.add(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">		System.out.println(String.format(<span class="string">"name=%s,paramTypes=%s,isBridge=%s"</span>, method.getName(),</span><br><span class="line">		Arrays.toString(method.getParameterTypes()), method.isBridge()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">name=method,paramTypes=[class java.lang.Integer],isBridge=false</span><br><span class="line">name=method,paramTypes=[class java.lang.Object],isBridge=true</span><br></pre></td></tr></table></figure>
<p>桥方法的定义比较模糊，因此这里只考虑它出现的情况，不做盲目的定义。不单只是子类实现带有泛型参数的父类会产生桥方法，还有一种比较常见的情况是在方法覆盖的时候指定一个更加&quot;严格的&quot;返回值类型的时候，也会产生桥方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Employee implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里实际上，Employee覆盖了Object的clone()方法，因此实际上编译后Employee如下</span></span><br><span class="line"><span class="keyword">public</span> Employee implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是桥方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为：</p>
<ul>
<li>编译的时候Java的方法签名是方法名称加上方法参数类型列表，也就是方法名和参数类型列表确定一个方法的签名(这样就可以很好理解方法重载，还有Java中的参数都是形参，所以参数名称没有实质意义，只有参数类型才是有意义的)。</li>
<li>Java虚拟机定义一个方法的签名是由方法名称、方法返回值类型和方法参数类型列表组成，所以JVM认为返回值类型不同，而方法名称和参数类型列表一致的方法是不相同的方法。</li>
</ul>
<p>仔细看，其实两种情况都是由于继承才导致桥方法出现。</p>
<h2 id="JDK中操作泛型的API">JDK中操作泛型的API</h2>
<p>这里列举一下JDK中笔者所知的操作泛型的相关API(可以会有遗漏)，这些API主要和反射操作相关：</p>
<p><strong><code>java.lang.Class</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericInterfaces()</td>
<td style="text-align:center">返回类实例的接口的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericSuperclass()</td>
<td style="text-align:center">返回类实例的父类的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Constructor</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">返回构造器的异常的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回构造器的方法参数的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Method</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">返回方法的异常的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回方法参数的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericReturnType()</td>
<td style="text-align:center">返回方法返回值的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Field</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type getGenericType()</td>
<td style="text-align:center">返回属性的泛型类型</td>
</tr>
</tbody>
</table>
<p>如果在使用上面的方法得到的返回值和期望的返回值不相同，请加深对泛型类型擦除的认识。</p>
<h2 id="小结">小结</h2>
<p>参考资料：</p>
<p>个人认为，泛型其实是JDK迭代过程中妥协和兼容历史的产物，它是一种没有实现的泛型，当然，提供编译期类型安全这一点可以让开发者避免类型转换出现人为错误，也就是说：Java中的泛型使得程序或者代码的可读性和安全性提高，这是它的最大优势。</p>
<ul>
<li>《Java核心技术卷I-基础知识》</li>
<li><a href="https://en.wikipedia.org/wiki/Generics_in_Java" target="_blank" rel="noopener">维基百科-Generics in Java</a></li>
</ul>
<p>(本文完 e-20181204-c-3d r-20181205)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/02/java-reflection-array-enum/">
      深入分析Java反射(二)-数组和枚举
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月2日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：10分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-04T23:42:12+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月4日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(二)-数组和枚举</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射中可能用到的两个比较特殊的类型，数组和枚举，分别对应<code>java.lang.reflect.Array</code>和<code>java.lang.Enum</code>，后者其实并不是反射类库包中的类，但是反射的基础类库里面有使用枚举类型的方法。</p>
<h2 id="数组类型">数组类型</h2>
<p>数组是一种包含固定数量的相同类型组件(Component)的引用类型对象，也就是说数组的长度是不可变，它的每个元素都是相同类型的。创建数组实例需要定义数组的长度和组件的类型。<strong>数组是由Java虚拟机实现(这一点很重要，这就是为什么JDK类库中没有数组对应的类型的原因，array也不是Java中的保留关键字，操作数组的底层方法都是native方法)</strong>，数组类型只有继承自<code>java.lang.Object</code>的方法，数组的<code>length</code>方法实际上并不属于数组类型的一部分，数组的<code>length</code>方法其实最终调用的是<code>java.lang.reflect.Array#getLength()</code>，注意到这个方法是native方法。<code>java.lang.reflect.Array</code>是基于反射操作数组的核心类。</p>
<p>使用非反射方式创建数组实例的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fully_qualified_class_name[] variable_name  = &#123;val1，val2，val3，...&#125;;</span><br><span class="line"></span><br><span class="line">fully_qualified_class_name[] variable_name = <span class="keyword">new</span> fully_qualified_class_name[$&#123;fix_length&#125;];</span><br><span class="line"></span><br><span class="line">例如：<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>使用反射方式就是使用<code>java.lang.reflect.Array</code>中的相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">Object o = Array.newInstance(c, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    String v = cVals[i];</span><br><span class="line">    Constructor ctor = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Object val = ctor.newInstance(v);</span><br><span class="line">    Array.set(o, i, val);</span><br><span class="line">&#125;</span><br><span class="line">Object[] oo = (Object[]) o;</span><br></pre></td></tr></table></figure>
<p>下面列举一下<code>java.lang.reflect.Array</code>中的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static Object newInstance(Class&lt;?&gt; componentType, int length)</td>
<td style="text-align:center">指定组件类型和数组固定长度创建一维数组</td>
</tr>
<tr>
<td style="text-align:center">static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)</td>
<td style="text-align:center">指定组件类型和多个固定长度创建多维数组，维度的最大值为255</td>
</tr>
<tr>
<td style="text-align:center">static native int getLength(Object array)</td>
<td style="text-align:center">获取数组长度</td>
</tr>
<tr>
<td style="text-align:center">static native Object get(Object array, int index)</td>
<td style="text-align:center">通过下标访问数组元素</td>
</tr>
<tr>
<td style="text-align:center">static native void set(Object array, int index, Object value)</td>
<td style="text-align:center">通过下标设置数组元素</td>
</tr>
</tbody>
</table>
<p>这里省略了一部分对于<code>Int</code>、<code>Boolean</code>等原始类型的Setter和Getter方法。</p>
<p>在<code>java.lang.Class</code>和数组相关的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">native boolean isArray()</td>
<td style="text-align:center">判断类型是否数组类型</td>
</tr>
<tr>
<td style="text-align:center">Class&lt;?&gt; getComponentType()</td>
<td style="text-align:center">如果是数组类型则返回其组件类型，否则返回null</td>
</tr>
</tbody>
</table>
<p>这里举个例子加深下印象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCreationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这个是我们创建的最终目标数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String R = <span class="string">"java.math.BigInteger[] bi = &#123;123,234,345&#125;"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] S = <span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>, <span class="string">"234"</span>, <span class="string">"345"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;BigInteger&gt; componentType = BigInteger<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Object arrayObject = Array.newInstance(componentType, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">			String each = S[i];</span><br><span class="line">			Constructor&lt;BigInteger&gt; constructor = componentType.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			BigInteger value = constructor.newInstance(each);</span><br><span class="line">			Array.set(arrayObject, i, value);</span><br><span class="line">		&#125;</span><br><span class="line">		Object[] result = (Object[]) arrayObject;</span><br><span class="line">		System.out.println(String.format(<span class="string">"%s[] = %s"</span>, componentType, Arrays.toString(result)));</span><br><span class="line">		<span class="keyword">int</span> length = Array.getLength(arrayObject);</span><br><span class="line">		System.out.println(<span class="string">"Length = "</span> + length);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			System.out.println(String.format(<span class="string">"index = %d,value = %s"</span>, i, Array.get(arrayObject, i)));</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; arrayObjectClass = arrayObject.getClass();</span><br><span class="line">		System.out.println(<span class="string">"Is array type:"</span> + arrayObjectClass.isArray());</span><br><span class="line">		System.out.println(<span class="string">"Component type:"</span> + arrayObjectClass.getComponentType());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class java.math.BigInteger[] = [123, 234, 345]</span><br><span class="line">Length = <span class="number">3</span></span><br><span class="line">index = <span class="number">0</span>,value = <span class="number">123</span></span><br><span class="line">index = <span class="number">1</span>,value = <span class="number">234</span></span><br><span class="line">index = <span class="number">2</span>,value = <span class="number">345</span></span><br><span class="line">Is array type:<span class="keyword">true</span></span><br><span class="line">Component type:<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">math</span>.<span class="title">BigInteger</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>java.lang.reflect.Array</code>中的Setter和Getter方法如果越界操作数组元素，会抛出<code>ArrayIndexOutOfBoundsException</code>，通过Setter设置和数组初始化时候的组件类型不一致的元素会抛出<code>IllegalArgumentException</code>。</p>
<h3 id="细议数组类型">细议数组类型</h3>
<p>前面说到了数组类型的一些基础特性，这里补充一些比较高级的使用方法。</p>
<p><strong>创建特定元素类型的数组：</strong></p>
<p>因为Java泛型擦除的问题，实际上我们使用<code>Array#newInstance</code>方法只能得到一个Object类型的结果实例，其实这个结果实例的类型就是<code>ComponentType[]</code>，这里只是返回了它的父类(Object)类型实例，因此我们可以直接强转，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = (String[]) Array.newInstance(String<span class="class">.<span class="keyword">class</span>, 3)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>获取数组类型：</strong></p>
<p>在非反射方式下，我们可以通过<code>数组实例.class</code>通过class字面量直接获取数组类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = String[]<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
<p>反射条件下，可以通过<code>Class.forName()</code>获取数组类型，但是调用此方法的时候有个限制，类名必须使用JVM可以识别的签名形式，就是<code>[L${ComponentType};</code>，注意<code>Class.forName()</code>无法获取原始类型(如int、boolean)的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能漏了左边的[L和右边的;</span></span><br><span class="line">Class stringArrayClass = Class.forName(<span class="string">"[Ljava.lang.String;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这样做会抛出ClassNotFoundException</span></span><br><span class="line">Class intClass1 = Class.forName(<span class="string">"I"</span>);</span><br><span class="line">Class intClass2 = Class.forName(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>获取数组元素(组件)类型：</strong></p>
<p>目前获取数组组件类型只能通过数组类型实例去调用<code>Class#getComponentType()</code>。</p>
<h2 id="枚举类型">枚举类型</h2>
<p>枚举是一种语言结构(Language Construct)，用于定义可以使用一组固定的名值对表示的类型安全的枚举(原文是：An enum is a language construct that is used to define type-safe enumerations which can be used when a fixed set of named values is desired)。所有枚举都继承自<code>java.lang.Enum</code>。枚举可以包含一个或者多个枚举常量，这些枚举常量都是该枚举的实例。枚举的声明其实和一个普通的Class的声明相似，因为它可以包含字段、方法和构造函数之类的成员。</p>
<p>因为枚举就是普通的Java类，因此反射相关类库中并没有添加一个<code>java.lang.reflect.Enum</code>类型，反射中的API和枚举相关的有：</p>
<ul>
<li><code>boolean java.lang.Class#isEnum()</code>：判断类型是否枚举类型。</li>
<li><code>T[] java.lang.Class#getEnumConstants()</code>：获取类型中所有的枚举常量。</li>
<li><code>boolean java.lang.reflect.Field#isEnumConstant()</code>：判断属性是否枚举类型。</li>
</ul>
<p>如果实例中的成员属性为枚举，那么枚举的反射操作实际上就是<code>java.lang.reflect.Field</code>的相关操作。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> Color &#123;</span><br><span class="line">		RED, BLACK, BLUE</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Color color = Color.BLACK;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;Color&gt; colorClass = Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		System.out.println(<span class="string">"Color class is enum:"</span> + colorClass.isEnum());</span><br><span class="line">		System.out.println(<span class="string">"Color values:"</span> + Arrays.toString(colorClass.getEnumConstants()));</span><br><span class="line">		ColorHolder colorHolder = <span class="keyword">new</span> ColorHolder();</span><br><span class="line">		Class&lt;ColorHolder&gt; holderClass = ColorHolder<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Field field = holderClass.getDeclaredField(<span class="string">"color"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(<span class="string">"Old color:"</span> + field.get(colorHolder));</span><br><span class="line">		field.set(colorHolder, Color.RED);</span><br><span class="line">		System.out.println(<span class="string">"New color:"</span> + field.get(colorHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Color class is enum:true</span><br><span class="line">Color values:[RED, BLACK, BLUE]</span><br><span class="line">Old color:BLACK</span><br><span class="line">New color:RED</span><br></pre></td></tr></table></figure>
<p>之前写过一篇文章《JDK中枚举的底层实现》，从枚举类的字节码翻译出类的代码逻辑，这里翻出来那个例子(手机操作系统枚举)说一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PhoneOsEnum &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 安卓</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ANDROID(<span class="number">1</span>, <span class="string">"android"</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ios</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	IOS(<span class="number">2</span>, <span class="string">"ios"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer type;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line"></span><br><span class="line">	PhoneOsEnum(Integer type, String typeName) &#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> typeName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是我们使用Java的关于枚举的语法创建出来的枚举类型，是编译前我们看到的Java类文件，实际上，编译完成之后，枚举类型会变成一个普通的Java类，它有以下特点：</p>
<ul>
<li>1、枚举类型会变成一个普通Java类，这个Java类会继承<code>java.lang.Enum</code>，并且把自身类型作为泛型参数类型，构造函数中必定包含name(字符串类型String)、ordinal(整型int)参数，因为父类<code>java.lang.Enum</code>的构造要求传入这两个参数。</li>
<li>2、所有的枚举成员属性都变成<code>static final</code>修饰的在第1步中提到的Java类的实例，属性的名称和原来枚举的名字一致，实例在静态代码块中创建。</li>
<li>3、新增了一个<code>static final</code>修饰的第1步中提到的Java类的数组实例，名称为<code>$VALUES</code>，此数组在静态代码块中创建，基于此数组还新增了一个静态方法<code>values()</code>，此方法就是直接返回数组的克隆。</li>
</ul>
<p>也就是上面提到的<code>PhoneOsEnum</code>在编译完成之后会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneOsEnumeration</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">PhoneOsEnumeration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PhoneOsEnumeration</span><span class="params">(String name, <span class="keyword">int</span> ordinal, Integer type, String typeName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, ordinal);</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> PhoneOsEnumeration[] values() &#123;</span><br><span class="line">		<span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneOsEnumeration <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Enum.valueOf(PhoneOsEnumeration<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer type;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration ANDROID;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration IOS;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration[] $VALUES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		ANDROID = <span class="keyword">new</span> PhoneOsEnumeration(<span class="string">"ANDROID"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"android"</span>);</span><br><span class="line">		IOS = <span class="keyword">new</span> PhoneOsEnumeration(<span class="string">"IOS"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"ios"</span>);</span><br><span class="line">		$VALUES = <span class="keyword">new</span> PhoneOsEnumeration[]&#123;ANDROID, IOS&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，如果你直接编写一个Java类去继承<code>java.lang.Enum</code>会编译报错，也就是Java希望把枚举的行为和特性交由自身控制而不是开发者去控制，从编译层面控制枚举的类型安全。如果细心一点会发现，枚举中<code>valueOf(String name)</code>也是由<code>java.lang.Class</code>提供的，追溯到最里层是<code>T[] java.lang.Class#getEnumConstants()</code>方法，其实有可能在构造<code>$VALUES</code>属性的时候也是用到这个方法，这一点就没有深究下去，编译层面的东西可能会牵涉很多方面的知识，还没有到达那种水平。</p>
<h2 id="小结">小结</h2>
<p>数组和枚举在Java中的使用频率也是比较高的，特别是算法或者框架中，本文尝试从反射角度介绍这两个类型的使用方式，掌握它们对数组或者枚举的使用有很大的帮助。</p>
<p>(本文完 e-2018122-c-1-d r-2018124-c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/blog/tags/Java/page/3/">
            <section class="post prev white-box card-shadow " >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          4 / 5
        </p>
        
          <a class="next" rel="next" href="/blog/tags/Java/page/5/">
            <section class="post next white-box card-shadow ">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
