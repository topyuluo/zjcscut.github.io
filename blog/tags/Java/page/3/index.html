<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: Java | Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <div class="cover-wrapper">
    <cover class='cover  half'>
      
        
  <img class='logo' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/blog-logo.png'/>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <i class="icon fas fa-search fa-fw"></i>
      <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
    </form>
  </div>

<div class='menu navigation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home "
            href="/"
            
            
            id="home">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/projects/"
            
            
            id="projects">
            <i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/friends/"
            
              rel="nofollow"
            
            
            id="friends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home "
            href="/about/"
            
              rel="nofollow"
            
            
            id="about">
            <i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
          </a>
        </li>
      
    
  </ul>
</div>
<div style="text-align: center;margin-top: 5px;" id="rollingColorfulFont"></div>
      
    </cover>
    <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


  <div class="l_body">
    <div class='body-wrapper'>
      
<div class='l_main'>
  
    
      
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/04/30/java-object-wait-notify/">
      深入理解Object提供的阻塞和唤醒API
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年4月30日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Concurrency/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Concurrency</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：5.2k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：22分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-05-01T17:27:19+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年5月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入理解Object提供的阻塞和唤醒API</h1>
<h2 id="前提">前提</h2>
<p>前段时间花了大量时间去研读JUC中同步器<code>AbstractQueuedSynchronizer</code>的源码实现，再结合很久之前看过的一篇关于<code>Object</code>提供的等待和唤醒机制的JVM实现，发现两者有不少的关联，于是决定重新研读一下<code>Object</code>中提供的阻塞和唤醒方法。本文阅读JDK类库源码使用的JDK版本是JDK11，因为本文内容可能不适合于其他版本。</p>
<h2 id="Object提供的阻塞和唤醒API">Object提供的阻塞和唤醒API</h2>
<p><code>java.lang.Object</code>作为所有非基本类型的基类，也就是说所有<code>java.lang.Object</code>的子类都具备阻塞和唤醒的功能。下面详细分析<code>Object</code>提供的阻塞和唤醒API。</p>
<h3 id="阻塞等待-wait">阻塞等待-wait</h3>
<p>等待-<code>wait()</code>方法提供了阻塞的功能，分超时和永久阻塞的版本，实际上，底层只提供了一个JNI方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个是底层提供的JNI方法，带超时的阻塞等待，响应中断，其他两个只是变体</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变体方法1，永久阻塞，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变体方法2，带超时的阻塞，超时时间分两段：毫秒和纳秒，实际上纳秒大于0直接毫秒加1(这么暴力...)，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeoutMillis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeoutMillis value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeoutMillis++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是只有一个<code>wait(long timeoutMillis)</code>方法是JNI接口，其他两个方法相当于：</p>
<ul>
<li><code>wait()</code>等价于<code>wait(0L)</code>。</li>
<li><code>wait(long timeoutMillis, int nanos)</code>在参数合法的情况下等价于<code>wait(timeoutMillis + 1L)</code>。</li>
</ul>
<p>由于<code>wait(long timeoutMillis, int nanos)</code>是参数最完整的方法，它的API注释特别长，这里直接翻译和摘取它注释中的核心要素：</p>
<ol>
<li>当前线程阻塞等待直到被唤醒，唤醒的情况一般有三种：notify(All)被调用、线程被中断或者在指定了超时阻塞的情况下超过了指定的阻塞时间。</li>
<li>当前线程必须获取此对象的监视器锁(<strong>monitor lock</strong>)，也就是<strong>调用阻塞等待方法之前一个线程必须成为此对象的监视器锁的拥有者</strong>。</li>
<li>调用了<code>wait()</code>方法之后，当前线程会把自身放到当前对象的等待集合(wait-set)，然后释放所有在此对象上的同步声明(then to relinquish any nd all synchronization claims on this object)，谨记只有当前对象上的同步声明会被释放，当前线程在其他对象上的同步锁只有在调用其<code>wait()</code>方法之后才会释放。</li>
<li><strong>Warning</strong>：线程被唤醒之后(<code>notify()</code>或者中断)就会从等待集合(wait-set)中移除并且重新允许被线程调度器调度。通常情况下，这个被唤醒的线程会与其他线程竞争对象上的同步权(锁)，一旦线程重新<strong>控制了对象(regained control of the object)</strong>，它对对象的所有同步声明都恢复到以前的状态，即恢复到调用<code>wait()</code>方法时(笔者认为，其实准确来说，是调用<code>wait()</code>方法前)的状态。</li>
<li>如果任意线程在它调用了<code>wait()</code>之前，或者调用过<code>wait()</code>方法之后处于阻塞等待状态，一旦线程调用了<code>Thread#interrupt()</code>，线程就会中断并且抛出<code>InterruptedException</code>异常，线程的中断状态会被清除。<code>InterruptedException</code>异常会延迟到在第4点提到&quot;它对对象的所有同步声明都恢复到以前的状态&quot;的时候抛出。</li>
</ol>
<p>值得注意的还有：</p>
<p><strong>一个线程必须成为此对象的监视器锁的拥有者才能正常调用<code>wait()</code>系列方法，也就是<code>wait()</code>系列方法必须在同步代码块(<code>synchronized</code>代码块)中调用，否则会抛出<code>IllegalMonitorStateException</code>异常</strong>，这一点是初学者或者不了解<code>wait()</code>的机制的开发者经常会犯的问题。</p>
<p>上面的五点描述可以写个简单的同步代码块伪代码时序总结一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="number">1</span>、线程进入同步代码块，意味着获取对象监视器锁成功</span><br><span class="line">    <span class="keyword">while</span>(!condition)&#123;</span><br><span class="line">        lock.wait();   <span class="number">2</span>.线程调用wait()进行阻塞等待</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">3</span>.线程从wait()的阻塞等待中被唤醒，恢复到第<span class="number">1</span>步之后的同步状态</span><br><span class="line">    <span class="number">4</span>.继续执行后面的代码，直到离开同步代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="唤醒-notify">唤醒-notify</h3>
<p><code>notify()</code>方法的方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面按照惯例翻译一下其API注释：</p>
<ol>
<li>唤醒一个阻塞等待在此对象监视器上的线程，(如果存在多个阻塞线程)至于选择哪一个线程进行唤醒是任意的，取决于具体的现实，一个线程通过调用<code>wait()</code>方法才能阻塞在对象监视器上。</li>
<li>被唤醒的线程并不会马上继续执行，直到当前线程(也就是当前调用了<code>notify()</code>方法的线程)释放对象上的锁。被唤醒的线程会与其他线程竞争在对象上进行同步(换言之只有获得对象的同步控制权才能继续执行)，在成为下一个锁定此对象的线程时，被唤醒的线程没有可靠的特权或劣势。</li>
<li>此方法只有在一个线程获取了此对象监视器的所有权(the owner)的时候才能调用，具体就是：同步方法中、同步代码块中或者静态同步方法中。否则，会抛出<code>IllegalMonitorStateException</code>异常。</li>
</ol>
<h3 id="唤醒所有-notifyAll">唤醒所有-notifyAll</h3>
<p><code>notifyAll()</code>方法的方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>唤醒所有阻塞等待在此对象监视器上的线程，一个线程通过调用<code>wait()</code>方法才能阻塞在对象监视器上。</li>
</ol>
<p>其他注释的描述和<code>notify()</code>方法类似。</p>
<h3 id="小结">小结</h3>
<p>我们经常看到的资料中提到<code>synchronized</code>关键字的用法：</p>
<ul>
<li>普通同步方法，同步或者说锁定的是当前实例对象。</li>
<li>静态同步方法，同步或者说锁定的是当前实例对象的<code>Class</code>对象。</li>
<li>同步代码块，同步或者说锁定的是括号里面的实例对象。</li>
</ul>
<p>对于同步代码块而言，<code>synchronized</code>关键字抽象到字节码层面就是同步代码块中的字节码执行在<code>monitorenter</code>和<code>monitorexit</code>指令之间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(xxxx)&#123;</span><br><span class="line"></span><br><span class="line">    ...coding block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">↓↓↓↓↓↓↓↓↓↓</span><br><span class="line"></span><br><span class="line">monitorenter;</span><br><span class="line">...coding block - bytecode</span><br><span class="line">monitorexit;</span><br></pre></td></tr></table></figure>
<p>JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor(实际上是<code>ObjectMonitor</code>)与之相关联，当且一个monitor被持有之后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。</p>
<p>对于同步(静态)方法而言，<code>synchronized</code>方法则会被翻译成普通的方法调用和返回指令，如：<code>invokevirtual</code>等等，在JVM字节码层面并没有任何特别的指令来实现被<code>synchronized</code>修饰的方法，而是在<code>Class</code>文件的方法表中将该方法的<code>access_flags</code>字段中的<code>synchronized</code>标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的<code>Class</code>在JVM的内部对象表示<code>Klass</code>做为锁对象。</p>
<p>其实从开发者角度简单理解，<strong>这两种方式只是在获取锁的时机有所不同</strong>。</p>
<p>下面重复阐述<strong>几个第一眼看起来不合理却是事实的问题</strong>(其实前文已经提及过)：</p>
<ol>
<li>在线程进入<code>synchronized</code>方法或者代码块，相当于获取监视器锁成功，如果此时成功调用<code>wait()</code>系列方法，那么它会立即释放监视器锁，并且添加到等待集合(Wait Set)中进行阻塞等待。</li>
<li>由于已经有线程释放了监视器锁，那么在另一个线程进入<code>synchronized</code>方法或者代码块之后，它可以调用<code>notify(All)</code>方法唤醒等待集合中正在阻塞的线程，但是这个唤醒操作并不是调用<code>notify(All)</code>方法后立即生效，而是在该线程退出<code>synchronized</code>方法或者代码块之后才生效。</li>
<li>从<code>wait()</code>方法阻塞过程中被唤醒的线程会竞争监视器目标对象的控制权，一旦重新控制了对象，那么线程的同步状态就会恢复到步入<code>synchronized</code>方法或者代码块时候的状态(也就是成功获取到对象监视器锁时候的状态)，这个时候线程才能够继续执行。</li>
</ol>
<p>为了验证这三点，可以写个简单的Demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter F = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span>  WaitRunnable(lock), <span class="string">"WaitThread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span>  WaitRunnable(lock), <span class="string">"WaitThread-2"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span>  NotifyRunnable(lock), <span class="string">"NotifyThread"</span>).start();</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiredArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-线程[%s]获取锁成功,准备执行wait方法"</span>, F.format(LocalDateTime.now()),</span><br><span class="line">                        Thread.currentThread().getName()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(String.format(<span class="string">"[%s]-线程[%s]从wait中唤醒,准备exit"</span>, F.format(LocalDateTime.now()),</span><br><span class="line">                            Thread.currentThread().getName()));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">//ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiredArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-线程[%s]获取锁成功,准备执行notifyAll方法"</span>, F.format(LocalDateTime.now()),</span><br><span class="line">                        Thread.currentThread().getName()));</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-线程[%s]先休眠3000ms"</span>, F.format(LocalDateTime.now()),</span><br><span class="line">                        Thread.currentThread().getName()));</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-线程[%s]准备exit"</span>, F.format(LocalDateTime.now()),</span><br><span class="line">                        Thread.currentThread().getName()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某个时刻的执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">17.617</span>]-线程[WaitThread-<span class="number">1</span>]获取锁成功,准备执行wait方法</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">17.631</span>]-线程[WaitThread-<span class="number">2</span>]获取锁成功,准备执行wait方法</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">17.657</span>]-线程[NotifyThread]获取锁成功,准备执行notifyAll方法 &lt;-------- 这一步执行完说明WaitThread已经释放了锁</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">17.657</span>]-线程[NotifyThread]先休眠<span class="number">3000</span>ms</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">20.658</span>]-线程[NotifyThread]准备exit &lt;------- 这一步后NotifyThread离开同步代码块</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">20.658</span>]-线程[WaitThread-<span class="number">1</span>]从wait中唤醒,准备exit &lt;------- 这一步WaitThread-<span class="number">1</span>解除阻塞</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">27</span> <span class="number">23</span>:<span class="number">28</span>:<span class="number">21.160</span>]-线程[WaitThread-<span class="number">2</span>]从wait中唤醒,准备exit &lt;------- 这一步WaitThread-<span class="number">2</span>解除阻塞，注意发生时间在WaitThread-<span class="number">1</span>解除阻塞<span class="number">500</span>ms之后，符合我们前面提到的第<span class="number">3</span>点</span><br></pre></td></tr></table></figure>
<p>如果结合<code>wait()</code>和<code>notify()</code>可以简单总结出一个同步代码块的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="number">1</span>、线程进入同步代码块，意味着获取对象监视器锁成功</span><br><span class="line">    <span class="keyword">while</span>(!condition)&#123;</span><br><span class="line">        lock.wait();   <span class="number">2</span>.线程调用wait()进行阻塞等待</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">3</span>.线程从wait()的阻塞等待中被唤醒，尝试恢复第<span class="number">1</span>步之后的同步状态，并不会马上生效，直到notify被调用并且调用notify方法的线程已经释放锁，同时当前线程需要竞争成功</span><br><span class="line">    <span class="number">4</span>.继续执行后面的代码，直到离开同步代码块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="number">1</span>、线程进入同步代码块，意味着获取对象监视器锁成功</span><br><span class="line">    lock.notify();  <span class="number">2</span>.唤醒其中一个在对象监视器上等待的线程</span><br><span class="line">    <span class="number">3</span>.准备推出同步代码块释放锁，只有释放锁之后第<span class="number">2</span>步才会生效</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图解Object提供的阻塞和唤醒机制">图解Object提供的阻塞和唤醒机制</h2>
<p>结合前面分析过的知识点以及参考资料中的文章，重新画一个图理解一下对象监视器以及相应阻塞和唤醒API的工作示意过程：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201904/j-u-c-o-w-n-1.png" alt="j-u-c-o-w-n-1.png"></p>
<ul>
<li>Entry Set(实际上是<code>ObjectMonitor</code>中的_EntryList属性)：存放等待锁并且处于阻塞状态的线程。</li>
<li>Wait Set(实际上是<code>ObjectMonitor</code>中的_WaitSet属性)：存放处于等待阻塞状态的线程。</li>
<li>The Owner(实际上是<code>ObjectMonitor</code>中的_owner属性)：指向获得对象监视器的线程，在同一个时刻只能有一个线程被The Owner持有，通俗来看，它就是监视器的控制权。</li>
</ul>
<h2 id="使用例子">使用例子</h2>
<p>通过<code>Object</code>提供的阻塞和唤醒机制举几个简单的使用例子。</p>
<h3 id="维修厕所的例子">维修厕所的例子</h3>
<p>假设有以下场景：厕所只有一个卡位，厕所维修工修厕所的时候，任何人不能上厕所。当厕所维修工修完厕所的时候，上厕所的人需要&quot;得到厕所的控制权&quot;才能上厕所。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 厕所类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Toilet</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 厕所的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> available;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAvailable</span><span class="params">(<span class="keyword">boolean</span> available)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.available = available;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> available;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厕所维修工</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToiletRepairer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter F = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Toilet toilet;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toilet.getLock()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"[%s]-厕所维修员得到了厕所的锁,维修厕所要用5000ms..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            toilet.setAvailable(<span class="keyword">true</span>);</span><br><span class="line">            toilet.getLock().notifyAll();</span><br><span class="line">            System.out.println(String.format(<span class="string">"[%s]-厕所维修员维修完毕..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上厕所的任务</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToiletTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter F = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Toilet toilet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toilet.getLock()) &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"[%s]-%s得到了厕所的锁..."</span>, LocalDateTime.now().format(F), name));</span><br><span class="line">            <span class="keyword">while</span> (!toilet.getAvailable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    toilet.getLock().wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> time = random.nextInt(<span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟上厕所用时</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(time);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-%s上厕所用了%s秒..."</span>, LocalDateTime.now().format(F), name, time));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景入口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Toilet toilet = <span class="keyword">new</span> Toilet();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        Thread toiletRepairer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ToiletRepairer(toilet), <span class="string">"ToiletRepairer"</span>);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ToiletTask(toilet, <span class="string">"张三"</span>, random), <span class="string">"thread-1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ToiletTask(toilet, <span class="string">"李四"</span>, random), <span class="string">"thread-2"</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ToiletTask(toilet, <span class="string">"王五"</span>, random), <span class="string">"thread-3"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        toiletRepairer.start();</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某次执行的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">25.914</span>]-张三得到了厕所的锁...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">25.931</span>]-李四得到了厕所的锁...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">25.931</span>]-王五得到了厕所的锁...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">25.951</span>]-厕所维修员得到了厕所的锁,维修厕所要用<span class="number">5000</span>ms...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">30.951</span>]-厕所维修员维修完毕...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">32.952</span>]-张三上厕所用了<span class="number">2</span>秒...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">35.952</span>]-王五上厕所用了<span class="number">3</span>秒...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">07</span>:<span class="number">37.953</span>]-李四上厕所用了<span class="number">2</span>秒...</span><br></pre></td></tr></table></figure>
<h3 id="阻塞队列实现">阻塞队列实现</h3>
<p>实现一个简单固定容量的阻塞队列，接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T value)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>put(T value)</code>会阻塞直到队列中有可用的容量，而<code>take()</code>方法会阻塞直到有元素投放到队列中。实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlockingQueue</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object notEmpty = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object notFull = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> takeIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T value)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (notFull) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == elements.length) &#123;</span><br><span class="line">                notFull.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.elements;</span><br><span class="line">        items[putIndex] = value;</span><br><span class="line">        <span class="keyword">if</span> (++putIndex == items.length) &#123;</span><br><span class="line">            putIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">synchronized</span> (notEmpty) &#123;</span><br><span class="line">            notEmpty.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (notEmpty) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.elements;</span><br><span class="line">        T value = (T) items[takeIndex];</span><br><span class="line">        items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (++takeIndex == items.length) &#123;</span><br><span class="line">            takeIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">synchronized</span> (notFull) &#123;</span><br><span class="line">            notFull.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景入口类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> DefaultBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String take = queue.take();</span><br><span class="line">                    System.out.println(String.format(<span class="string">"线程%s消费消息-%s"</span>, Thread.currentThread().getName(), take));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"thread-1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r, <span class="string">"thread-2"</span>).start();</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(String.valueOf(i));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某次执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程thread-<span class="number">1</span>消费消息-<span class="number">0</span></span><br><span class="line">线程thread-<span class="number">2</span>消费消息-<span class="number">1</span></span><br><span class="line">线程thread-<span class="number">1</span>消费消息-<span class="number">2</span></span><br><span class="line">线程thread-<span class="number">2</span>消费消息-<span class="number">3</span></span><br><span class="line">线程thread-<span class="number">1</span>消费消息-<span class="number">4</span></span><br><span class="line">线程thread-<span class="number">2</span>消费消息-<span class="number">5</span></span><br><span class="line">线程thread-<span class="number">1</span>消费消息-<span class="number">6</span></span><br><span class="line">线程thread-<span class="number">2</span>消费消息-<span class="number">7</span></span><br><span class="line">线程thread-<span class="number">1</span>消费消息-<span class="number">8</span></span><br><span class="line">线程thread-<span class="number">2</span>消费消息-<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子就是简单的单生产者-多消费者的模型。</p>
<h3 id="线程池实现">线程池实现</h3>
<p>这里实现一个极度简陋的固定容量的线程池，功能是：初始化固定数量的活跃线程，阻塞直到有可用的线程用于提交任务。它只有一个接口方法，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Worker&gt; initWorkers;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Worker&gt; availableWorkers;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Worker&gt; busyWorkers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object nextLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadPool</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        init(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        initWorkers = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">        availableWorkers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        busyWorkers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">            worker.setName(<span class="string">"Worker-"</span> + (i + <span class="number">1</span>));</span><br><span class="line">            worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            initWorkers.add(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : initWorkers) &#123;</span><br><span class="line">            w.start();</span><br><span class="line">            availableWorkers.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == runnable) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (nextLock) &#123;</span><br><span class="line">            <span class="keyword">while</span> (availableWorkers.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nextLock.wait(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Worker worker = availableWorkers.removeFirst();</span><br><span class="line">            busyWorkers.add(worker);</span><br><span class="line">            worker.run(runnable);</span><br><span class="line">            nextLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeAvailable</span><span class="params">(Worker worker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (nextLock) &#123;</span><br><span class="line">            availableWorkers.add(worker);</span><br><span class="line">            busyWorkers.remove(worker);</span><br><span class="line">            nextLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">        <span class="keyword">private</span> AtomicBoolean run = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != <span class="keyword">this</span>.runnable) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already running a Runnable!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (run.get()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (runnable == <span class="keyword">null</span> &amp;&amp; run.get()) &#123;</span><br><span class="line">                            lock.wait(<span class="number">500</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            ran = <span class="keyword">true</span>;</span><br><span class="line">                            runnable.run();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        runnable = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ran) &#123;</span><br><span class="line">                        ran = <span class="keyword">false</span>;</span><br><span class="line">                        makeAvailable(<span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景类入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter F = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ThreadPool threadPool = <span class="keyword">new</span> DefaultThreadPool(<span class="number">2</span>);</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-任务一开始执行持续3秒..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-任务一执行结束..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-任务二开始执行持续4秒..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-任务二执行结束..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-任务三开始执行持续5秒..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.out.println(String.format(<span class="string">"[%s]-任务三执行结束..."</span>, LocalDateTime.now().format(F)));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某次执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">02</span>:<span class="number">07</span>:<span class="number">25.465</span>]-任务二开始执行持续<span class="number">4</span>秒...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">02</span>:<span class="number">07</span>:<span class="number">25.465</span>]-任务一开始执行持续<span class="number">3</span>秒...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">02</span>:<span class="number">07</span>:<span class="number">28.486</span>]-任务一执行结束...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">02</span>:<span class="number">07</span>:<span class="number">28.486</span>]-任务三开始执行持续<span class="number">5</span>秒...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">02</span>:<span class="number">07</span>:<span class="number">29.486</span>]-任务二执行结束...</span><br><span class="line">[<span class="number">2019</span>-<span class="number">04</span>-<span class="number">29</span> <span class="number">02</span>:<span class="number">07</span>:<span class="number">33.487</span>]-任务三执行结束...</span><br></pre></td></tr></table></figure>
<h2 id="小结-2">小结</h2>
<p>鉴于笔者C语言学得不好，这里就无法深入分析JVM源码的实现，只能结合一些现有的资料和自己的理解重新梳理一下<code>Object</code>提供的阻塞和唤醒机制这些知识点。结合之前看过JUC同步器的源码，一时醒悟过来，JUC同步器只是在数据结构和算法层面使用Java语言对原来JVM中C语言的阻塞和唤醒机制即<code>Object</code>提供的那几个JNI方法进行了一次实现而已。</p>
<p>最后，<code>Object</code>提供的阻塞等待唤醒机制是JVM实现的(如果特别熟悉C语言可以通过JVM源码研究其实现，对于大部分开发者来说是黑箱)，除非是特别熟练或者是JDK版本太低尚未引入JUC包，一般情况下不应该优先选择<code>Object</code>，而应该考虑专门为并发设计的JUC包中的类库。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.jianshu.com/p/f4454164c017" target="_blank" rel="noopener">JVM源码分析之Object.wait/notify实现-By占小狼</a></li>
<li><a href="http://cmsblogs.com/?p=2071" target="_blank" rel="noopener">死磕Java并发-深入分析synchronized的实现原理</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 c-7-d e-a-20190430)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Object/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Object</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/04/07/java-juc-aqs-source-code/">
      JUC同步器框架AbstractQueuedSynchronizer源码图文分析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年4月7日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Concurrency/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Concurrency</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：14.2k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：58分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-09T11:54:33+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年6月9日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201905/j-a-q-s-9.png" alt=""></p>
<h2 id="前提">前提</h2>
<p>Doug Lea大神在编写JUC(<code>java.util.concurrent</code>)包的时候引入了<code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code>，Abstract Queued Synchronizer，也就是&quot;基于队列实现的抽象同步器&quot;，一般我们称之为AQS。其实Doug Lea大神编写AQS是有严谨的理论基础的，他的个人博客上有一篇论文《<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">The java.util.concurrent Synchronizer Framework</a>》，文章在<a href="http://ifeve.com" target="_blank" rel="noopener">http://ifeve.com</a>上可以找到相关的译文(《JUC同步器框架》)，如果想要深入研究AQS必须要理解一下该论文的内容，然后详细分析一下AQS的源码实现。本文在阅读AQS源码的时候选用的JDK版本是JDK11。</p>
<h2 id="AQS的主要功能">AQS的主要功能</h2>
<p>AQS是JUC包中用于构建锁或者其他同步组件(信号量、事件等)的基础框架类。AQS从它的实现上看主要提供了下面的功能：</p>
<ul>
<li>同步状态的原子性管理。</li>
<li>线程的阻塞和解除阻塞。</li>
<li>提供阻塞线程的存储队列。</li>
</ul>
<p>基于这三大功能，衍生出下面的附加功能：</p>
<ul>
<li>通过中断实现的任务取消，基于线程中断实现。</li>
<li>可选的超时设置，也就是调用者可以选择放弃等待。</li>
<li>定义了<code>Condition接口</code>，用于支持管程形式的await/signal/signalAll操作，代替了<code>Object</code>类基于JNI提供的wait/notify/notifyAll。</li>
</ul>
<p><code>AQS</code>还根据同步状态的不同管理方式区分为两种不同的实现：<strong>独占状态的同步器</strong>和<strong>共享状态的同步器</strong>。</p>
      
        
          <div class="button readmore">
            <a href="/2019/04/07/java-juc-aqs-source-code/" class="flat-box">
              <i class="fas fa-book-open fa-fw" aria-hidden="true"></i>
              阅读全文
            </a>
          </div>
        
      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/AQS/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> AQS</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/17/java-concurrency-threadlocal-source-code/">
      ThreadLocal源码分析-黄金分割数的使用
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月17日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Concurrency/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Concurrency</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：27分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-06-23T23:25:45+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年6月23日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/g-t-2.png" alt=""></p>
<h2 id="前提">前提</h2>
<p>最近接触到的一个项目要兼容新老系统，最终采用了<code>ThreadLocal</code>(实际上用的是<code>InheritableThreadLocal</code>)用于在子线程获取父线程中共享的变量。问题是解决了，但是后来发现对<code>ThreadLocal</code>的理解不够深入，于是顺便把它的源码阅读理解了一遍。在谈到<code>ThreadLocal</code>之前先买个关子，先谈谈黄金分割数。本文在阅读<code>ThreadLocal</code>源码的时候是使用JDK8(1.8.0_181)。</p>
      
        
          <div class="button readmore">
            <a href="/2019/02/17/java-concurrency-threadlocal-source-code/" class="flat-box">
              <i class="fas fa-book-open fa-fw" aria-hidden="true"></i>
              阅读全文
            </a>
          </div>
        
      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/ThreadLocal/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> ThreadLocal</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/16/java-security-cipher/">
      JDK安全模块JCE核心Cipher使用详解
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：33分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-02-16T23:05:55+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年2月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JDK安全模块JCE核心Cipher使用详解</h1>
<h2 id="前提">前提</h2>
<p><code>javax.crypto.Cipher</code>，翻译为密码，其实叫做<strong>密码器</strong>更加合适。Cipher是JCA(Java Cryptographic Extension，Java加密扩展)的核心，提供基于多种加解密算法的加解密功能。在不了解Cipher之前，我们在完成一些需要加解密的模块的时候总是需要到处拷贝代码，甚至有些错误的用法也被无数次拷贝，踩坑之后又要拷贝补坑的代码。为什么不尝试理解Cipher然后合理地使用呢？</p>
<h2 id="Cipher初始化transformation-转换模式-的一些知识补充">Cipher初始化transformation(转换模式)的一些知识补充</h2>
<p>转换模式transformation一般由三个部分组成，格式是：<strong>算法/工作模式/填充模式(algorithm/mode/padding)</strong>。例如：DES/CBC/PKCS5Padding。</p>
<h3 id="算法">算法</h3>
<p>算法就是指具体加解密算法的名称英文字符串，例如&quot;SHA-256&quot;、&quot;RSA&quot;等，这里不对具体算法的实现原理做具体展开。</p>
<h3 id="工作模式">工作模式</h3>
<p>工作模式其实主要是针对分组密码。分组密码是将明文消息编码表示后的数字（简称明文数字）序列，划分成长度为n的组（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列。工作模式的出现主要基于下面原因：</p>
<ul>
<li>当需要加密的明文长度十分大(例如文件内容)，由于硬件或者性能原因需要分组加密。</li>
<li>多次使用相同的密钥对多个分组加密，会引发许多安全问题。</li>
</ul>
<p>从本质上讲，工作模式是一项增强密码算法或者使算法适应具体应用的技术，例如将分组密码应用于数据块组成的序列或者数据流。目前主要包括下面五种由NIST定义的工作模式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">电子密码本(ECB)</td>
<td style="text-align:center">Electronic CodeBook</td>
<td style="text-align:center">用相同的密钥分别对明文分组独立加密</td>
<td style="text-align:center">单个数据的安全传输(例如一个加密密钥)</td>
</tr>
<tr>
<td style="text-align:center">密码分组链接(CBC)</td>
<td style="text-align:center">Cipher Block Chaining</td>
<td style="text-align:center">加密算法的输入是上一个密文组合下一个明文组的异或</td>
<td style="text-align:center">面向分组的通用传输或者认证</td>
</tr>
<tr>
<td style="text-align:center">密文反馈(CFB)</td>
<td style="text-align:center">Cipher FeedBack</td>
<td style="text-align:center">一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一单元的密文</td>
<td style="text-align:center">面向分组的通用传输或者认证</td>
</tr>
<tr>
<td style="text-align:center">输出反馈(OFB)</td>
<td style="text-align:center">Output FeedBack</td>
<td style="text-align:center">与CFB类似，只是加密算法的输入是上一次加密的输出，并且使用整个分组</td>
<td style="text-align:center">噪声信道上的数据流的传输(如卫星通信)</td>
</tr>
<tr>
<td style="text-align:center">计数器(CTR)</td>
<td style="text-align:center">Counter</td>
<td style="text-align:center">每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增</td>
<td style="text-align:center">面向分组的通用传输或者用于高速需求</td>
</tr>
</tbody>
</table>
<p>上面五种工作模式可以用于3DES和AES在内的任何分组密码，至于选择哪一种工作模式需要结合实际情况分析。</p>
<h3 id="填充模式">填充模式</h3>
<p>Padding指的是：块加密算法要求原文数据长度为固定块大小的整数倍，如果原文数据长度大于固定块大小，则需要在固定块填充数据直到整个块的数据是完整的。例如我们约定块的长度为128，但是需要加密的原文长度为129，那么需要分成两个加密块，第二个加密块需要填充127长度的数据，填充模式决定怎么填充数据。</p>
<p>对数据在加密时进行填充、解密时去除填充则是通信双方需要重点考虑的因素。对原文进行填充，主要基于以下原因：</p>
<ul>
<li>首先，考虑安全性。由于对原始数据进行了填充，使原文能够“伪装”在填充后的数据中，使得攻击者很难找到真正的原文位置。</li>
<li>其次，由于块加密算法要求原文数据长度为固定块大小的整数倍，如果加密原文不满足这个条件，则需要在加密前填充原文数据至固定块大小的整数倍。</li>
<li>另外，填充也为发送方与接收方提供了一种标准的形式以约束加密原文的大小。只有加解密双方知道填充方式，才可知道如何准确移去填充的数据并进行解密。</li>
</ul>
<p>常用的填充方式至少有5种，不同编程语言实现加解密时用到的填充多数来自于这些方式或它们的变种方式。以下五种填充模式摘抄自参考资料的论文：</p>
<p><strong>1.填充数据为填充字节序列的长度</strong>：</p>
<p>这种填充方式中，填充字符串由一个字节序列组成，每个字节填充该字节序列的长度。假定块长度为8，原文数据长度为9，则填充字节数 等于0x07；如果明文数据长度为8的整数倍，则填充字节数为0x08。填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</li>
<li>==========================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 08 08 08 08 08 08 08 08</li>
</ul>
<p><strong>2.填充数据为0x80后加0x00</strong>：</p>
<p>这种填充方式中，填充字符串的第一个字节数是0x80，后面的每个字节是0x00。假定块长度为8，原文数据长度为9或者为8的整数倍，则 填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00</li>
<li>==========================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00 00</li>
</ul>
<p><strong>3.填充数据的最后一个字节为填充字节序列的长度</strong>：</p>
<p>这种填充方式中，填充字符串的最后一个字节为该序列的长度，而前面的字节可以是0x00，也可以是随机的字节序列。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：</p>
<ul>
<li>原文数据1:FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07或FF FF FF FF FF FF FF FF FF 0A B0 0C 08 05 09 07</li>
<li>===============================================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 08或FF FF FF FF FF FF FF FF 80 06 AB EA 03 02 01 08</li>
</ul>
<p><strong>4.填充数据为空格</strong>：</p>
<p>这种填充方式中，填充字符串的每个字节为空格对应的字节数0x20。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20</li>
<li>===============================================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20 20</li>
</ul>
<p><strong>5.填充数据为0x00</strong>：</p>
<p>这种填充方式中，填充字符串的每个字节为0x00。假定块长度为8，原文数据长度为9或者8的整数倍，则填充字符串如下：</p>
<ul>
<li>原文数据1: FF FF FF FF FF FF FF FF FF</li>
<li>填充后数据1:FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00</li>
<li>===============================================================================</li>
<li>原文数据2:FF FF FF FF FF FF FF FF</li>
<li>填充后数据2:FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00</li>
</ul>
<h2 id="transformation小结">transformation小结</h2>
<p>SunJCE Provider支持的Cipher的部分详细信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">algorithm(算法)</th>
<th style="text-align:center">mode(工作模式)</th>
<th style="text-align:center">padding(填充模式)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AES</td>
<td style="text-align:center">EBC、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128等</td>
<td style="text-align:center">NoPadding、ISO10126Padding、PKCS5Padding</td>
</tr>
<tr>
<td style="text-align:center">AESWrap</td>
<td style="text-align:center">EBC</td>
<td style="text-align:center">NoPadding</td>
</tr>
<tr>
<td style="text-align:center">ARCFOUR</td>
<td style="text-align:center">EBC</td>
<td style="text-align:center">NoPadding</td>
</tr>
<tr>
<td style="text-align:center">Blowfish、DES、DESede、RC2</td>
<td style="text-align:center">EBC、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128等</td>
<td style="text-align:center">NoPadding、ISO10126Padding、PKCS5Padding</td>
</tr>
<tr>
<td style="text-align:center">DESedeWrap</td>
<td style="text-align:center">CBC</td>
<td style="text-align:center">NoPadding</td>
</tr>
<tr>
<td style="text-align:center">PBEWithMD5AndDES、PBEWithMD5AndTripleDES、PBEWithSHA1AndDESede、PBEWithSHA1AndRC2_40</td>
<td style="text-align:center">CBC</td>
<td style="text-align:center">PKCS5Padding</td>
</tr>
<tr>
<td style="text-align:center">RSA</td>
<td style="text-align:center">ECB、NONE</td>
<td style="text-align:center">NoPadding、PKCS1Padding等</td>
</tr>
</tbody>
</table>
<p>Java原生支持的Padding(Cipher)汇总如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">填充模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NoPadding</td>
<td style="text-align:center">不采用填充模式</td>
</tr>
<tr>
<td style="text-align:center">ISO10126Padding</td>
<td style="text-align:center">XML加密语法和处理文档中有详细描述</td>
</tr>
<tr>
<td style="text-align:center">OAEPPadding, OAEPWith&lt;digest&gt;And&lt;mgf&gt;Padding</td>
<td style="text-align:center">PKCS1中定义的最优非对称加密填充方案，digest代表消息摘要类型，mgf代表掩码生成函数，例如：OAEPWithMD5AndMGF1Padding或者OAEPWithSHA-512AndMGF1Padding</td>
</tr>
<tr>
<td style="text-align:center">PKCS1Padding</td>
<td style="text-align:center">PKCS1，RSA算法使用</td>
</tr>
<tr>
<td style="text-align:center">PKCS5Padding</td>
<td style="text-align:center">PKCS5，RSA算法使用</td>
</tr>
<tr>
<td style="text-align:center">SSL3Padding</td>
<td style="text-align:center">见SSL Protocol Version 3.0的定义</td>
</tr>
</tbody>
</table>
<p>其他Padding需要第三方Provider提供。</p>
<h2 id="Cipher的属性和方法">Cipher的属性和方法</h2>
<h3 id="Cipher的七个主要公有属性">Cipher的七个主要公有属性</h3>
<ul>
<li>1、ENCRYPT_MODE，整型值1，加密模式，用于Cipher的初始化。</li>
<li>2、DECRYPT_MODE，整型值2，解密模式，用于Cipher的初始化。</li>
<li>3、WRAP_MODE，整型值3，包装密钥模式，用于Cipher的初始化。</li>
<li>4、UNWRAP_MODE，整型值4，解包装密钥模式，用于Cipher的初始化。</li>
<li>5、PUBLIC_KEY，整型值1，解包装密钥模式下指定密钥类型为公钥。</li>
<li>6、PRIVATE_KEY，整型值2，解包装密钥模式下指定密钥类型为私钥。</li>
<li>7、SECRET_KEY，整型值3，解包装密钥模式下指定密钥类型为密钥，主要用于不是非对称加密的密钥(只有一个密钥，不包含私钥和公钥)。</li>
</ul>
<h3 id="getInstance方法">getInstance方法</h3>
<p>Cipher提供三个静态工厂方法<code>getInstance()</code>用于构建其实例，三个方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cipher <span class="title">getInstance</span><span class="params">(String transformation)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> NoSuchAlgorithmException,</span></span><br><span class="line"><span class="function">                                       NoSuchPaddingException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cipher <span class="title">getInstance</span><span class="params">(String transformation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String provider)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> NoSuchAlgorithmException,</span></span><br><span class="line"><span class="function">                                       NoSuchProviderException,</span></span><br><span class="line"><span class="function">                                       NoSuchPaddingException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cipher <span class="title">getInstance</span><span class="params">(String transformation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Provider provider)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> NoSuchAlgorithmException,</span></span><br><span class="line"><span class="function">                                       NoSuchPaddingException</span></span><br></pre></td></tr></table></figure>
<p>其中transformation，这里称为<strong>转换(模式)</strong>，是核心参数，见前面一个小节的解析。另外，有两个工厂方法要求必须传入java.security.Provider的全类名或者实例，因为Cipher要从对应的提供商中获取指定转换模式的实现，第一个工厂方法只有单参数transformation，它会从现成所有的<code>java.security.Provider</code>中匹配取出第一个满足transformation的服务，从中实例化<code>CipherSpi</code>(<strong>要理解Cipher委托到内部持有的CipherSpi实例完成具体的加解密功能</strong>)。实际上Cipher实例的初始化必须依赖于转换模式和提供商。</p>
<h3 id="init方法">init方法</h3>
<p><code>init()</code>方法一共有八个变体方法，此方法主要用于初始化Cipher。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//额外参数是Key(密钥)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)和SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)和AlgorithmParameterSpec(算法参数透明定义)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameterSpec params)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)、AlgorithmParameterSpec(算法参数透明定义)和SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameterSpec params,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)、AlgorithmParameters(算法参数)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameters params)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Key(密钥)、AlgorithmParameters(算法参数)、SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Key key,</span></span></span><br><span class="line"><span class="function"><span class="params">                       AlgorithmParameters params,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                       InvalidAlgorithmParameterException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Certificate(证书)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Certificate certificate)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//额外参数是Certificate(证书)、SecureRandom(随机源)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> opmode,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Certificate certificate,</span></span></span><br><span class="line"><span class="function"><span class="params">                       SecureRandom random)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> InvalidKeyException</span></span><br></pre></td></tr></table></figure>
<p>opmode(操作模式)是必须参数，可选值是ENCRYPT_MODE、DECRYPT_MODE、WRAP_MODE和UNWRAP_MODE。Key类型参数如果不是非对称加密，对应的类型是SecretKey，如果是非对称加密，可以是PublicKey或者PrivateKey。SecureRandom是随机源，因为有些算法需要每次加密结果都不相同，这个时候需要依赖系统或者传入的随机源，一些要求每次加解密结果相同的算法如AES不能使用此参数。Certificate是带有密钥的证书实现。算法参数主要包括IV(initialization vector，初始化向量)等等。</p>
<h3 id="wrap方法和unwrap方法">wrap方法和unwrap方法</h3>
<p>wrap方法用于包装一个密钥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] wrap(Key key)</span><br><span class="line">                  <span class="keyword">throws</span> IllegalBlockSizeException,</span><br><span class="line">                         InvalidKeyException</span><br></pre></td></tr></table></figure>
<p>wrap方法使用的时候需要注意Cipher的opmode要初始化为WRAP_MODE。</p>
<p>unwrap方法用于解包装一个密钥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Key <span class="title">unwrap</span><span class="params">(<span class="keyword">byte</span>[] wrappedKey,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String wrappedKeyAlgorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> wrappedKeyType)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> InvalidKeyException,</span></span><br><span class="line"><span class="function">                        NoSuchAlgorithmException</span></span><br></pre></td></tr></table></figure>
<p>unwrap方法使用的时候需要注意Cipher的opmode要初始化为UNWRAP_MODE，在调用unwrap方法时候，需要指定之前包装密钥的算法和Key的类型。</p>
<p>其实wrap和unwrap是一个互逆的操作：</p>
<ul>
<li>wrap方法的作用是把原始的密钥通过某种加密算法包装为加密后的密钥，这样就可以避免在传递密钥的时候泄漏了密钥的明文。</li>
<li>unwrap方法的作用是把包装(加密)后的密钥解包装为原始的密钥，得到密钥的明文。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncryptUtils &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRECT = <span class="string">"passwrod"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">wrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.WRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKeySpec key = <span class="keyword">new</span> SecretKeySpec(keyString.getBytes(), <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.wrap(key);</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">unwrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = Hex.decodeHex(keyString);</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.UNWRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKey key = (SecretKey) cipher.unwrap(rawKey, <span class="string">"AES"</span>, Cipher.SECRET_KEY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String wrapKey = EncryptUtils.SINGLETON.wrap(<span class="string">"doge"</span>);</span><br><span class="line">        System.out.println(wrapKey);</span><br><span class="line">        System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是通过AES对密钥进行包装和解包装，调用main方法，输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">77050742188</span>d4b97a1d401db902b864d</span><br><span class="line">doge</span><br></pre></td></tr></table></figure>
<h3 id="update方法">update方法</h3>
<p>update方法有多个变体，其实意义相差无几：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] update(<span class="keyword">byte</span>[] input)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] update(<span class="keyword">byte</span>[] input,</span><br><span class="line">                           <span class="keyword">int</span> inputOffset,</span><br><span class="line">                           <span class="keyword">int</span> inputLen)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> inputLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">byte</span>[] output)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> ShortBufferException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(ByteBuffer input,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ByteBuffer output)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> ShortBufferException</span></span><br></pre></td></tr></table></figure>
<p>update方法主要用于部分加密或者部分解密，至于加密或是解密取决于Cipher初始化时候的opmode。即使它有多个变体，但是套路是一样的：依赖于一个输入的缓冲区(带有需要被加密或者被解密的数据)、返回值或者参数是一个输出的缓冲区，一些额外的参数可以通过偏移量和长度控制加密或者解密操作的数据段。部分加密或者解密操作完毕后，必须要调用<code>Cipher#doFinal()</code>方法来结束加密或者解密操作。</p>
<h3 id="doFinal方法">doFinal方法</h3>
<p><code>doFinal()</code>方法也存在多个变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束多部分加密或者解密操作。</span></span><br><span class="line"><span class="comment"> * 此方法需要在update调用链执行完毕之后调用，返回的结果是加密或者解密结果的一部分。</span></span><br><span class="line"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] doFinal()</span><br><span class="line">                     <span class="keyword">throws</span> IllegalBlockSizeException,</span><br><span class="line">                            BadPaddingException</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结束多部分加密或者解密操作。</span></span><br><span class="line"><span class="comment"> * 此方法需要在update调用链执行完毕之后调用，传入的output作为缓冲区接收加密或者解密结果的一部分。</span></span><br><span class="line"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] output,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> outputOffset)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         ShortBufferException,</span></span><br><span class="line"><span class="function">                         BadPaddingException                         </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法接收需要加密或者解密的完整报文，返回处理结果</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input)</span></span></span><br><span class="line"><span class="function">                     <span class="keyword">throws</span> IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                            BadPaddingException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> inputLen)</span></span></span><br><span class="line"><span class="function">                     <span class="keyword">throws</span> IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                            BadPaddingException      </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度，output用于接收加解密的结果</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">byte</span>[] output)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> ShortBufferException,</span></span><br><span class="line"><span class="function">                         IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         BadPaddingException                                                         </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * output用于接收加解密的结果，outputOffset用于设置output的起始位置</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(<span class="keyword">byte</span>[] input,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> inputLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">byte</span>[] output,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> outputOffset)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> ShortBufferException,</span></span><br><span class="line"><span class="function">                         IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         BadPaddingException </span></span><br><span class="line"><span class="function"><span class="comment">/**</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 结束单部分或者多部分加密或者解密操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 参数input为输入缓冲区，output为输出缓冲区</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此方法正常调用结束之后Cipher会重置为初始化状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doFinal</span><span class="params">(ByteBuffer input,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ByteBuffer output)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> ShortBufferException,</span></span><br><span class="line"><span class="function">                         IllegalBlockSizeException,</span></span><br><span class="line"><span class="function">                         BadPaddingException</span></span><br></pre></td></tr></table></figure>
<p><code>doFinal()</code>主要功能是结束单部分或者多部分加密或者解密操作。单部分加密或者解密适用于需要处理的报文长度较短无需分块的情况，这个时候直接使用<code>byte[] doFinal(byte[] input)</code>方法即可。多部分加密或者解密适用于需要处理的报文长度长度较大，需要进行分块的情况，这个时候需要调用多次<code>update</code>方法变体进行部分块的加解密，最后调用<code>doFinal</code>方法变体进行部分加解密操作的结束。举个例子，例如处理块的大小为8，实际需要加密的报文长度为23，那么需要分三块进行加密，前面2块长度为8的报文需要调用update进行部分加密，部分加密的结果可以从update的返回值获取到，最后的7长度(其实一般会填充到长度为块长度8)的报文则调用doFinal进行加密，结束整个部分加密的操作。另外，值得注意的是只要Cipher正常调用完任一个<code>doFinal</code>变体方法(过程中不抛出异常)，那么Cipher会重置为初始化状态，可以继续使用，这个可复用的特性可以降低创建Cipher实例的性能损耗。</p>
<h3 id="updateADD方法">updateADD方法</h3>
<p>首先ADD的意思是Additional Authentication Data(额外的身份认证数据)。<code>updateADD()</code>也有三个方法变体：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAAD</span><span class="params">(<span class="keyword">byte</span>[] src)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAAD</span><span class="params">(<span class="keyword">byte</span>[] src,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateAAD</span><span class="params">(ByteBuffer src)</span></span></span><br></pre></td></tr></table></figure>
<p>它的方法变体都只依赖一个输入缓冲区，带有额外的身份认证数据，一般使用在<code>GCM</code>或者<code>CCM</code>加解密算法中。如果使用此方法，它的调用必须在Cipher的<code>update</code>和<code>doFinal</code>变体方法之前调用，其实理解起来也很简单，身份验证必须在实际的加解密操作之前进行。目前，<code>updateADD</code>的资料比较少，笔者在生产环境找那个也尚未实践过，所以不做展开分析。</p>
<h3 id="其他方法">其他方法</h3>
<p>其他方法主要是Getter方法，用于获取Cipher的相关信息。</p>
<ul>
<li><code>public final Provider getProvider()</code>：获取Cipher的提供商。</li>
<li><code>public final String getAlgorithm()</code>：获取Cipher使用的算法名称。</li>
<li><code>public final int getBlockSize()</code>：分组加密中，每一组都有固定的长度，也称为块，此方法是返回块的大小（以字节为单位）。</li>
<li><code>public final int getOutputSize(int inputLen)</code>：根据给定的输入长度inputLen（以字节为单位），返回保存下一个update或doFinal操作结果所需的输出缓冲区长度（以字节为单位）。</li>
<li><code>public final byte[] getIV()</code>：返回Cipher中的初始化向量的字节数组。</li>
<li><code>public final AlgorithmParameters getParameters()</code>：返回Cipher使用的算法参数。</li>
<li><code>public final ExemptionMechanism getExemptionMechanism()</code>：返回Cipher使用的豁免(exemption)机制对象。</li>
<li><code>public static final int getMaxAllowedKeyLength(String transformation)</code>：根据所安装的JCE策略文件，返回指定转换的最大密钥长度。</li>
<li><code>public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation)</code>：根据JCE策略文件，返回Cipher指定transformation下最大的AlgorithmParameterSpec对象。</li>
</ul>
<h2 id="Cipher的工作流程">Cipher的工作流程</h2>
<p>下面画一个图来详细分析一下Cipher的工作流程：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/cipher-1.png" alt="cipher-1"></p>
<p>当然上图只分析了Cipher的使用过程，其实还有一个重要的步骤就是密钥的处理，但是密钥的处理和具体的算法使用是相关的，所以图中没有体现。再放一张官方描述Cipher加载的流程：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/cipher-2.png" alt="cipher-2"></p>
<p>主要过程包括：</p>
<ul>
<li>1、创建Cipher实例，这个时候会从平台中所有的提供商(Provider)中根据transformation匹配第一个可以使用的CipherSpi实例，&quot;算法/工作模式/填充模式&quot;必须完全匹配才能选中。</li>
</ul>
<blockquote>
<p>在${JAVA_HONE}/jre/lib/security中的java.security文件中可以看到默认加载的提供商。如果需要添加额外或者自实现的Provider，可以通过java.security.Security的静态方法addProvider添加。</p>
</blockquote>
<ul>
<li>2、通过Cipher实例的init方法初始化Cipher，主要参数是opmode和密钥。</li>
<li>3、根据初始化的方式和是否需要分组处理，选择合适的方法进行调用，一般以<code>doFinal()</code>方法作结得到返回结果。</li>
</ul>
<h2 id="Cipher的使用">Cipher的使用</h2>
<p>为了方便Cipher的使用，最好先引入<code>apache-codec</code>依赖，这样能简化Hex、Base64等操作。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>大多数情况下，加密后的byte数组的中元素取值不在Unicode码点的范围内，表面上看到的就是乱码，实际上它们是有意义的，因此需要考虑把这种byte数组转换为非乱码的字符串以便传输，常见的方式有Hex(二进制转换为十六进制)、Base64等等。下面举例中没有针对异常类型进行处理统一外抛，切勿模仿，还有，所有的字符串转化为字节数组都没有指定字符编码，因此只能使用非中文的明文进行处理。</p>
<h3 id="加密模式">加密模式</h3>
<p>加密模式下，Cipher只能用于加密，主要由<code>init()</code>方法中的opmode决定。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">encryptByAes</span><span class="params">(String content, String password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//这里指定了算法为AES_128，工作模式为EBC，填充模式为NoPadding</span></span><br><span class="line">	Cipher cipher = Cipher.getInstance(<span class="string">"AES_128/ECB/NoPadding"</span>);</span><br><span class="line">	KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">	keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(password.getBytes()));</span><br><span class="line">	SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">	SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//基于加密模式和密钥初始化Cipher</span></span><br><span class="line">	cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">	<span class="comment">//单部分加密结束，重置Cipher</span></span><br><span class="line">	<span class="keyword">byte</span>[] bytes = cipher.doFinal(content.getBytes());</span><br><span class="line">	<span class="comment">//加密后的密文由二进制序列转化为十六进制序列，依赖apache-codec包</span></span><br><span class="line">	<span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实整个过程Cipher的使用都很简单，比较复杂的反而是密钥生成的过程。上面的例子需要注意，因为使用了填充模式为NoPadding，输入的需要加密的报文长度必须是16(128bit)的倍数。</p>
<h3 id="解密模式">解密模式</h3>
<p>解密模式的使用大致和加密模式是相同的，把处理过程逆转过来就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decryptByAes</span><span class="params">(String content, String password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//这里要把十六进制的序列转化回二进制的序列，依赖apache-codec包</span></span><br><span class="line">	<span class="keyword">byte</span>[] bytes = Hex.decodeHex(content);</span><br><span class="line">	<span class="comment">//这里指定了算法为AES_128，工作模式为EBC，填充模式为NoPadding</span></span><br><span class="line">	Cipher cipher = Cipher.getInstance(<span class="string">"AES_128/ECB/NoPadding"</span>);</span><br><span class="line">	KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">	keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(password.getBytes()));</span><br><span class="line">	SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">	SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">	<span class="comment">//基于解密模式和密钥初始化Cipher</span></span><br><span class="line">	cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">	<span class="comment">//单部分加密结束，重置Cipher</span></span><br><span class="line">	<span class="keyword">byte</span>[] result = cipher.doFinal(bytes);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子需要注意，因为使用了填充模式为NoPadding，输入的需要加密的报文长度必须是16(128bit)的倍数。</p>
<h3 id="包装密钥模式和解包装密钥模式">包装密钥模式和解包装密钥模式</h3>
<p>密钥的包装和解包装模式是一对互逆的操作，主要作用是通过算法对密钥进行加解密，从而提高密钥泄漏的难度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncryptUtils &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRECT = <span class="string">"passwrod"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">wrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.WRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKeySpec key = <span class="keyword">new</span> SecretKeySpec(keyString.getBytes(), <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.wrap(key);</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">unwrap</span><span class="params">(String keyString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] rawKey = Hex.decodeHex(keyString);</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        <span class="comment">//初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是"passward")</span></span><br><span class="line">        keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRECT.getBytes()));</span><br><span class="line">        SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">        SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.UNWRAP_MODE, secretKeySpec);</span><br><span class="line">        SecretKey key = (SecretKey) cipher.unwrap(rawKey, <span class="string">"AES"</span>, Cipher.SECRET_KEY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(key.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String wrapKey = EncryptUtils.SINGLETON.wrap(<span class="string">"doge"</span>);</span><br><span class="line">        System.out.println(wrapKey);</span><br><span class="line">        System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组-部分-加密和分组解密">分组(部分)加密和分组解密</h3>
<p>当一个需要加密的报文十分长的时候，我们可以考虑把报文切割成多个小段，然后针对每个小段进行加密，这就是分组加密。分组解密的过程类同，可以看作是分组加密的逆向过程。下面还是用AES算法为例举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> throwable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/15 1:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Part &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * SINGLETON</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SINGLETON;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"throwable"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cipher <span class="title">createCipher</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">encrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Cipher cipher = createCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(PASSWORD.getBytes()));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//基于加密模式和密钥初始化Cipher</span></span><br><span class="line">		cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">		<span class="keyword">byte</span>[] raw = content.getBytes();</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//[0,9]</span></span><br><span class="line">		<span class="keyword">byte</span>[] first = cipher.update(raw, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">		builder.append(Hex.encodeHexString(first));</span><br><span class="line">		<span class="comment">//[10,19]</span></span><br><span class="line">		<span class="keyword">byte</span>[] second = cipher.update(raw, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">		builder.append(Hex.encodeHexString(second));</span><br><span class="line">		<span class="comment">//[20,25]</span></span><br><span class="line">		<span class="keyword">byte</span>[] third = cipher.update(raw, <span class="number">20</span>, <span class="number">6</span>);</span><br><span class="line">		builder.append(Hex.encodeHexString(third));</span><br><span class="line">		<span class="comment">//多部分加密结束，得到最后一段加密的结果，重置Cipher</span></span><br><span class="line">		<span class="keyword">byte</span>[] bytes = cipher.doFinal();</span><br><span class="line">		String last = Hex.encodeHexString(bytes);</span><br><span class="line">		builder.append(last);</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">decrypt</span><span class="params">(String content)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] raw = Hex.decodeHex(content);</span><br><span class="line">		Cipher cipher = createCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组</span></span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(PASSWORD.getBytes()));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AES"</span>);</span><br><span class="line">		<span class="comment">//基于解密模式和密钥初始化Cipher</span></span><br><span class="line">		cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//[0,14]</span></span><br><span class="line">		<span class="keyword">byte</span>[] first = cipher.update(raw, <span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(first));</span><br><span class="line">		<span class="comment">//[15,29]</span></span><br><span class="line">		<span class="keyword">byte</span>[] second = cipher.update(raw, <span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(second));</span><br><span class="line">		<span class="comment">//[30,31]</span></span><br><span class="line">		<span class="keyword">byte</span>[] third = cipher.update(raw, <span class="number">30</span>, <span class="number">2</span>);</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(third));</span><br><span class="line">		<span class="comment">//多部分解密结束，得到最后一段解密的结果，重置Cipher</span></span><br><span class="line">		<span class="keyword">byte</span>[] bytes = cipher.doFinal();</span><br><span class="line">		builder.append(<span class="keyword">new</span> String(bytes));</span><br><span class="line">		<span class="keyword">return</span> builder.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		String raw = <span class="string">"abcdefghijklmnopqrstyuwxyz"</span>;</span><br><span class="line">		String e = Part.SINGLETON.encrypt(raw);</span><br><span class="line">		System.out.println(e);</span><br><span class="line">		System.out.println(Part.SINGLETON.decrypt(e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的分段下标已经在注释中给出，分段的规则由实际情况考虑，一般AES加解密报文不大的时候可以直接单部分加解密即可，这里仅仅是为了做展示。</p>
<h3 id="查看当前JDK中Cipher的所有提供商">查看当前JDK中Cipher的所有提供商</h3>
<p>我们可以直接查看当前的使用的JDK中Cipher的所有提供商和支持的加解密服务，简单写个main函数就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.Provider;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Provider[] providers = Security.getProviders();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != providers) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Provider provider : providers) &#123;</span><br><span class="line">				Set&lt;Provider.Service&gt; services = provider.getServices();</span><br><span class="line">				<span class="keyword">for</span> (Provider.Service service : services) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">"Cipher"</span>.equals(service.getType())) &#123;</span><br><span class="line">						System.out.println(String.format(<span class="string">"provider:%s,type:%s,algorithm:%s"</span>, service.getProvider(), service.getType(), service.getAlgorithm()));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>笔者编写这篇文章的时候使用的JDK是JDK8的最后一个更新的版本8u181(1.8.0_181)，运行main函数输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:RSA</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:DES</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:DESede</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:DESedeWrap</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithMD5AndDES</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithMD5AndTripleDES</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithSHA1AndDESede</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithSHA1AndRC2_40</span><br><span class="line">provider:SunJCE version <span class="number">1.8</span>,type:Cipher,algorithm:PBEWithSHA1AndRC2_128</span><br><span class="line">.....输出内容太多忽略剩余部分</span><br></pre></td></tr></table></figure>
<h2 id="扩展">扩展</h2>
<p>因为Java原生支持的transformation是有限的，有些时候我们需要使用一些算法其他工作模式或者填充模式原生无法支持，这个时候我们需要引入第三方的Provider甚至自己实现Provider。常见的第三方Provider是bouncycastle(BC)，目前BC的最新依赖为：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcprov-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>举个例子，Java原生是不支持AESWRAP算法的，因此可以引入BC的依赖，再使用转换模式AESWRAP。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.security.Security;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EncryptUtils &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * SINGLETON</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SINGLETON;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SECRET = <span class="string">"throwable"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//装载BC提供商</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Security.addProvider(<span class="keyword">new</span> BouncyCastleProvider());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cipher <span class="title">createAesCipher</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Cipher.getInstance(<span class="string">"AESWRAP"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">encryptByAes</span><span class="params">(String raw)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Cipher aesCipher = createAesCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AESWRAP"</span>);</span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRET.getBytes(CHARSET)));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AESWRAP"</span>);</span><br><span class="line">		aesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = aesCipher.doFinal(raw.getBytes(CHARSET));</span><br><span class="line">		<span class="keyword">return</span> Hex.encodeHexString(bytes);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">decryptByAes</span><span class="params">(String raw)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = Hex.decodeHex(raw);</span><br><span class="line">		Cipher aesCipher = createAesCipher();</span><br><span class="line">		KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AESWRAP"</span>);</span><br><span class="line">		keyGenerator.init(<span class="number">128</span>, <span class="keyword">new</span> SecureRandom(SECRET.getBytes(CHARSET)));</span><br><span class="line">		SecretKey secretKey = keyGenerator.generateKey();</span><br><span class="line">		SecretKeySpec secretKeySpec = <span class="keyword">new</span> SecretKeySpec(secretKey.getEncoded(), <span class="string">"AESWRAP"</span>);</span><br><span class="line">		aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> String(aesCipher.doFinal(bytes), CHARSET);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String raw = <span class="string">"throwable-a-doge"</span>;</span><br><span class="line">		String en = EncryptUtils.SINGLETON.encryptByAes(raw);</span><br><span class="line">		System.out.println(en);</span><br><span class="line">		String de = EncryptUtils.SINGLETON.decryptByAes(en);</span><br><span class="line">		System.out.println(de);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子需要注意，因为使用了AESWRAP算法，输入的需要加密的报文长度必须是8的倍数。</p>
<h2 id="小结">小结</h2>
<p>熟练掌握Cipher的用法、转换模式transformation的一些知识之后，影响我们编写加解密模块代码的主要因素就是加解密算法的原理或者使用，这些需要我们去学习专门的加解密算法相关的知识。另外，<strong>有些时候我们发现不同平台或者不同语言使用同一个加密算法不能相互解密加密</strong>，其实原因很简单，绝大部分原因是工作模式选取或者填充模式选取的不同导致的，排除掉这两点，剩下的可能性就是算法的实现不相同，依据这三点因素(或者说就是transformation这唯一的因素)去判断和寻找解决方案即可。关于加解密算法原理、工作模式等相关知识可以参考下面的资料。</p>
<p>参考资料：</p>
<ul>
<li>《密码编码学与网络安全-原理与实践(第六版)》</li>
<li>《信息安全原理与实践(第2版)》</li>
<li>《关于加密数据的填充方式的研究》</li>
<li>JDK8文档</li>
</ul>
<p>另外，一些特殊的方法例如<code>Ciper#updateADD()</code>暂时没遇到使用场景，这里就不写没实践过的Demo。</p>
<p>(本文完 e-a-20190216 c-7-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Security/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Security</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/02/16/java-reference/">
      深入理解JDK中的Reference原理和源码实现
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年2月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：9.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：41分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-02-16T14:51:54+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年2月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入理解JDK中的Reference原理和源码实现</h1>
<h2 id="前提">前提</h2>
<p>这篇文章主要基于JDK11的源码和最近翻看的《深入理解Java虚拟机-2nd》一书的部分内容，对JDK11中的Reference(引用)做一些总结。值得注意的是，通过笔者对比一下JDK11和JDK8对于<code>java.lang.ref</code>包的相关实现，发现代码变化比较大，<strong>因此本文的源码分析可能并不适合于JDK11之外的JDK版本</strong>。</p>
<h2 id="Reference的简介和分类">Reference的简介和分类</h2>
<p>在JDK1.2之前，Java中的引用的定义是十分传统的：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。在这种定义之下，一个对象只有被引用和没有被引用两种状态。</p>
<p>实际上，我们更希望存在这样的一类对象：当内存空间还足够的时候，这些对象能够保留在内存空间中；如果当内存空间在进行了垃圾收集之后还是非常紧张，则可以抛弃这些对象。基于这种特性，可以满足很多系统的缓存功能的使用场景。</p>
<p><code>java.lang.ref</code>包是JDK1.2引入的，包结构和类分布如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- java.lang.ref</span><br><span class="line">  - Cleaner<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">Finalizer</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">FinalizerHistogram</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">FinalReference</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">PhantomReference</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">Reference</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">ReferenceQueue</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">  - <span class="title">SoftReference</span>.<span class="title">classs</span></span></span><br><span class="line"><span class="class">  - <span class="title">WeakReference</span>.<span class="title">class</span></span></span><br></pre></td></tr></table></figure>
<p>引入此包的作用是对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种类型的引用，还有一种比较特殊的引用是析构引用(Final Reference)，它是一种特化的虚引用。四种引用的强度按照下面的次序依次减弱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrongReference &gt; SoftReference &gt; WeakReference &gt; PhantomReference</span><br></pre></td></tr></table></figure>
<p>值得注意的是：</p>
<ul>
<li>强引用没有对应的类型表示，也就是说强引用是普遍存在的，如<code>Object object = new Object();</code>。</li>
<li>软引用、弱引用和虚引用都是<code>java.lang.ref.Reference</code>的直接子类。</li>
<li>直到JDK11为止，只存在四种引用，这些引用是由JVM创建，因此直接继承<code>java.lang.ref.Reference</code>创建自定义的引用类型是无效的，但是可以直接继承已经存在的引用类型，如<code>java.lang.ref.Cleaner</code>就是继承自<code>java.lang.ref.PhantomReference</code>。</li>
<li>特殊的<code>java.lang.ref.Reference</code>的子类<code>java.lang.ref.FinalReference</code>和<code>Object#finalize()</code>有关，<code>java.lang.ref.Finalizer</code>是<code>java.lang.ref.FinalReference</code>子类，下文会详细分析这些内容。</li>
</ul>
<h2 id="Reference">Reference</h2>
<p><code>Reference</code>就是引用，对JVM的垃圾收集活动敏感(当然，强引用可能对垃圾收集活动是不敏感的)，<code>Reference</code>的继承关系或者实现是由JDK定制，引用实例是由JVM创建，所以自行继承<code>Reference</code>实现自定义的引用类型是无意义的，但是可以继承已经存在的引用类型，如<code>SoftReference</code>等。<code>Reference</code>类文件的注释也比较简短，但是方法和变量的注释十分详细，特别是用图表表明了状态跃迁的过程，这里先看类文件头注释：</p>
<blockquote>
<p>Abstract base class for reference objects.  This class defines the operations common to all reference objects.  Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.</p>
</blockquote>
<p>翻译一下大意是：<code>Reference</code>是所有引用对象的基类。这个类定义了所有引用对象的通用操作。因为引用对象是与垃圾收集器紧密协作而实现的，所以这个类可能不能直接子类化。</p>
<h3 id="Reference的状态集合">Reference的状态集合</h3>
<p><code>Reference</code>源码中并不存在一个成员变量用于描述<code>Reference</code>的状态，它是通过组合判断referent、discovered、queue、next成员的存在性或者顺序&quot;拼凑出&quot;对应的状态，注释中描述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">一个引用对象可以同时存在两种状态：</span><br><span class="line">- 第一组状态：<span class="string">"active"</span>, <span class="string">"pending"</span>, or <span class="string">"inactive"</span></span><br><span class="line">- 第二组状态：<span class="string">"registered"</span>, <span class="string">"enqueued"</span>, <span class="string">"dequeued"</span>, or <span class="string">"unregistered"</span></span><br><span class="line"></span><br><span class="line">Active：</span><br><span class="line"></span><br><span class="line">当前引用实例处于Active状态，会收到垃圾收集器的特殊处理。在垃圾收集器检测到referent的可达性已更改为适当状态之后的某个时间，垃圾收集器会<span class="string">"通知"</span>当前引用实例改变其状态为<span class="string">"pending"</span>或者<span class="string">"inactive"</span>。此时的判断条件是：referent != <span class="keyword">null</span>; discovered = <span class="keyword">null</span>或者实例位于GC的discovered列表中。</span><br><span class="line"></span><br><span class="line">Pending：</span><br><span class="line"></span><br><span class="line">当前的引用实例是pending-Reference列表的一个元素，等待被ReferenceHandler线程处理。pending-Reference列表通过应用实例的discovered字段进行关联。此时的判断条件是：referent = <span class="keyword">null</span>; discovered = pending-Reference列表中的下一个元素</span><br><span class="line"></span><br><span class="line">Inactive：</span><br><span class="line"></span><br><span class="line">当前的引用实例处于非Active和非Pending状态。此时的判断条件是：referent = <span class="keyword">null</span> (同时discovered = <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">Registered：</span><br><span class="line"></span><br><span class="line">当前的引用实例创建的时候关联到一个引用队列实例，但是引用实例暂未加入到队列中。此时的判断条件是：queue = 传入的ReferenceQueue实例</span><br><span class="line"></span><br><span class="line">Enqueued：</span><br><span class="line"></span><br><span class="line">当前的引用实例已经添加到和它关联的引用队列中但是尚未移除(remove)，也就是调用了ReferenceQueue.enqueued()后的Reference实例就会处于这个状态。此时的判断条件是：queue = ReferenceQueue.ENQUEUE; next = 引用列表中的下一个引用实例，或者如果当前引用实例是引用列表中的最后一个元素，则它会进入Inactive状态</span><br><span class="line"></span><br><span class="line">Dequeued：</span><br><span class="line"></span><br><span class="line">当前的引用实例曾经添加到和它关联的引用队列中并且已经移除(remove)。此时的判断条件是：queue = ReferenceQueue.NULL; next = 当前的引用实例</span><br><span class="line"></span><br><span class="line">Unregistered：</span><br><span class="line"></span><br><span class="line">当前的引用实例不存在关联的引用队列，也就是创建引用实例的时候传入的queue为<span class="keyword">null</span>。此时的判断条件是：queue = ReferenceQueue.NULL</span><br></pre></td></tr></table></figure>
<p>状态跃迁的时序图如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">* Initial states:</span><br><span class="line">*   [active/registered]</span><br><span class="line">*   [active/unregistered] [<span class="number">1</span>]</span><br><span class="line">*</span><br><span class="line">* Transitions:</span><br><span class="line">*                            clear</span><br><span class="line">*   [active/registered]     -------&gt;   [inactive/registered]</span><br><span class="line">*          |                                 |</span><br><span class="line">*          |                                 | enqueue [<span class="number">2</span>]</span><br><span class="line">*          | GC              enqueue [<span class="number">2</span>]     |</span><br><span class="line">*          |                -----------------|</span><br><span class="line">*          |                                 |</span><br><span class="line">*          v                                 |</span><br><span class="line">*   [pending/registered]    ---              v</span><br><span class="line">*          |                   | ReferenceHandler</span><br><span class="line">*          | enqueue [<span class="number">2</span>]       |---&gt;   [inactive/enqueued]</span><br><span class="line">*          v                   |             |</span><br><span class="line">*   [pending/enqueued]      ---              |</span><br><span class="line">*          |                                 | poll/remove</span><br><span class="line">*          | poll/remove                     |</span><br><span class="line">*          |                                 |</span><br><span class="line">*          v            ReferenceHandler     v</span><br><span class="line">*   [pending/dequeued]      ------&gt;    [inactive/dequeued]</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*                           clear/enqueue/GC [<span class="number">3</span>]</span><br><span class="line">*   [active/unregistered]   ------</span><br><span class="line">*          |                      |</span><br><span class="line">*          | GC                   |</span><br><span class="line">*          |                      |--&gt; [inactive/unregistered]</span><br><span class="line">*          v                      |</span><br><span class="line">*   [pending/unregistered]  ------</span><br><span class="line">*                           ReferenceHandler</span><br><span class="line">*</span><br><span class="line">* Terminal states:</span><br><span class="line">*   [inactive/dequeued]</span><br><span class="line">*   [inactive/unregistered]</span><br><span class="line">*</span><br><span class="line">* <span class="function">Unreachable <span class="title">states</span> <span class="params">(because enqueue also clears)</span>:</span></span><br><span class="line"><span class="function">*   [active/enqeued]</span></span><br><span class="line"><span class="function">*   [active/dequeued]</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* [1] Unregistered is not permitted <span class="keyword">for</span> FinalReferences.</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* [2] These transitions are not possible <span class="keyword">for</span> FinalReferences, making</span></span><br><span class="line"><span class="function">* [pending/enqueued] and [pending/dequeued] unreachable, and</span></span><br><span class="line"><span class="function">* [inactive/registered] terminal.</span></span><br><span class="line"><span class="function">*</span></span><br><span class="line"><span class="function">* [3] The garbage collector may directly transition a Reference</span></span><br><span class="line"><span class="function">* from [active/unregistered] to [inactive/unregistered],</span></span><br><span class="line"><span class="function">* bypassing the pending-Reference list.</span></span><br></pre></td></tr></table></figure>
<p>注释中还强调了几点：</p>
<ul>
<li>初始化状态：<code>[active/registered]</code>和<code>[active/unregistered](这种情况只限于FinalReferences)</code>。</li>
<li>终结状态：<code>[inactive/dequeued]</code>和<code>[inactive/unregistered]</code>。</li>
<li>不可能出现的状态：<code>[active/enqeued]</code>和<code>[active/dequeued]</code>。</li>
</ul>
<p>上面的图看起来可能比较抽象，<code>ReferenceHandler</code>其实是<code>Reference</code>中静态代码块中初始化的线程实例，主要作用是：处理pending状态的引用实例，使它们入队列并走向<code>[inactive/dequeued]</code>状态。另外，上面的线框图是分两部分，其中上半部分是使用了<code>ReferenceQueue</code>，后半部分是没有使用<code>ReferenceQueue</code>(或者说使用了<code>ReferenceQueue.NULL</code>)。这里尝试用PPT画一下简化的状态跃迁图：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-d-k-r-1.png" alt="j-d-k-r-1"></p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-d-k-r-2.png" alt="j-d-k-r-2"></p>
<h3 id="Reference源码分析">Reference源码分析</h3>
<p>先看<code>Reference</code>的构造函数和成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> T referent;</span><br><span class="line">   <span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br><span class="line">   <span class="keyword">volatile</span> Reference next;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Reference&lt;T&gt; discovered;</span><br><span class="line"></span><br><span class="line">   Reference(T referent) &#123;</span><br><span class="line">        <span class="keyword">this</span>(referent, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.referent = referent;</span><br><span class="line">        <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造描述</strong>：</p>
<p>构造函数依赖于一个泛型的referent成员以及一个<code>ReferenceQueue&lt;? super T&gt;</code>的队列，如果<code>ReferenceQueue</code>实例为null，则使用<code>ReferenceQueue.NULL</code>。</p>
<p><strong>成员变量描述</strong>：</p>
<ul>
<li>referent：<code>Reference</code>保存的引用指向的对象，下面直接称为referent。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC特殊处理的对象</span></span><br><span class="line"><span class="keyword">private</span> T referent;         <span class="comment">/* Treated specially by GC */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>queue：<code>Reference</code>对象关联的队列，也就是引用队列，对象如果即将被垃圾收集器回收，此队列作为通知的回调队列，也就是当<code>Reference</code>实例持有的对象referent要被回收的时候，<code>Reference</code>实例会被放入引用队列，那么程序执行的时候可以从引用队列得到或者监控相应的<code>Reference</code>实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The queue this reference gets enqueued to by GC notification or by</span></span><br><span class="line"><span class="comment"> * calling enqueue().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When registered: the queue with which this reference is registered.</span></span><br><span class="line"><span class="comment"> *        enqueued: ReferenceQueue.ENQUEUE</span></span><br><span class="line"><span class="comment"> *        dequeued: ReferenceQueue.NULL</span></span><br><span class="line"><span class="comment"> *    unregistered: ReferenceQueue.NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue;</span><br></pre></td></tr></table></figure>
<ul>
<li>next：下一个<code>Reference</code>实例的引用，<code>Reference</code>实例通过此构造单向的链表。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The link in a ReferenceQueue's list of Reference objects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When registered: null</span></span><br><span class="line"><span class="comment"> *        enqueued: next element in queue (or this if last)</span></span><br><span class="line"><span class="comment"> *        dequeued: this (marking FinalReferences as inactive)</span></span><br><span class="line"><span class="comment"> *    unregistered: null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">volatile</span> Reference next;</span><br></pre></td></tr></table></figure>
<ul>
<li>discovered：注意这个属性由transient修饰，基于状态表示不同链表中的下一个待处理的对象，主要是pending-reference列表的下一个元素，通过JVM直接调用赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When active:  next element in a discovered reference list maintained by GC (or this if last)</span></span><br><span class="line"><span class="comment">*     pending:   next element in the pending list (or null if last)</span></span><br><span class="line"><span class="comment">*     otherwise:   NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">private</span> Reference&lt;T&gt; discovered;  <span class="comment">/* used by VM */</span></span><br></pre></td></tr></table></figure>
<p><strong>实例方法(和ReferenceHandler线程不相关的方法)</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取持有的referent实例</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.referent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把持有的referent实例置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否处于enqeued状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnqueued</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span>.queue == ReferenceQueue.ENQUEUED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队参数，同时会把referent置为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.referent = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.queue.enqueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖clone方法并且抛出异常，也就是禁止clone</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> CloneNotSupportedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保给定的引用实例是强可达的</span></span><br><span class="line"><span class="meta">@ForceInline</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reachabilityFence</span><span class="params">(Object ref)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReferenceHandler线程">ReferenceHandler线程</h3>
<p>ReferenceHandler线程是由<code>Reference</code>静态代码块中建立并且运行的线程，它的运行方法中依赖了比较多的本地(native)方法，ReferenceHandler线程的主要功能是处理pending链表中的引用对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferenceHandler直接继承于Thread覆盖了run方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态工具方法用于确保对应的类型已经初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(clazz.getName(), <span class="keyword">true</span>, clazz.getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) <span class="keyword">new</span> NoClassDefFoundError(e.getMessage()).initCause(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 确保Cleaner这个类已经初始化</span></span><br><span class="line">        <span class="comment">// pre-load and initialize Cleaner class so that we don't</span></span><br><span class="line">        <span class="comment">// get into trouble later in the run loop if there's</span></span><br><span class="line">        <span class="comment">// memory shortage while loading/initializing it lazily.</span></span><br><span class="line">        ensureClassInitialized(Cleaner<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(g, <span class="keyword">null</span>, name, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意run方法是一个死循环执行processPendingReferences</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            processPendingReferences();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 原子获取(后)并且清理VM中的pending引用链表</span></span><br><span class="line"><span class="comment"> * Atomically get and clear (set to null) the VM's pending-Reference list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Reference&lt;Object&gt; <span class="title">getAndClearReferencePendingList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检验VM中的pending引用对象链表是否有剩余元素</span></span><br><span class="line"><span class="comment"> * Test whether the VM's pending-Reference list contains any entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">hasReferencePendingList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待直到pending引用对象链表不为null，此方法阻塞的具体实现又VM实现</span></span><br><span class="line"><span class="comment"> * Wait until the VM's pending-Reference list may be non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">waitForReferencePendingList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁对象，用于控制等待pending对象时候的加锁和开始处理这些对象时候的解锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object processPendingLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 正在处理pending对象的时候，这个变量会更新为true，处理完毕或者初始化状态为false，用于避免重复处理或者重复等待</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> processPendingActive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是死循环中的核心方法，功能是处理pending链表中的引用元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPendingReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Only the singleton reference processing thread calls</span></span><br><span class="line">    <span class="comment">// waitForReferencePendingList() and getAndClearReferencePendingList().</span></span><br><span class="line">    <span class="comment">// These are separate operations to avoid a race with other threads</span></span><br><span class="line">    <span class="comment">// that are calling waitForReferenceProcessing().</span></span><br><span class="line">    <span class="comment">// （1）等待</span></span><br><span class="line">    waitForReferencePendingList();</span><br><span class="line">    Reference&lt;Object&gt; pendingList;</span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        <span class="comment">// （2）获取并清理，标记处理中状态</span></span><br><span class="line">        pendingList = getAndClearReferencePendingList();</span><br><span class="line">        processPendingActive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// （3）通过discovered(下一个元素)遍历pending链表进行处理</span></span><br><span class="line">    <span class="keyword">while</span> (pendingList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Reference&lt;Object&gt; ref = pendingList;</span><br><span class="line">        pendingList = ref.discovered;</span><br><span class="line">        ref.discovered = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果是Cleaner类型执行执行clean方法并且对锁对象processPendingLock进行唤醒所有阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">            ((Cleaner)ref).clean();</span><br><span class="line">            <span class="comment">// Notify any waiters that progress has been made.</span></span><br><span class="line">            <span class="comment">// This improves latency for nio.Bits waiters, which</span></span><br><span class="line">            <span class="comment">// are the only important ones.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">                processPendingLock.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 非Cleaner类型并且引用队列不为ReferenceQueue.NULL则进行入队操作</span></span><br><span class="line">            ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = ref.queue;</span><br><span class="line">            <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(ref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// （4）当次循环结束之前再次唤醒锁对象processPendingLock上阻塞的所有线程</span></span><br><span class="line">    <span class="comment">// Notify any waiters of completion of current round.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        processPendingActive = <span class="keyword">false</span>;</span><br><span class="line">        processPendingLock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReferenceHandler线程启动的静态代码块如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// ThreadGroup继承当前执行线程(一般是主线程)的线程组</span></span><br><span class="line">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">         tgn != <span class="keyword">null</span>;</span><br><span class="line">         tg = tgn, tgn = tg.getParent());</span><br><span class="line">    <span class="comment">// 创建线程实例，命名为Reference Handler，配置最高优先级和后台运行(守护线程)，然后启动</span></span><br><span class="line">    Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">    <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">     * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">    handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    handler.start();</span><br><span class="line">    <span class="comment">// 注意这里覆盖了全局的jdk.internal.misc.JavaLangRefAccess实现</span></span><br><span class="line">    <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">    SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForReferenceProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Reference.waitForReferenceProcessing();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Finalizer.runFinalization();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果正在处理pending链表中的引用对象或者监测到VM中的pending链表中还有剩余元素则基于锁对象processPendingLock进行等待</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">waitForReferenceProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (processPendingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processPendingActive || hasReferencePendingList()) &#123;</span><br><span class="line">            <span class="comment">// Wait for progress, not necessarily completion.</span></span><br><span class="line">            processPendingLock.wait();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于ReferenceHandler线程是<code>Reference</code>的静态代码创建的，所以只要<code>Reference</code>这个父类被初始化，该线程就会创建和运行，由于它是守护线程，除非JVM进程终结，否则它会一直在后台运行(注意它的<code>run()</code>方法里面使用了死循环)。</p>
<h2 id="ReferenceQueue">ReferenceQueue</h2>
<p>JDK中对<code>ReferenceQueue</code>的文档描述是比较少的，类文件只有一句简单的注释：</p>
<blockquote>
<p>Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.</p>
</blockquote>
<p>翻译一下大意为：引用队列，垃圾收集器在检测到适当的可达性更改后将已注册的引用对象追加到该队列。</p>
<p>从源码上看，实际上<code>ReferenceQueue</code>只是名义上的引用队列，它只保存了<code>Reference</code>链表的头(<strong>head</strong>)节点，并且提供了出队、入队和移除等操作，而<code>Reference</code>实际上本身提供单向链表的功能，<strong>也就是<code>Reference</code>通过成员属性next构建单向链表，而链表的操作是委托给<code>ReferenceQueue</code>完成，这里的逻辑有点绕</strong>。<code>ReferenceQueue</code>的源码比较少，这里全量贴出标注一下注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceQueue</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部类Null类继承自ReferenceQueue，覆盖了enqueue方法返回false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Null</span> <span class="keyword">extends</span> <span class="title">ReferenceQueue</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;?&gt; r)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ReferenceQueue.NULL和ReferenceQueue.ENQUEUED都是内部类Null的新实例</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; NULL = <span class="keyword">new</span> Null();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; ENQUEUED = <span class="keyword">new</span> Null();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类，作为锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="comment">// 锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="comment">// 引用链表的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Reference&lt;? extends T&gt; head;</span><br><span class="line">    <span class="comment">// 引用队列长度，入队则增加1，出队则减少1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> queueLength = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作，只会被Reference实例调用</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(Reference&lt;? extends T&gt; r)</span> </span>&#123; <span class="comment">/* Called only by Reference class */</span></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// Check that since getting the lock this reference hasn't already been</span></span><br><span class="line">            <span class="comment">// enqueued (and even then removed)</span></span><br><span class="line">            <span class="comment">// 如果引用实例持有的队列为ReferenceQueue.NULL或者ReferenceQueue.ENQUEUED则入队失败返回false</span></span><br><span class="line">            ReferenceQueue&lt;?&gt; queue = r.queue;</span><br><span class="line">            <span class="keyword">if</span> ((queue == NULL) || (queue == ENQUEUED)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">assert</span> queue == <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Self-loop end, so if a FinalReference it remains inactive.</span></span><br><span class="line">            <span class="comment">// 如果链表没有元素，则此引用实例直接作为头节点，否则把前一个引用实例作为下一个节点</span></span><br><span class="line">            r.next = (head == <span class="keyword">null</span>) ? r : head;</span><br><span class="line">            <span class="comment">// 当前实例更新为头节点，也就是每一个新入队的引用实例都是作为头节点，已有的引用实例会作为后继节点</span></span><br><span class="line">            head = r;</span><br><span class="line">            <span class="comment">// 队列长度增加1</span></span><br><span class="line">            queueLength++;</span><br><span class="line">            <span class="comment">// Update r.queue *after* adding to list, to avoid race</span></span><br><span class="line">            <span class="comment">// with concurrent enqueued checks and fast-path poll().</span></span><br><span class="line">            <span class="comment">// Volatiles ensure ordering.</span></span><br><span class="line">            <span class="comment">// 当前引用实例已经入队，那么它本身持有的引用队列实例置为ReferenceQueue.ENQUEUED</span></span><br><span class="line">            r.queue = ENQUEUED;</span><br><span class="line">            <span class="comment">// 特殊处理FinalReference，VM进行计数</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                VM.addFinalRefCount(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">            lock.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用队列的poll操作，此方法必须在加锁情况下调用</span></span><br><span class="line">    <span class="keyword">private</span> Reference&lt;? extends T&gt; reallyPoll() &#123;       <span class="comment">/* Must hold lock */</span></span><br><span class="line">        Reference&lt;? extends T&gt; r = head;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.queue = NULL;</span><br><span class="line">            <span class="comment">// Update r.queue *before* removing from list, to avoid</span></span><br><span class="line">            <span class="comment">// race with concurrent enqueued checks and fast-path</span></span><br><span class="line">            <span class="comment">// poll().  Volatiles ensure ordering.</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Reference&lt;? extends T&gt; rn = r.next;</span><br><span class="line">            <span class="comment">// Handle self-looped next as end of list designator.</span></span><br><span class="line">            <span class="comment">// 更新next节点为头节点，如果next节点为自身，说明已经走过一次出队，则返回null</span></span><br><span class="line">            head = (rn == r) ? <span class="keyword">null</span> : rn;</span><br><span class="line">            <span class="comment">// Self-loop next rather than setting to null, so if a</span></span><br><span class="line">            <span class="comment">// FinalReference it remains inactive.</span></span><br><span class="line">            <span class="comment">// 当前头节点变更为环状队列，考虑到FinalReference尚为inactive和避免重复出队的问题</span></span><br><span class="line">            r.next = r;</span><br><span class="line">            <span class="comment">// 队列长度减少1</span></span><br><span class="line">            queueLength--;</span><br><span class="line">            <span class="comment">// 特殊处理FinalReference，VM进行计数</span></span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> FinalReference) &#123;</span><br><span class="line">                VM.addFinalRefCount(-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列的公有poll操作，主要是加锁后调用reallyPoll</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; poll() &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> reallyPoll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除引用队列中的下一个引用元素，实际上也是依赖于reallyPoll的Object提供的阻塞机制</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; remove(<span class="keyword">long</span> timeout)</span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            Reference&lt;? extends T&gt; r = reallyPoll();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">long</span> start = (timeout == <span class="number">0</span>) ? <span class="number">0</span> : System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                lock.wait(timeout);</span><br><span class="line">                r = reallyPoll();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">                <span class="keyword">if</span> (timeout != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">                    timeout -= (end - start) / <span class="number">1000_000</span>;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    start = end;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// remove，超时时间为0，实际上就是lock.wait(0)就是永久阻塞直至唤醒</span></span><br><span class="line">    <span class="keyword">public</span> Reference&lt;? extends T&gt; remove() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// foreach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Reference&lt;? extends T&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Reference&lt;? extends T&gt; r = head; r != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            action.accept(r);</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Reference&lt;? extends T&gt; rn = r.next;</span><br><span class="line">            <span class="keyword">if</span> (rn == r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.queue == ENQUEUED) &#123;</span><br><span class="line">                    <span class="comment">// still enqueued -&gt; we reached end of chain</span></span><br><span class="line">                    r = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// already dequeued: r.queue == NULL; -&gt;</span></span><br><span class="line">                    <span class="comment">// restart from head when overtaken by queue poller(s)</span></span><br><span class="line">                    r = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// next in chain</span></span><br><span class="line">                r = rn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReferenceQueue</code>的源码十分简单，还是重新提一下，它只存储了<code>Reference</code>链表的头节点，真正的<code>Reference</code>链表的所有节点是存储在<code>Reference</code>实例本身，通过属性next拼接的，<code>ReferenceQueue</code>提供了对<code>Reference</code>链表的入队、poll、remove等操作。</p>
<h2 id="判断对象的可达性和对象是否存活">判断对象的可达性和对象是否存活</h2>
<p>判断对象的可达性和对象是否存活是两个比较困难的问题，笔者C语言学得比较烂，否则会重点翻看一下JVM的实现，目前只能参考一些资料来说明这个问题。</p>
<h3 id="可达性算法">可达性算法</h3>
<p>主流商用语言包括Java都是使用可达性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路是通过一系列的称为&quot;GC Roots&quot;(GC根集)的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC根集没有任何引用链相连(从图论的角度看，也就是从GC根集到这个对象是不可达的)时，则证明此对象是不可用的。不可用的对象&quot;<strong>有机会</strong>&quot;被判定为可以回收的对象。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201901/j-d-k-r-3.png" alt="j-d-k-r-3"></p>
<p>在Java语言中，可以作为GC根集的对象包括下面几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li>
<li>方法区中常量引用的对象(在JDK1.8之后不存在方法区，也就是有可能是metaspace中常量引用的对象)。</li>
<li>本地方法栈中JNI(即一般常说的Native方法)引用的对象。</li>
</ul>
<h3 id="finalize函数">finalize函数</h3>
<p>即使在可达性分析算法中判定为不可达的对象，也并非一定会判定为可以被回收的&quot;死亡&quot;对象。一个对象判定为&quot;死亡&quot;至少需要经历<strong>两次标记</strong>的过程。</p>
<p><strong>第一次标记</strong>：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。JVM会把以下两种情况认为对象没有必要执行<code>finalize()</code>方法：</p>
<ul>
<li>对象没有覆盖继承自Object类的<code>finalize()</code>方法。</li>
<li>对象的<code>finalize()</code>方法已经被JVM调用过。</li>
</ul>
<p>如果一个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个叫<code>F-Queue</code>的队列之中，并且稍后由一个优先级低的Finalizer线程去取该队列的元素，&quot;尝试执行&quot;元素的<code>finalize()</code>方法。这里之所以叫尝试执行是因为JVM会保证触发满足条件的对象的<code>finalize()</code>方法，但是并不承诺会等待它执行结束，这是因为：如果一个对象在执行<code>finalize()</code>方法耗时较长，甚至发生了死循环，将会导致<code>F-Queue</code>的队列中的其他元素永远处于等待状态，<strong>极端情况下有可能导致整个内存回收系统崩溃</strong>。</p>
<p><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会，因为稍后的GC将会对<code>F-Queue</code>队列中的对象进行<strong>第二次小规模的标记</strong>，如果对象在<code>finalize()</code>方法执行过程中成功拯救自己–也就是对象自身重新与引用链的任何一个对象建立关联即可，最常见的就是把自身(this关键字)赋值给某个类变量或者对象的成员属性，那么在第二次小规模的标记时候将会把&quot;自我拯救&quot;成功的对象移出&quot;即将回收&quot;的集合。如果对象在<code>finalize()</code>方法执行过程中没有&quot;逃逸&quot;，那么它最终就会被回收。参考《深入理解Java虚拟机-2nd》的&quot;对象自我拯救的例子&quot;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> FinalizeEscapeGc SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Yes,I am still alive :)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGc();</span><br><span class="line"></span><br><span class="line">		SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"No,I am not alive :("</span>);</span><br><span class="line">		&#125;</span><br><span class="line">                <span class="comment">// 下面的这段代码和上面的一致</span></span><br><span class="line">		SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"No,I am not alive :("</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.finalize();</span><br><span class="line">		System.out.println(<span class="string">"FinalizeEscapeGc finalize invoke..."</span>);</span><br><span class="line">		FinalizeEscapeGc.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">FinalizeEscapeGc finalize invoke...</span><br><span class="line">Yes,I am still alive :)</span><br><span class="line">No,I am not alive :(</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>finalize()</code>方法的错误使用有可能是内存回收系统崩溃的根源，一般情况下谨慎思考是否真的需要覆盖此方法。</li>
<li>任意一个对象只能通过<code>finalize()</code>方法自我拯救一次。</li>
</ul>
<h3 id="Finalizer守护线程">Finalizer守护线程</h3>
<p>前面提到的<code>Finalizer</code>守护线程和<code>F-Queue</code>队列其实在JDK中有具体的实现类<code>java.lang.ref.Finalizer</code>。<code>F-Queue</code>队列只是《深入理解Java虚拟机-2nd》中的一个名词描述，实际上笔者没有找到相关的资料，这里我们通过分析JDK和JVM相关的源码去理解这个<code>F-Queue</code>队列吧。先看<code>java.lang.ref.Finalizer</code>的源码，代码比较少全量贴出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalizer</span> <span class="keyword">extends</span> <span class="title">FinalReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123; <span class="comment">/* Package-private; must be in</span></span><br><span class="line"><span class="comment">                                                          same package as the Reference</span></span><br><span class="line"><span class="comment">                                                          class */</span></span><br><span class="line">    <span class="comment">// Finalizer关联的ReferenceQueue，其实Finalizer是一个特殊的Reference实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Head of doubly linked list of Finalizers awaiting finalization. */</span></span><br><span class="line">    <span class="comment">// 等待finalization的所有Finalizer实例链表的头节点，这里称此链表为unfinalized链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Finalizer unfinalized = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock guarding access to unfinalized list. */</span></span><br><span class="line">    <span class="comment">// unfinalized链表的锁，静态final，全局的锁实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中间变量，分别记录unfinalized链表中当前执行元素的下一个节点和前一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Finalizer next, prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Finalizer</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(finalizee, queue);</span><br><span class="line">        <span class="comment">// push onto unfinalized</span></span><br><span class="line">        <span class="comment">// 这里主要是更新unfinalized链表的头节点，新增的元素总是会变成头节点</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unfinalized != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.next = unfinalized;</span><br><span class="line">                unfinalized.prev = <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unfinalized = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ReferenceQueue&lt;Object&gt; <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoked by VM */</span> 这个方法由JVM激活，也就是链表的元素入队是由JVM控制的，见下文分析</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object finalizee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Finalizer(finalizee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runFinalizer</span><span class="params">(JavaLangAccess jla)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 当前元素已经处理过，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.next == <span class="keyword">this</span>)      <span class="comment">// already finalized</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// unlink from unfinalized</span></span><br><span class="line">            <span class="comment">// 下面的逻辑是当前需要执行的元素从链表中移除，并且更新prev和next的值，相当于重建链表的部分节点</span></span><br><span class="line">            <span class="keyword">if</span> (unfinalized == <span class="keyword">this</span>)</span><br><span class="line">                unfinalized = <span class="keyword">this</span>.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">this</span>.prev.next = <span class="keyword">this</span>.next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.next != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.next.prev = <span class="keyword">this</span>.prev;</span><br><span class="line">            <span class="keyword">this</span>.prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.next = <span class="keyword">this</span>;           <span class="comment">// mark as finalized</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取对象执行一次finalize方法</span></span><br><span class="line">            Object finalizee = <span class="keyword">this</span>.get();</span><br><span class="line">            <span class="keyword">if</span> (finalizee != <span class="keyword">null</span> &amp;&amp; !(finalizee <span class="keyword">instanceof</span> java.lang.Enum)) &#123;</span><br><span class="line">                jla.invokeFinalize(finalizee);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clear stack slot containing this variable, to decrease</span></span><br><span class="line">                <span class="comment">// the chances of false retention with a conservative GC</span></span><br><span class="line">                <span class="comment">// 清空变量引用从而减少保守GC导致变量保留的可能性</span></span><br><span class="line">                finalizee = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable x) &#123; &#125;</span><br><span class="line">        <span class="comment">// 执行完毕会做一次情况防止重复执行</span></span><br><span class="line">        <span class="keyword">super</span>.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create a privileged secondary finalizer thread in the system thread</span></span><br><span class="line"><span class="comment">     * group for the given Runnable, and wait for it to complete.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method is used by runFinalization.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It could have been implemented by offloading the work to the</span></span><br><span class="line"><span class="comment">     * regular finalizer thread and waiting for that thread to finish.</span></span><br><span class="line"><span class="comment">     * The advantage of creating a fresh thread, however, is that it insulates</span></span><br><span class="line"><span class="comment">     * invokers of that method from a stalled or deadlocked finalizer thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 这里其实不用畏惧注释太多，它只是一个候选方法，新建一个线程直接调用包裹在Runnable的runFinalization方法，主要是提供给主动调用的上层方法调用的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkSecondaryFinalizer</span><span class="params">(<span class="keyword">final</span> Runnable proc)</span> </span>&#123;</span><br><span class="line">        AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">                    <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">                         tgn != <span class="keyword">null</span>;</span><br><span class="line">                         tg = tgn, tgn = tg.getParent());</span><br><span class="line">                    Thread sft = <span class="keyword">new</span> Thread(tg, proc, <span class="string">"Secondary finalizer"</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">                    sft.start();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        sft.join();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Called by Runtime.runFinalization() */</span></span><br><span class="line">    <span class="comment">// 这个方法是给Runtime.runFinalization()委托调用的，其实就是主动取出queue的元素强制调用其finalize方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runFinalization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (VM.initLevel() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        forkSecondaryFinalizer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// in case of recursive call to run()</span></span><br><span class="line">                <span class="keyword">if</span> (running)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class="line">                running = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (Finalizer f; (f = (Finalizer)queue.poll()) != <span class="keyword">null</span>;)</span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正的Finalizer线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running;</span><br><span class="line">        FinalizerThread(ThreadGroup g) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g, <span class="keyword">null</span>, <span class="string">"Finalizer"</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// in case of recursive call to run()</span></span><br><span class="line">            <span class="keyword">if</span> (running)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Finalizer thread starts before System.initializeSystemClass</span></span><br><span class="line">            <span class="comment">// is called.  Wait until JavaLangAccess is available</span></span><br><span class="line">            <span class="keyword">while</span> (VM.initLevel() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// delay until VM completes initialization</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    VM.awaitInitLevel(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">// ignore and continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> JavaLangAccess jla = SharedSecrets.getJavaLangAccess();</span><br><span class="line">            running = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 注意这里是死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 注意这里是调用`Reference#remove()`的永久阻塞版本，只有`Reference#enqueue()`被调用才会解除阻塞</span></span><br><span class="line">                    <span class="comment">// `Reference#remove()`解除阻塞说明元素已经完成入队，由ReferenceHandler线程完成</span></span><br><span class="line">                    Finalizer f = (Finalizer)queue.remove();</span><br><span class="line">                    <span class="comment">// 实际上就是调用对象的finalize方法</span></span><br><span class="line">                    f.runFinalizer(jla);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                    <span class="comment">// ignore and continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">             tgn != <span class="keyword">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        <span class="comment">// 静态代码块中声明线程，优先级是最高优先级-2，守护线程，实际上这里优先级不一定会生效</span></span><br><span class="line">        Thread finalizer = <span class="keyword">new</span> FinalizerThread(tg);</span><br><span class="line">        finalizer.setPriority(Thread.MAX_PRIORITY - <span class="number">2</span>);</span><br><span class="line">        finalizer.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        finalizer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的注释已经很明显标注出来，这里小结一下内容。</p>
<ul>
<li><code>Finalizer</code>是<code>FinalReference</code>的子类，而<code>FinalReference</code>是<code>Reference</code>的实现，所以它的工作原理和其他引用类似，对象的状态更变和由ReferenceHandler线程密切相关。</li>
<li><code>Finalizer</code>内部维护了一个链表，每当JVM调用静态注册方法就会新建一个<code>Finalizer</code>实例加入到链表的头节点中，头节点元素为unfinalized，这里称此链表为unfinalized链表。</li>
<li><code>Finalizer</code>线程由<code>Finalizer</code>静态代码块构建并且运行，它是守护线程，优先级是最高优先级-2，它的作用就是提取unfinalized链表的元素并且执行元素对象的<code>finalize()</code>方法，过程中还会涉及到线程的阻塞、唤醒，以及unfinalized链表的重建等工作。</li>
</ul>
<p>由于静态方法<code>Finalizer#register(Object finalizee)</code>是由JVM调用的，所以我们必须要分析一些JVM的源码，参考的是OpenJDK主分支的代码，文件是<code>instanceKlass.cpp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">instanceOop <span class="title">InstanceKlass::register_finalizer</span><span class="params">(instanceOop i, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (TraceFinalizerRegistration) &#123;</span><br><span class="line">    tty-&gt;<span class="built_in">print</span>(<span class="string">"Registered "</span>);</span><br><span class="line">    i-&gt;print_value_on(tty);</span><br><span class="line">    tty-&gt;print_cr(<span class="string">" ("</span> INTPTR_FORMAT <span class="string">") as finalizable"</span>, p2i(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">instanceHandle <span class="title">h_i</span><span class="params">(THREAD, i)</span></span>;</span><br><span class="line">  <span class="comment">// Pass the handle as argument, JavaCalls::call expects oop as jobjects</span></span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  <span class="function">JavaCallArguments <span class="title">args</span><span class="params">(h_i)</span></span>;</span><br><span class="line">  <span class="comment">// 这里Universe::finalizer_register_method()获取到的就是Finalizer#register方法句柄</span></span><br><span class="line">  <span class="function">methodHandle <span class="title">mh</span> <span class="params">(THREAD, Universe::finalizer_register_method())</span></span>;</span><br><span class="line">  JavaCalls::call(&amp;result, mh, &amp;args, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> h_i();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用的是<code>javaCalls.cpp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaCalls::call</span><span class="params">(JavaValue* result, <span class="keyword">const</span> methodHandle&amp; method, JavaCallArguments* args, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check if we need to wrap a potential OS exception handler around thread</span></span><br><span class="line">  <span class="comment">// This is used for e.g. Win32 structured exception handlers</span></span><br><span class="line">  assert(THREAD-&gt;is_Java_thread(), <span class="string">"only JavaThreads can make JavaCalls"</span>);</span><br><span class="line">  <span class="comment">// Need to wrap each and every time, since there might be native code down the</span></span><br><span class="line">  <span class="comment">// stack that has installed its own exception handlers</span></span><br><span class="line">  os::os_exception_wrapper(call_helper, result, method, args, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来看就是把创建对象过程中，如果有必要注册<code>Finalizer</code>(一般是覆盖了<code>finalize()</code>方法)，则基于当前线程通过<code>Finalizer#register(Object finalizee)</code>把当前新建的实例注册到<code>Finalizer</code>自身维护的链表中(如果没理解错，所谓的<code>F-Queue</code>就是这个链表了)，等待后台<code>Finalizer</code>线程轮询并且执行链表中对象的<code>finalize()</code>方法。</p>
<h2 id="各类引用以及它们的使用场景">各类引用以及它们的使用场景</h2>
<p>这里提到的各类引用目前就是四种：强引用(StrongReference)、软引用(SoftReference)、弱引用(WeakReference)和虚引用(PhantomReference)。其实还有特殊的引用类型<code>FinalReference</code>，它是包私有的，并且只有一个子类型<code>Finalizer</code>。</p>
<h3 id="StrongReference">StrongReference</h3>
<p>StrongReference也就是强引用，它是使用最普遍的一种引用，<code>java.lang.ref</code>包下没有强引用对应的类型。一个比较明确的强引用定义就是：所有和GC Root之间存在引用链的对象都具备强引用。举个简单例子：形如<code>Object o = new Object();</code>在方法体中使用new关键字声明的对象一般就是强引用。如果一个对象具备强引用，垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>错误，使程序异常终止，也不会出现回收具有强引用的对象来解决内存不足的情况。当然，如果有共享的成员变量在方法退出之前置为null，相当于断绝成员变量和GC Root的引用链，在合适的时机是有利于GC后具备强引用的对象的回收，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object shareValue = XXX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    shareValue = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来有人过度信奉类似上面的这个实践，出现了一条比较诡异的编码实践：强引用使用完毕后都要置为null方便对象回收。但是实际上，这个实践并不是在任何场景都是合理的。</p>
<h3 id="SoftReference">SoftReference</h3>
<p>SoftReference也就是软引用，它是用来描述一些&quot;还有用但是非必须&quot;的对象。对于软引用关联着的对象，在JVM应用即将发生内存溢出异常之前，将会把这些软引用关联的对象列进去回收对象范围之中进行第二次回收。如果这次回收之后还是没有足够的内存，才会抛出内存溢出异常。简单来说就是：</p>
<ul>
<li>如果内存空间足够，垃圾回收器就不会回收软引用关联着的对象。</li>
<li>如果内存空间不足，垃圾回收器在将要抛出内存溢出异常之前会回收软引用关联着的对象。</li>
</ul>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VM参数：-Xmx4m -Xms4m</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ReferenceQueue&lt;SoftReferenceObject&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">		SoftReferenceObject object = <span class="keyword">new</span> SoftReferenceObject();</span><br><span class="line">		SoftReference&lt;SoftReferenceObject&gt; reference = <span class="keyword">new</span> SoftReference&lt;&gt;(object, queue);</span><br><span class="line">		object = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		System.out.println(reference.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">120_000</span>];</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"SoftReferenceObject"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行后输出结果</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>上面的例子故意把JVM的启动的最大Heap内存和初始Heap内存设置为4MB，使用这个对象初始化一个比较大的整型数组并且关系到一个软引用对象中，GC之后，发现软引用关联的对象被回收了。</p>
<h3 id="WeakReference">WeakReference</h3>
<p>WeakReference也就是弱引用，弱引用和软引用类似，它是用来描述&quot;非必须&quot;的对象的，它的强度比软引用要更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，简言之就是：一旦发生GC必定回收被弱引用关联的对象，不管当前的内存是否足够。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ReferenceQueue&lt;WeakReferenceObject&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">		WeakReferenceObject object = <span class="keyword">new</span> WeakReferenceObject();</span><br><span class="line">		System.out.println(object);</span><br><span class="line">		WeakReference&lt;WeakReferenceObject&gt; reference = <span class="keyword">new</span> WeakReference&lt;&gt;(object, queue);</span><br><span class="line">		object = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		System.out.println(reference.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"WeakReferenceObject"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行后输出结果</span></span><br><span class="line">WeakReferenceObject</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中没有设定JVM的堆内存，因此不存在内存不足的情况，可见弱引用关联的对象在GC之后被回收了。弱引用适合用来做对内存敏感的缓存，很常用的<code>WeakHashMap</code>就是基于弱引用实现的。</p>
<h3 id="PhantomReference">PhantomReference</h3>
<p>PhantomReference也就是虚引用，也叫幽灵引用或者幻影引用，它是所有引用类型中最弱的一种。一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例(<code>PhantomReference</code>覆盖了<code>Reference#get()</code>并且总是返回null)。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个<strong>系统通知</strong>。<code>PhantomReference</code>有两个比较常用的子类是<code>java.lang.ref.Cleaner</code>和<code>jdk.internal.ref.Cleaner</code>，其中前者提供的功能是开发者用于在引用对象回收的时候触发一个动作(<code>java.lang.ref.Cleaner$Cleanable</code>)，后者用于<code>DirectByteBuffer</code>对象回收的时候对于堆外内存的回收，可以翻看前面描述<code>java.lang.ref.Reference#processPendingReferences()</code>源码的时候，ReferenceHandler线程会对pending链表中的<code>jdk.internal.ref.Cleaner</code>类型引用对象调用其<code>clean()</code>方法。<code>PhantomReference</code>本身使用场景比较少，这里举一下<code>java.lang.ref.Cleaner</code>注释中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (CleaningExample o = <span class="keyword">new</span> CleaningExample(<span class="number">11</span>))&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		CleaningExample o2 = <span class="keyword">new</span> CleaningExample(<span class="number">22</span>);</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CleaningExample</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Cleaner cleaner = Cleaner.create();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CleaningExample</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">		state = <span class="keyword">new</span> State(s);</span><br><span class="line">		cleanable = cleaner.register(<span class="keyword">this</span>, state);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.s = s;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"State runnable in action.State value = "</span> + s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		cleanable.clean();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，沙面的代码执行完毕只会输出&quot;State runnable in action.State value = 11&quot;，并没有输出&quot;State runnable in action.State value = 22&quot;，这是因为无法预测强引用对象被回收的时机。<code>java.lang.ref.Cleaner</code>主要是用于预防实现了<code>AutoCloseable</code>接口的实例忘记调用<code>close()</code>方法在对象被垃圾收集器回收的时候(内存回收)做一个兜底的清理工作，在JDK9之后，<code>java.lang.ref.Cleaner</code>主要是为了替代已经标识为过期的<code>Object#finalize()</code>方法。</p>
<p>扩展阅读：可以注意阅读一下《Effective Java 3rd》的第8小节，摘抄部分内容如下：终结方法（Finalizer）是不可预知的，很多时候是危险的，而且一般情况下是不必要的。…在Java 9中，终结方法已经被遗弃了，但它们仍被Java类库使用，相应用来替代终结方法的是清理方法（cleaner）。比起终结方法，清理方法相对安全点，但仍是不可以预知的，运行慢的，而且一般情况下是不必要的。</p>
<p>JDK9中有很多原来使用覆盖<code>Object#finalize()</code>方法的清理工作实现都替换为<code>java.lang.ref.Cleaner</code>，但是仍然不鼓励使用这种方式。</p>
<h2 id="Reference和ReferenceQueue配合使用">Reference和ReferenceQueue配合使用</h2>
<p>前面基本介绍完了所有类型引用以及相关的源码，但是尚未提供例子说明<code>Reference</code>和<code>ReferenceQueue</code>是怎么配合使用的。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ReferenceQueue&lt;WeakReferenceObject&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">		WeakReferenceObject object = <span class="keyword">new</span> WeakReferenceObject();</span><br><span class="line">		WeakReference&lt;WeakReferenceObject&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(object, queue);</span><br><span class="line">		System.out.println(weakReference);</span><br><span class="line">		object = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Reference&lt;? extends WeakReferenceObject&gt; reference = queue.poll();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == reference) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(reference);</span><br><span class="line">				System.out.println(reference.get());</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"WeakReferenceObject"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出结果是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ref.WeakReference@<span class="number">6537</span>cf78</span><br><span class="line">java.lang.ref.WeakReference@<span class="number">6537</span>cf78</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>可见轮询<code>ReferenceQueue</code>实例得到的弱引用实例和创建的是一致的，只是它持有的关联的对象已经被回收，得到null。上面的<code>ReferenceQueue#poll()</code>方法也可以替换为<code>ReferenceQueue#remove()</code>，这样子就不用写在死循环中，因为<code>ReferenceQueue#remove()</code>会阻塞到有元素可以出队。通过轮询绑定到<code>Reference</code>实例的<code>ReferenceQueue</code>实例，就可以得知<code>Reference</code>实例当前的状态并且判断它关联的我们真正关注的对象是否被回收。</p>
<h2 id="小结">小结</h2>
<ul>
<li><code>Reference</code>是<strong>非强引用</strong>的其他三种引用的共同父类。</li>
<li><code>ReferenceQueue</code>只存储了引用链表的头节点，提供了引用链表的操作，实际上，引用链表是<code>Reference</code>实例内部变量存储的。</li>
<li>ReferenceHandler守护线程线程由<code>Reference</code>的静态代码块创建和运行，作用是处理pending链表的引用元素使之状态变更，伴随着<code>ReferenceQueue</code>的相关操作。</li>
<li>Finalizer守护线程是由<code>Finalizer</code>类的静态代码块创建和运行的，作用是处理<code>Finalizer</code>类内部维护的F-Queue链表(链表元素入队操作由JVM实现)的元素调用关联对象的<code>finalize()</code>方法。</li>
<li>ReferenceHandler守护线程线和Finalizer守护线程共同协作才能使引用类型对象内存回收系统的工作能够正常进行。</li>
</ul>
<p><strong>四种引用类型的总结</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">引用类型</th>
<th style="text-align:center">被垃圾收集器回收的时机</th>
<th style="text-align:center">主要用途</th>
<th style="text-align:center">生存周期</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">强引用</td>
<td style="text-align:center">直到内存溢出也不会回收</td>
<td style="text-align:center">普遍对象的状态</td>
<td style="text-align:center">从创建到JVM实例终止运行</td>
</tr>
<tr>
<td style="text-align:center">软引用</td>
<td style="text-align:center">垃圾回收并且内存不足时</td>
<td style="text-align:center">有用但非必须的对象缓存</td>
<td style="text-align:center">从创建到垃圾回收并且内存不足时</td>
</tr>
<tr>
<td style="text-align:center">弱引用</td>
<td style="text-align:center">垃圾回收时</td>
<td style="text-align:center">非必须的对象缓存</td>
<td style="text-align:center">上一次垃圾回收结束到下一次垃圾回收开始</td>
</tr>
<tr>
<td style="text-align:center">虚引用</td>
<td style="text-align:center">-</td>
<td style="text-align:center">关联的对象被垃圾收集器回收时候得到一个系统通知</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>参考资料：</p>
<ul>
<li>JDK11部分源码。</li>
<li>《深入理解Java虚拟机-2nd》- 这本书算是国内书籍写得比较良心的一本了，不过有很多小的问题或者笔误之处，需要自行发现和修正。</li>
</ul>
<p>(过年比较懒，很久没发文 e-a-20190215 c-14-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reference/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reference</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/08/java-jsr310-framework-integration/">
      JSR310新日期API(五)-在主流框架中使用新日期时间类
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月8日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：11分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-08T00:03:12+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(五)-在主流框架中使用新日期时间类</h1>
<h2 id="前提">前提</h2>
<p>前面的几篇文章已经基本介绍完了JSR-310日期时间类库的基本使用，这篇文章主要介绍在主流的框架中如何使用这些类库。因为涉及到数据库操作，先准备好一张表和对应的实体。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user`</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">'主键'</span>,</span><br><span class="line">  username <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  birthday <span class="built_in">DATE</span> <span class="keyword">COMMENT</span> <span class="string">'生日'</span>,</span><br><span class="line">  create_time DATETIME <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="keyword">KEY</span> idx_name(<span class="string">`username`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> idx_create_time(<span class="string">`create_time`</span>)</span><br><span class="line">)<span class="keyword">COMMENT</span> <span class="string">'用户表'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> LocalDate birthday;</span><br><span class="line">   <span class="keyword">private</span> OffsetDateTime createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如果不考虑时区的影响，createTime也可以使用<code>LocalDateTime</code>类型。另外，为了连接测试数据库，这里引入’光’连接池的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="JDBC中使用JSR-310日期时间类库">JDBC中使用JSR-310日期时间类库</h2>
<p>说实话，由于JDBC类库在方法参数或者返回值类型很久没更新，对于带日期时间的属性，统一使用<code>java.sql.Timestamp</code>类型，对于日期类型的属性则统一使用<code>java.sql.Date</code>，因此需要进行类型转换。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HikariConfig config = <span class="keyword">new</span> HikariConfig();</span><br><span class="line">		config.setMaximumPoolSize(<span class="number">10</span>);</span><br><span class="line">		config.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?useSSL=false&amp;characterEncoding=utf8"</span>);</span><br><span class="line">		config.setUsername(<span class="string">"root"</span>);</span><br><span class="line">		config.setPassword(<span class="string">"root"</span>);</span><br><span class="line">		config.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		DataSource dataSource = <span class="keyword">new</span> HikariDataSource(config);</span><br><span class="line">		Connection connection = dataSource.getConnection();</span><br><span class="line">		connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">		PreparedStatement p = connection.prepareStatement(<span class="string">"INSERT INTO t_user(id,username,birthday,create_time) VALUES (?,?,?,?)"</span>);</span><br><span class="line">		p.setLong(<span class="number">1</span>, <span class="number">1L</span>);</span><br><span class="line">		p.setString(<span class="number">2</span>, <span class="string">"Throwable"</span>);</span><br><span class="line">		p.setDate(<span class="number">3</span>, Date.valueOf(LocalDate.of(<span class="number">1993</span>, <span class="number">3</span>, <span class="number">10</span>)));</span><br><span class="line">		p.setTimestamp(<span class="number">4</span>, Timestamp.from(OffsetDateTime.now().toInstant()));</span><br><span class="line">		<span class="comment">//LocalDateTime -&gt; p.setTimestamp(4, Timestamp.from(LocalDateTime.now()));</span></span><br><span class="line">		<span class="keyword">int</span> updateCount = p.executeUpdate();</span><br><span class="line">		connection.commit();</span><br><span class="line">		System.out.println(String.format(<span class="string">"更新数据%d条"</span>, updateCount));</span><br><span class="line">		p = connection.prepareStatement(<span class="string">"SELECT * FROM t_user WHERE id = ?"</span>);</span><br><span class="line">		p.setLong(<span class="number">1</span>, <span class="number">1L</span>);</span><br><span class="line">		ResultSet resultSet = p.executeQuery();</span><br><span class="line">		User user = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (resultSet.next()) &#123;</span><br><span class="line">			user = <span class="keyword">new</span> User();</span><br><span class="line">			user.setId(resultSet.getLong(<span class="string">"id"</span>));</span><br><span class="line">			user.setName(resultSet.getString(<span class="string">"username"</span>));</span><br><span class="line">			user.setBirthday(resultSet.getDate(<span class="string">"birthday"</span>).toLocalDate());</span><br><span class="line">			user.setCreateTime(OffsetDateTime.ofInstant(resultSet.getTimestamp(<span class="string">"create_time"</span>).toInstant(), ZoneId.systemDefault()));</span><br><span class="line">			<span class="comment">//LocalDateTime -&gt; user.setCreateTime(resultSet.getTimestamp("create_time").toLocalDateTime());</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">更新数据<span class="number">1</span>条</span><br><span class="line">User(id=<span class="number">1</span>, name=Throwable, birthday=<span class="number">1993</span>-<span class="number">03</span>-<span class="number">10</span>, createTime=<span class="number">2019</span>-<span class="number">01</span>-<span class="number">06</span>T23:<span class="number">09</span>:<span class="number">01</span>+<span class="number">08</span>:<span class="number">00</span>)</span><br></pre></td></tr></table></figure>
<p>除了需要做少量类型转换，没有其他的兼容性问题。</p>
<h2 id="Mybatis中使用JSR-310日期时间类库">Mybatis中使用JSR-310日期时间类库</h2>
<p>既然JDBC已经可以使用JSR-310的日期时间类库，那么基于JDBC封装的ORM框架必定也可以支持。除了需要引入Mybatis本身的依赖，还需要引入mybatis-typehandlers-jsr310依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-typehandlers-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新建一个Mapper接口类<code>UserMapper</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Insert</span>(<span class="string">"INSERT INTO t_user(id,username,birthday,create_time) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;birthday&#125;,#&#123;createTime&#125;)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Select</span>(<span class="string">"SELECT id,username as name,birthday,create_time as createTime FROM t_user WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function">User <span class="title">selectById</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HikariConfig config = <span class="keyword">new</span> HikariConfig();</span><br><span class="line">		config.setMaximumPoolSize(<span class="number">10</span>);</span><br><span class="line">		config.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?useSSL=false&amp;characterEncoding=utf8"</span>);</span><br><span class="line">		config.setUsername(<span class="string">"root"</span>);</span><br><span class="line">		config.setPassword(<span class="string">"root"</span>);</span><br><span class="line">		config.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		DataSource dataSource = <span class="keyword">new</span> HikariDataSource(config);</span><br><span class="line">		TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">		Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">		Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">		configuration.addMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">		UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		User user = <span class="keyword">new</span> User();</span><br><span class="line">		user.setId(<span class="number">1L</span>);</span><br><span class="line">		user.setCreateTime(OffsetDateTime.now());</span><br><span class="line">		user.setBirthday(LocalDate.of(<span class="number">1993</span>, <span class="number">3</span>, <span class="number">10</span>));</span><br><span class="line">		user.setName(<span class="string">"Throwable"</span>);</span><br><span class="line">		<span class="keyword">int</span> updateCount = userMapper.insert(user);</span><br><span class="line">		System.out.println(String.format(<span class="string">"更新数据%d条"</span>, updateCount));</span><br><span class="line">		sqlSession.commit();</span><br><span class="line">		User result = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">		sqlSession.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">更新数据<span class="number">1</span>条</span><br><span class="line">User(id=<span class="number">1</span>, name=Throwable, birthday=<span class="number">1993</span>-<span class="number">03</span>-<span class="number">10</span>, createTime=<span class="number">2019</span>-<span class="number">01</span>-<span class="number">06</span>T23:<span class="number">30</span>:<span class="number">09</span>+<span class="number">08</span>:<span class="number">00</span>)</span><br></pre></td></tr></table></figure>
<p>虽然多引入了一个依赖，但是使用起来十分简单，甚至可以做到开发态无感知，Mybatis这一点做得比较完善。</p>
<h2 id="Jackson中使用JSR-310日期时间类库">Jackson中使用JSR-310日期时间类库</h2>
<p>Jackson从2.x某个版本中，官方就基于JDK8的新特性开发了第三方类库<a href="https://github.com/FasterXML/jackson-modules-java8" target="_blank" rel="noopener">jackson-modules-java8</a>，这个第三方类库包括三个模块<code>jackson-module-parameter-names</code>、<code>jackson-datatype-jdk8</code>和<code>jackson-datatype-jsr310</code>，这三个模块是独立打包的，可以按需引入。这里做的实例需要引入下面的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在官方文档中已经很详细给出具体的使用例子，这里也简单做一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">		JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">		javaTimeModule.addSerializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateSerializer</span>(<span class="title">DATE_FORMATTER</span>))</span>;</span><br><span class="line">		javaTimeModule.addDeserializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateDeserializer</span>(<span class="title">DATE_FORMATTER</span>))</span>;</span><br><span class="line">		javaTimeModule.addSerializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeSerializer</span>(<span class="title">DATE_TIME_FORMATTER</span>))</span>;</span><br><span class="line">		javaTimeModule.addDeserializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeDeserializer</span>(<span class="title">DATE_TIME_FORMATTER</span>))</span>;</span><br><span class="line">		objectMapper.registerModule(javaTimeModule);</span><br><span class="line">		Sample sample = <span class="keyword">new</span> Sample();</span><br><span class="line">		sample.setLocalDate(LocalDate.now());</span><br><span class="line">		sample.setLocalDateTime(LocalDateTime.now());</span><br><span class="line">		System.out.println(objectMapper.writeValueAsString(sample));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> LocalDate localDate;</span><br><span class="line">		<span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻输出如下</span></span><br><span class="line">&#123;<span class="string">"localDate"</span>:<span class="string">"2019-01-07"</span>,<span class="string">"localDateTime"</span>:<span class="string">"2019-01-07 23:40:12"</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObjectMapper</code>实例中可以注册自定义的<code>JavaTimeModule</code>模块，<code>JavaTimeModule</code>模块中已经存在了不少默认的日期时间类的序列化和反序列化器，必要时可以像上面的例子一样重写对应的日期时间类型的序列化和反序列化器并且覆盖已经配置的默认实现，这样子就能实现我们想要的格式化输出。<code>JavaTimeModule</code>默认的序列化和反序列化器配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JavaTimeModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(PackageVersion.VERSION);</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(Instant<span class="class">.<span class="keyword">class</span>, <span class="title">InstantDeserializer</span>.<span class="title">INSTANT</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(OffsetDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">InstantDeserializer</span>.<span class="title">OFFSET_DATE_TIME</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(ZonedDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">InstantDeserializer</span>.<span class="title">ZONED_DATE_TIME</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(Duration<span class="class">.<span class="keyword">class</span>, <span class="title">DurationDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">LocalDateTimeDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">LocalDateDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(LocalTime<span class="class">.<span class="keyword">class</span>, <span class="title">LocalTimeDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(MonthDay<span class="class">.<span class="keyword">class</span>, <span class="title">MonthDayDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(OffsetTime<span class="class">.<span class="keyword">class</span>, <span class="title">OffsetTimeDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(Period<span class="class">.<span class="keyword">class</span>, <span class="title">JSR310StringParsableDeserializer</span>.<span class="title">PERIOD</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(Year<span class="class">.<span class="keyword">class</span>, <span class="title">YearDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(YearMonth<span class="class">.<span class="keyword">class</span>, <span class="title">YearMonthDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(ZoneId<span class="class">.<span class="keyword">class</span>, <span class="title">JSR310StringParsableDeserializer</span>.<span class="title">ZONE_ID</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addDeserializer(ZoneOffset<span class="class">.<span class="keyword">class</span>, <span class="title">JSR310StringParsableDeserializer</span>.<span class="title">ZONE_OFFSET</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(Duration<span class="class">.<span class="keyword">class</span>, <span class="title">DurationSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(Instant<span class="class">.<span class="keyword">class</span>, <span class="title">InstantSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">LocalDateTimeSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">LocalDateSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(LocalTime<span class="class">.<span class="keyword">class</span>, <span class="title">LocalTimeSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(MonthDay<span class="class">.<span class="keyword">class</span>, <span class="title">MonthDaySerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(OffsetDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">OffsetDateTimeSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(OffsetTime<span class="class">.<span class="keyword">class</span>, <span class="title">OffsetTimeSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(Period<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ToStringSerializer</span>(<span class="title">Period</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(Year<span class="class">.<span class="keyword">class</span>, <span class="title">YearSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(YearMonth<span class="class">.<span class="keyword">class</span>, <span class="title">YearMonthSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(ZonedDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">ZonedDateTimeSerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(ZoneId<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ToStringSerializer</span>(<span class="title">ZoneId</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    <span class="keyword">this</span>.addSerializer(ZoneOffset<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ToStringSerializer</span>(<span class="title">ZoneOffset</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeySerializer(ZonedDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">ZonedDateTimeKeySerializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(Duration<span class="class">.<span class="keyword">class</span>, <span class="title">DurationKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(Instant<span class="class">.<span class="keyword">class</span>, <span class="title">InstantKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">LocalDateTimeKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">LocalDateKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(LocalTime<span class="class">.<span class="keyword">class</span>, <span class="title">LocalTimeKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(MonthDay<span class="class">.<span class="keyword">class</span>, <span class="title">MonthDayKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(OffsetDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">OffsetDateTimeKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(OffsetTime<span class="class">.<span class="keyword">class</span>, <span class="title">OffsetTimeKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(Period<span class="class">.<span class="keyword">class</span>, <span class="title">PeriodKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(Year<span class="class">.<span class="keyword">class</span>, <span class="title">YearKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(YearMonth<span class="class">.<span class="keyword">class</span>, <span class="title">YearMothKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(ZonedDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">ZonedDateTimeKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(ZoneId<span class="class">.<span class="keyword">class</span>, <span class="title">ZoneIdKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">    <span class="keyword">this</span>.addKeyDeserializer(ZoneOffset<span class="class">.<span class="keyword">class</span>, <span class="title">ZoneOffsetKeyDeserializer</span>.<span class="title">INSTANCE</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果熟练掌握Jackson的解析原理和源码，可以尝试继承<code>JSR310FormattedSerializerBase</code>或者<code>JSR310DateTimeDeserializerBase</code>实现自定义序列化或反序列化器，从更底层控制日期时间类的序列化和反序列化。</p>
<h2 id="SpringMVC中使用JSR-310日期时间类库">SpringMVC中使用JSR-310日期时间类库</h2>
<p>SpringMVC中默认的HTTP消息转换器就是使用Jackson实现的，前面已经提到了Jackson可以完美支持JSR-310，那么SpringMVC也必定可以支持，只需要对<code>ObjectMapper</code>做一些额外的配置即可。这里简单以SpringBoot应用做示例，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于<code>org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration</code>中会通过<code>Jackson2ObjectMapperBuilder</code>去构造内部使用的<code>ObjectMapper</code>，我们只需要提供一个自定义的<code>Jackson2ObjectMapperBuilder</code>类型的Bean即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonBuilderAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Jackson2ObjectMapperBuilder <span class="title">jackson2ObjectMapperBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Jackson2ObjectMapperBuilder builder = <span class="keyword">new</span> Jackson2ObjectMapperBuilder();</span><br><span class="line">		JavaTimeModule javaTimeModule = <span class="keyword">new</span> JavaTimeModule();</span><br><span class="line">		javaTimeModule.addSerializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateSerializer</span>(<span class="title">DATE_FORMATTER</span>))</span>;</span><br><span class="line">		javaTimeModule.addDeserializer(LocalDate<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateDeserializer</span>(<span class="title">DATE_FORMATTER</span>))</span>;</span><br><span class="line">		javaTimeModule.addSerializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeSerializer</span>(<span class="title">DATE_TIME_FORMATTER</span>))</span>;</span><br><span class="line">		javaTimeModule.addDeserializer(LocalDateTime<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">LocalDateTimeDeserializer</span>(<span class="title">DATE_TIME_FORMATTER</span>))</span>;</span><br><span class="line">		builder.modules(javaTimeModule);</span><br><span class="line">		<span class="keyword">return</span> builder;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Sample sample = <span class="keyword">new</span> Sample();</span><br><span class="line">		sample.setLocalDate(LocalDate.now());</span><br><span class="line">		sample.setLocalDateTime(LocalDateTime.now());</span><br><span class="line">		System.out.println(objectMapper.writeValueAsString(sample));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> LocalDate localDate;</span><br><span class="line">		<span class="keyword">private</span> LocalDateTime localDateTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行启动类，某个时刻输出如下</span></span><br><span class="line">&#123;<span class="string">"localDate"</span>:<span class="string">"2019-01-07"</span>,<span class="string">"localDateTime"</span>:<span class="string">"2019-01-07 23:58:08"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这里只要保证SpringMVC内部使用的<code>ObjectMapper</code>类型的Bean对JSR-310日期时间类型的序列化和反序列化生效即可，因为默认配置的<code>MappingJackson2HttpMessageConverter</code>HTTP消息转换器就是使用内置的<code>ObjectMapper</code>类型的Bean做JSON的序列化和反序列化。</p>
<h2 id="小结">小结</h2>
<p>实战层面来看，使用的框架都是基于JDK类库的实现，只要JDK类库的功能可以实现，那么在应用的时候要有信心主流的框架一定会支持对应的特性。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://www.mybatis.org" target="_blank" rel="noopener">Mybatis官方文档</a></li>
<li>JDK11相关源码和注释</li>
</ul>
<p>(本文完 e-a-201818 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/06/java-jsr310-date-time-calculate/">
      JSR310新日期API(四)-日期时间常用计算工具
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月6日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.5k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：6分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-06T16:25:10+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月6日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(四)-日期时间常用计算工具</h1>
<h2 id="前提">前提</h2>
<p>这篇文章主要介绍JSR-310中日期时间类的常用计算工具，包括常规的两个日期时间实例之间的前后比较、间隔的时间量等等。</p>
<h2 id="日期时间的基准类">日期时间的基准类</h2>
<p>日期时间类库中提供了几个常用的计算或者度量基准类，分别是：</p>
<ul>
<li>表示取值范围的<code>ValueRange</code>：内部持有四个主要的成员变量minSmallest、minLargest、maxSmallest和maxLargest，可以表示的值范围是<code>[minSmallest/maxSmallest,minLargest/maxLargest]</code>。</li>
<li>表示秒和纳秒级别的时间量<code>Duration</code>：<code>TemporalAmount</code>的实现类，内部持有一个长整型的成员seconds代表秒和一个整型的成员nanos代表纳秒，由秒和纳秒组成时间量。</li>
<li>表示年月日级别的时间量<code>Period</code>：<code>TemporalAmount</code>的实现类，内部持有三个整型的成员years、months和days分别代表年、月、日，由年月日组成时间量。</li>
<li>日期时间的基本单位<code>TemporalUnit</code>：主要实现类是枚举类型<code>ChronoUnit</code>，一个<code>ChronoUnit</code>成员会维护一个字符串名字属性name和一个<code>Duration</code>类型的实例。</li>
<li>日期时间的属性(field)表示<code>TemporalField</code>：主要实现是枚举类型<code>ChronoField</code>，一个<code>ChronoField</code>成员会维护一个字符串名字属性name、一个<code>TemporalUnit</code>的基础单位baseUnit、一个<code>TemporalUnit</code>的表示范围的单位rangeUnit和一个<code>ValueRange</code>类型的range用于表示当前属性的范围。</li>
</ul>
<p>举一些简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueRangeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ValueRange valueRange = ValueRange.of(<span class="number">1L</span>, <span class="number">10000L</span>);</span><br><span class="line">		System.out.println(valueRange);</span><br><span class="line">		valueRange = ValueRange.of(<span class="number">1L</span>, <span class="number">5L</span>, <span class="number">10000L</span>, <span class="number">50000L</span>);</span><br><span class="line">		System.out.println(valueRange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span> - <span class="number">10000</span></span><br><span class="line"><span class="number">1</span>/<span class="number">5</span> - <span class="number">10000</span>/<span class="number">50000</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Duration duration = Duration.of(<span class="number">1L</span>, ChronoUnit.HOURS);</span><br><span class="line">		System.out.println(duration);</span><br><span class="line">		duration = Duration.from(duration);</span><br><span class="line">		System.out.println(duration);</span><br><span class="line">		duration = Duration.ofSeconds(<span class="number">1L</span>, <span class="number">999_999_999</span>);</span><br><span class="line">		System.out.println(duration.get(ChronoUnit.SECONDS));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果 - toString方法重写了，有特定的格式</span></span><br><span class="line">PT1H</span><br><span class="line">PT1H</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Period period = Period.of(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">		System.out.println(period);</span><br><span class="line">		period = Period.from(period);</span><br><span class="line">		System.out.println(period.getYears());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">P10Y10M10D</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h2 id="常用计算工具">常用计算工具</h2>
<h3 id="判断是否闰年">判断是否闰年</h3>
<p>判断是否闰年这个功能是由年表<code>Chronology</code>提供的，因为不同的年表中的闰年规则可能不一致。一般情况下，我们都是使用ISO规范下的年表，对应的是<code>IsoChronology</code>，可以看一下<code>IsoChronology</code>判断闰年方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">long</span> prolepticYear)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((prolepticYear &amp; <span class="number">3</span>) == <span class="number">0</span>) &amp;&amp; ((prolepticYear % <span class="number">100</span>) != <span class="number">0</span> || (prolepticYear % <span class="number">400</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也是最常见的Java基础面试题之一，可以记下来怎么实现。静态方法<code>java.time.Year#isLeap()</code>也是同样的实现。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsLeapYearMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> year = <span class="number">2016</span>;</span><br><span class="line">		System.out.println(Year.isLeap(year));</span><br><span class="line">		System.out.println(IsoChronology.INSTANCE.isLeapYear(year));</span><br><span class="line">		<span class="comment">// 2018年</span></span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		System.out.println(localDate.isLeapYear());</span><br><span class="line">		System.out.println(localDateTime.toLocalDate().isLeapYear());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h3 id="比较日期时间的先后">比较日期时间的先后</h3>
<p>所有的日期时间、日期、时间类都具备三个比较方法：<code>isBefore()</code>、<code>isAfter()</code>和<code>isEqual()或者equals()</code>，对于<code>ChronoLocalDateTime</code>或者<code>ChronoZonedDateTime</code>，底层总是先转化为新纪元天数再基于天数进行比较。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeCompareMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(LocalDateTime.now().isBefore(LocalDateTime.now().plus(<span class="number">1</span>, ChronoUnit.SECONDS)));</span><br><span class="line">		System.out.println(LocalDate.now().isBefore(LocalDate.now().plus(<span class="number">1</span>, ChronoUnit.DAYS)));</span><br><span class="line">		System.out.println(LocalTime.now().equals(LocalTime.now().plus(<span class="number">1</span>, ChronoUnit.SECONDS)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h3 id="计算日期时间的间隔">计算日期时间的间隔</h3>
<p>计算日期时间的间隔主要通过<code>Duration</code>或者<code>Period</code>的静态方法，主要是通过两个类的<code>between()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Duration中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Duration <span class="title">between</span><span class="params">(Temporal startInclusive, Temporal endExclusive)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Period中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Period</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChronoPeriod <span class="title">between</span><span class="params">(ChronoLocalDate startDateInclusive, ChronoLocalDate endDateExclusive)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> Period <span class="title">between</span><span class="params">(LocalDate startDateInclusive, LocalDate endDateExclusive)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>对于日期时间类来说，计算时间间隔底层是基于<code>TemporalUnit#between()</code>方法，入口方法一般是<code>long until(Temporal endExclusive, TemporalUnit unit)</code>方法。</p>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurationPeriodMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalTime start = LocalTime.of(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		LocalTime end = LocalTime.of(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">		Duration duration = Duration.between(start, end);</span><br><span class="line">		<span class="keyword">long</span> until = start.until(end, ChronoUnit.SECONDS);</span><br><span class="line">		System.out.println(duration.getSeconds());</span><br><span class="line">		System.out.println(until);</span><br><span class="line">		LocalDateTime startDt = LocalDateTime.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">		LocalDateTime endDt = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">		duration = Duration.between(startDt, endDt);</span><br><span class="line">		until = startDt.until(endDt, ChronoUnit.SECONDS);</span><br><span class="line">		System.out.println(duration.getSeconds());</span><br><span class="line">		System.out.println(until);</span><br><span class="line">		LocalDate startD = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		LocalDate endD = LocalDate.of(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">		Period period = Period.between(startD, endD);</span><br><span class="line">		Period untilPeriod = startD.until(endD);</span><br><span class="line">		System.out.println(period);</span><br><span class="line">		System.out.println(untilPeriod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">3661</span></span><br><span class="line"><span class="number">3661</span></span><br><span class="line"><span class="number">10581009</span></span><br><span class="line"><span class="number">10581009</span></span><br><span class="line">P11M5D</span><br><span class="line">P11M5D</span><br></pre></td></tr></table></figure>
<p>只要通过计算得到<code>Duration</code>或者<code>Period</code>实例，那么可以通过<code>get(TemporalUnit unit)</code>方法转换为对应单位的时间量，但是要注意的是对于此方法<code>Duration</code>只支持<code>ChronoUnit.SECONDS</code>和<code>ChronoUnit.NANOS</code>，而<code>Period</code>只支持<code>ChronoUnit.YEARS</code>、<code>ChronoUnit.MONTHS</code>和<code>ChronoUnit.DAYS</code>。一般情况下，我们更希望得知两个日期时间之间相差多少年，多少个月等，这个时候，可以使用<code>Duration</code>或者<code>Period</code>提供的实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Period中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相差的总月数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toTotalMonths</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// Period中</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class Period</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为天数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toDays</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为小时数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toHours</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为分钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMinutes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为秒钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toSeconds</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为毫秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toMillis</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为纳秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toNanos</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确天数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toDaysPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确小时数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toHoursPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确分钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toMinutesPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确秒钟数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toSecondsPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确毫秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toMillisPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// 转换为准确纳秒数</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">toNanosPart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上的实例方法都是<strong>基于整数的除法，也就是说会截断尾数</strong>。举个简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime start = LocalDateTime.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">LocalDateTime end = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">Duration duration = Duration.between(start, end);</span><br><span class="line">Period period = Period.between(start.toLocalDate(), end.toLocalDate());</span><br><span class="line">System.out.println(duration.toDays());</span><br><span class="line">System.out.println(period.toTotalMonths());</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如果不使用<code>Duration</code>或者<code>Period</code>，可以直接使用日期时间类的<code>util()</code>方法，本质是一致的，以<code>LocalDateTime</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime start = LocalDateTime.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">LocalDateTime end = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">long</span> months = start.until(end, ChronoUnit.MONTHS);</span><br><span class="line"><span class="keyword">long</span> days = start.until(end, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(months);</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">122</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>(本文完 c-1-d e-a-201816)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/05/java-jsr310-date-time-format-parse/">
      JSR310新日期API(三)-日期时间格式化与解析
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月5日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：11分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-05T21:45:27+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月5日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(三)-日期时间格式化与解析</h1>
<h2 id="前提">前提</h2>
<p>前一篇文章已经比较详细地介绍了JSR-310中新增的常用的日期时间类，在实际应用中，我们也十分关注这些日期时间类的格式化操作，更加通俗来说就是字符串和日期时间类的相互转换问题。下面先回顾一下Java旧有的日期时间类和字符串之间的转换方案，然后重点分析JSR-310中新增的常用的日期时间类和字符串之间的转换方案。</p>
<h2 id="SimpleDateFormat">SimpleDateFormat</h2>
<p>Java旧有的日期时间类格式化为字符串或者字符串基于模式(pattern)解析为日期时间类完全依赖于<code>java.text.DateFormat</code>的实现类<code>java.text.SimpleDateFormat</code>。<code>SimpleDateFormat</code>的基本功能是完备的，但是存在两个问题：</p>
<ul>
<li><strong>解析和格式化的效率比较低</strong>，原因是依赖了本来就效率不高的<code>Calendar</code>，内部有大量的字符串或者字符(char)的判断和转换代码，因此使用了大量循环、switch块等，这些因素都导致了<code>SimpleDateFormat</code>的效率比较低。</li>
<li><strong>非线程安全</strong>，这个是因为<code>SimpleDateFormat</code>在做转换操作的时候共享了<code>DateFormat</code>的一个内部<code>Calendar</code>的成员calendar。</li>
</ul>
<p>效率低是可以忍受的，但是非线程安全这一点可能会导致严重的问题。对于非线程安全这个问题也有解决方案：</p>
<ul>
<li>方案一：把<code>SimpleDateFormat</code>实例封闭在方法中，也就是调用的时候才创建，这样虽然导致了资源浪费，但是可以避免并发问题。</li>
<li>方案二：使用<code>ThreadLocal</code>装载<code>SimpleDateFormat</code>实例，对于同一个线程来说，共享一个<code>SimpleDateFormat</code>实例。</li>
</ul>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormatMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		java.util.Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		String dateString = simpleDateFormat.format(date);</span><br><span class="line">		System.out.println(dateString);</span><br><span class="line">		date = simpleDateFormat.parse(dateString);</span><br><span class="line">		System.out.println(date);</span><br><span class="line">		simpleDateFormat.applyPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">		dateString = simpleDateFormat.format(date);</span><br><span class="line">		System.out.println(dateString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">03</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">05</span></span><br><span class="line">Thu Jan <span class="number">03</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">05</span> CST <span class="number">2019</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">03</span></span><br></pre></td></tr></table></figure>
<p>对于Java旧有的日期时间类，<code>SimpleDateFormat</code>是基本能够满足的，再加上有第三方库<code>apache-common-lang3</code>、<code>joda-time</code>等的补足，格式化和解析的效率也会有所提高。</p>
<h2 id="JSR-310日期时间类的格式化和解析">JSR-310日期时间类的格式化和解析</h2>
<p>JSR-310日期时间类的格式化依赖于日期时间格式化器<code>java.time.format.DateTimeFormatter</code>，它有一个建造器类<code>java.time.format.DateTimeFormatterBuilder</code>。</p>
<h3 id="DateTimeFormatterBuilder">DateTimeFormatterBuilder</h3>
<p><code>java.time.format.DateTimeFormatterBuilder</code>用于构建日期时间类格式化器，它在设计的时候使用了链式结构，内部持有一个<code>DateTimeFormatterBuilder</code>类型的parent成员指向父<code>DateTimeFormatterBuilder</code>实例和一个<code>DateTimeFormatterBuilder</code>类型的active成员指向当前的<code>DateTimeFormatterBuilder</code>实例。还有一点比较重要的是：<code>DateTimeFormatterBuilder</code>实例内部维护了一个<code>DateTimePrinterParser</code>列表printerParsers，真正的解析工作是委托给对应的<code>DateTimePrinterParser</code>实例完成的，如果没有可用或者没有添加<code>DateTimePrinterParser</code>，那么解析或者格式化方法相当于空跑。接着看下<code>DateTimeFormatterBuilder</code>提供构建<code>DateTimeFormatter</code>时允许添加特性的方法。</p>
<p><strong>解析风格配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大小写敏感 - 默认</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseCaseSensitive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 大小写不敏感</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseCaseInsensitive</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 严格 - 默认</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseStrict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 宽松</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseLenient</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>默认值配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于TemporalField实例配置解析时候写入默认值，支持的TemporalField主要在ChronoField</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">parseDefaulting</span><span class="params">(TemporalField field, <span class="keyword">long</span> value)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加日期时间属性格式化符号控制配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于每个日期时间字段格式化的控制，实际作用是添加一个DateTimePrinterParser的实现NumberPrinterParser</span></span><br><span class="line"><span class="comment"> * TemporalField：日期时间字段类型实例，主要实现类为在ChronoField的枚举属性</span></span><br><span class="line"><span class="comment"> * minWidth：打印最小长度限制，范围是[1,19]</span></span><br><span class="line"><span class="comment"> * maxWidth：打印最大长度限制，范围是[1,19]</span></span><br><span class="line"><span class="comment"> * SignStyle：符号风格，有NORMAL、ALWAYS、NEVER、NOT_NEGATIVE、EXCEEDS_PAD五种选择</span></span><br><span class="line"><span class="comment"> *     - NORMAL：严格模式下只接收负值，宽松模式下接收所有符号</span></span><br><span class="line"><span class="comment"> *     - ALWAYS：0会替换为'+'，严格模式下不接收缺失的符号，宽松模式下缺失的符号会替换为一个正数</span></span><br><span class="line"><span class="comment"> *     - NEVER：只输出绝对的固定值，严格模式下不接收任何符号，宽松模式下只接收固定长度的符号</span></span><br><span class="line"><span class="comment"> *     - NOT_NEGATIVE：以异常的方式阻止负值，严格模式下不接收任何符号，宽松模式下只接收固定长度的符号</span></span><br><span class="line"><span class="comment"> *     - EXCEEDS_PAD：只输出超出宽度限制的符号，负数替换为'-'，严格模式下只输出超出宽度限制的符号，宽松模式下缺失的符号会替换为一个正数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValue</span><span class="params">(TemporalField field, <span class="keyword">int</span> minWidth, <span class="keyword">int</span> maxWidth, SignStyle signStyle)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 下面2个是重载方法</span></span></span><br><span class="line"><span class="function"><span class="comment">// minWidth = 1,maxWidth = 19,signStyle = SignStyle.NORMAL</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValue</span><span class="params">(TemporalField field)</span></span></span><br><span class="line"><span class="function"><span class="comment">// minWidth = maxWidth = width,signStyle = SignStyle.NOT_NEGATIVE</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValue</span><span class="params">(TemporalField field, <span class="keyword">int</span> width)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加基于基础值进行减少配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如field=YEAR，width=2，baseValue=2018，那么当前格式化的实例的有效值为[2018,2117]，2019-&gt;1，2117-&gt;99</span></span><br><span class="line"><span class="comment">// width范围是[1,10]，maxWidth范围是[1,10]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValueReduced</span><span class="params">(TemporalField field, <span class="keyword">int</span> width, <span class="keyword">int</span> maxWidth, <span class="keyword">int</span> baseValue)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendValueReduced</span><span class="params">(TemporalField field, <span class="keyword">int</span> width, <span class="keyword">int</span> maxWidth, ChronoLocalDate baseDate)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加小数(点)配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decimalPoint = true则输出小数，minWidth范围是[0,9]，maxWidth范围是[1,9]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendFraction</span><span class="params">(TemporalField field, <span class="keyword">int</span> minWidth, <span class="keyword">int</span> maxWidth, <span class="keyword">boolean</span> decimalPoint)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加文本格式配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendText</span><span class="params">(TemporalField field)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendText</span><span class="params">(TemporalField field, TextStyle textStyle)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendText</span><span class="params">(TemporalField field, Map&lt;Long, String&gt; textLookup)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加瞬时时间配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendInstant</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendInstant</span><span class="params">(<span class="keyword">int</span> fractionalDigits)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加时区相关的配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间偏移量如+01:00</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendOffsetId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 指定格式的时间偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendOffset</span><span class="params">(String pattern, String noOffsetText)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 指定文本风格的本地时间偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLocalizedOffset</span><span class="params">(TextStyle style)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneRegionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneOrOffsetId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneText</span><span class="params">(TextStyle textStyle)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendZoneText</span><span class="params">(TextStyle textStyle, Set&lt;ZoneId&gt; preferredZones)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 太平洋时间时区偏移量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendGenericZoneText</span><span class="params">(TextStyle textStyle)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendGenericZoneText</span><span class="params">(TextStyle textStyle, Set&lt;ZoneId&gt; preferredZones)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 日历配置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendChronologyId</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendChronologyText</span><span class="params">(TextStyle textStyle)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加本地日期时间配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLocalized</span><span class="params">(FormatStyle dateStyle, FormatStyle timeStyle)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加常量文字(字符串)配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLiteral</span><span class="params">(<span class="keyword">char</span> literal)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendLiteral</span><span class="params">(String literal)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加其他格式化器的属性到当期建造器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">append</span><span class="params">(DateTimeFormatter formatter)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 配置候选格式化器</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendOptional</span><span class="params">(DateTimeFormatter formatter)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>追加通用格式配置</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pattern的解析基本包含了上面提到的其他种类的配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DateTimeFormatterBuilder <span class="title">appendPattern</span><span class="params">(String pattern)</span></span></span><br></pre></td></tr></table></figure>
<p>上面只是分析完毕，实际上理解这些配置方法的成本还是挺高的，可以参考<code>DateTimeFormatter</code>中已经存在的一些静态变量<code>ISO_LOCAL_TIME</code>、<code>ISO_OFFSET_TIME</code>、<code>ISO_LOCAL_DATE_TIME</code>等学习怎么使用<code>DateTimeFormatterBuilder</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ISO_LOCAL_TIME;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    ISO_LOCAL_TIME = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">            .appendValue(HOUR_OF_DAY, <span class="number">2</span>)</span><br><span class="line">            .appendLiteral(<span class="string">':'</span>)</span><br><span class="line">            .appendValue(MINUTE_OF_HOUR, <span class="number">2</span>)</span><br><span class="line">            .optionalStart()</span><br><span class="line">            .appendLiteral(<span class="string">':'</span>)</span><br><span class="line">            .appendValue(SECOND_OF_MINUTE, <span class="number">2</span>)</span><br><span class="line">            .optionalStart()</span><br><span class="line">            .appendFraction(NANO_OF_SECOND, <span class="number">0</span>, <span class="number">9</span>, <span class="keyword">true</span>)</span><br><span class="line">            .toFormatter(ResolverStyle.STRICT, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模仿上面的代码，我们做一个简单的例子：格式化用<code>LocalDateTime</code>存储的日期时间2018-1-5 15:30:30为&quot;当前时间是：2018年1月5日 15时30分30秒，祝你生活愉快！&quot;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeFormatterBuilderMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DateTimeFormatterBuilder builder = <span class="keyword">new</span> DateTimeFormatterBuilder();</span><br><span class="line">		builder.appendLiteral(<span class="string">"当前时间是："</span>);</span><br><span class="line">		builder.appendValue(ChronoField.YEAR, <span class="number">4</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"年"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.MONTH_OF_YEAR, <span class="number">1</span>, <span class="number">2</span>, SignStyle.NORMAL);</span><br><span class="line">		builder.appendLiteral(<span class="string">"月"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.DAY_OF_MONTH, <span class="number">1</span>, <span class="number">2</span>, SignStyle.NORMAL);</span><br><span class="line">		builder.appendLiteral(<span class="string">"日"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">" "</span>);</span><br><span class="line">		builder.appendValue(ChronoField.HOUR_OF_DAY, <span class="number">2</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"时"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">":"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.MINUTE_OF_HOUR, <span class="number">2</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"分"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">":"</span>);</span><br><span class="line">		builder.appendValue(ChronoField.SECOND_OF_MINUTE, <span class="number">2</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"秒"</span>);</span><br><span class="line">		builder.appendLiteral(<span class="string">"，祝你生活愉快！"</span>);</span><br><span class="line">		DateTimeFormatter formatter = builder.toFormatter();</span><br><span class="line">		System.out.println(formatter.format(LocalDateTime.now()));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻执行后输出结果</span></span><br><span class="line">当前时间是：<span class="number">2019</span>年<span class="number">1</span>月<span class="number">5</span>日 <span class="number">15</span>时:<span class="number">50</span>分:<span class="number">50</span>秒，祝你生活愉快！</span><br></pre></td></tr></table></figure>
<p>从理论上来看，如果能够熟练使用上面分析过的规则，那么可以格式化或者反向解析任意格式的日期时间或者字符串。</p>
<h3 id="DateTimeFormatter">DateTimeFormatter</h3>
<p><code>java.time.format.DateTimeFormatter</code>在设计上是一个不可变类，也就是它是线程安全的，<code>DateTimeFormatter</code>的静态方法和实例方法只要返回<code>DateTimeFormatter</code>类型，那么必定是一个新的实例。它主要职责是格式化日期时间。一般情况下，构造<code>DateTimeFormatter</code>实例可以使用它提供的静态工厂方法，这些静态方法如果不能满足需求，可以考虑使用<code>DateTimeFormatterBuilder</code>定制化建造<code>DateTimeFormatter</code>实例。常用的2个静态工厂方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateTimeFormatter <span class="title">ofPattern</span><span class="params">(String pattern)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DateTimeFormatter <span class="title">ofPattern</span><span class="params">(String pattern, Locale locale)</span></span></span><br></pre></td></tr></table></figure>
<p>字符串pattern基本可以填写任意合法的日期时间格式，因为底层使用<code>DateTimeFormatterBuilder#appendPattern()</code>进行解析，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>)</span><br></pre></td></tr></table></figure>
<p>至于日期时间实例的格式化，主要通过下面的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(TemporalAccessor temporal)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">formatTo</span><span class="params">(TemporalAccessor temporal, Appendable appendable)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeFormatterMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		String value = formatter.format(localDateTime);</span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		formatter.formatTo(localDateTime, builder);</span><br><span class="line">		System.out.println(value);</span><br><span class="line">		System.out.println(builder.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line"><span class="number">2019</span>年<span class="number">01</span>月<span class="number">05</span>日 <span class="number">16</span>时<span class="number">28</span>分<span class="number">01</span>秒</span><br><span class="line"><span class="number">2019</span>年<span class="number">01</span>月<span class="number">05</span>日 <span class="number">16</span>时<span class="number">28</span>分<span class="number">01</span>秒</span><br></pre></td></tr></table></figure>
<p>字符串反解析为日期时间类型的(parse)方法并不存在于<code>DateTimeFormatter</code>类中，parse方法存在于日期时间类自身之中，这样的设计才是合理的，思想和领域驱动的方向是一致的，这里用<code>LocalDateTime</code>为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用DateTimeFormatter.ISO_LOCAL_DATE_TIME进行解析</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parse</span><span class="params">(CharSequence text)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 使用传入的自定义DateTimeFormatter进行解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parse</span><span class="params">(CharSequence text, DateTimeFormatter formatter)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeFormatterMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒"</span>);</span><br><span class="line">		String dateTime = <span class="string">"2019年01月05日 16时28分01秒"</span>;</span><br><span class="line">		LocalDateTime parseResult = LocalDateTime.parse(dateTime, formatter);</span><br><span class="line">		System.out.println(parseResult);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">05</span>T16:<span class="number">28</span>:<span class="number">01</span></span><br></pre></td></tr></table></figure>
<p>由于<code>DateTimeFormatter</code>实例创建的时候相对耗时，因此需要考虑避免多次创建<code>DateTimeFormatter</code>实例，可以考虑编写一个工具类，用哈希表缓存<code>pattern -&gt; DateTimeFormatter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只列举LocalDateTime和LocalDate的例子，其他的日期时间类可以以此类推</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> DateTimeFormatUtils &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 单例</span></span><br><span class="line">	SINGLETON;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, DateTimeFormatter&gt; FORMATTERS = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">formatLocalDateTime</span><span class="params">(LocalDateTime value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getOrCreateDateTimeFormatter(pattern).format(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">parseLocalDateTime</span><span class="params">(String value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> LocalDateTime.parse(value, getOrCreateDateTimeFormatter(pattern));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">formatLocalDate</span><span class="params">(LocalDate value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getOrCreateDateTimeFormatter(pattern).format(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LocalDate <span class="title">parseLocalDate</span><span class="params">(String value, String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> LocalDate.parse(value, getOrCreateDateTimeFormatter(pattern));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> DateTimeFormatter <span class="title">getOrCreateDateTimeFormatter</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> FORMATTERS.computeIfAbsent(pattern, DateTimeFormatter::ofPattern);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还要注意一点：<strong>格式化或者解析的时候使用的模式pattern必须是合法日期时间表示格式(例如年份用yyyy表示)，并且严格区分日期时间、只有日期属性和只有时间属性三种不同的情况</strong>，如果使用<code>yyyy-MM-dd HH:mm:ss</code>模式创建的<code>DateTimeFormatter</code>去格式化<code>LocalTime</code>或者<code>LocalDate</code>，会抛出异常，异常的类型是<code>DateTimeException</code>或者其子类，属于运行时异常。</p>
<h2 id="小结">小结</h2>
<p>在JavaEE开发中，特别在系统交互中，日期时间字段的转换是比较重要的。其实JSR-310中的日期时间API的格式化和解析和旧有的日期时间API的格式化和解析从本质上是没有区别的，都是字符串解析和转换的游戏，但是个人是推荐使用JSR-310中的日期时间API的格式化和解析，原因是：</p>
<ul>
<li>性能上有很大提升(直观上推测，没有做严格测试)。</li>
<li>类库设计上更加合理。</li>
<li>线程安全。</li>
</ul>
<p>(本文完 e-a-2019-1-5 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2019/01/01/java-jsr310-time-api/">
      JSR310新日期API(二)-日期时间API
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2019年1月1日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：29分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-01T22:04:22+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(二)-日期时间API</h1>
<h2 id="前提">前提</h2>
<p>这篇文章主要介绍一下日期时间API中最常用的类库，分别是：</p>
<ul>
<li><code>java.time.Clock</code>：时钟。</li>
<li><code>java.time.Instant</code>：瞬时时间，时间戳<code>java.sql.Timestamp</code>的替代类。</li>
<li><code>java.time.LocalDate</code>：本地日期，ISO-8601日历系统下的日期表示，不包含时区的概念，只能表示年月日。</li>
<li><code>java.time.LocalDateTime</code>：本地日期时间，ISO-8601日历系统下的日期时间表示，不包含时区的概念，只能表示年月日时分秒。</li>
<li><code>java.time.LocalTime</code>：本地时间，ISO-8601日历系统下的时间表示，不包含时区的概念，只能表示时分秒。</li>
<li><code>java.time.OffsetTime</code>：带有时间偏移量的时间，ISO-8601日历系统下的带有UTC/GMT时间偏移量的时间表示。</li>
<li><code>java.time.OffsetDateTime</code>：带有时间偏移量的日期时间，ISO-8601日历系统下的带有UTC/GMT时间偏移量(不包含基于ZoneRegion的时间偏移量)的日期时间表示。</li>
<li><code>java.time.ZonedDateTime</code>：带有时间偏移量的日期时间，ISO-8601日历系统下的带有UTC/GMT时间偏移量(包含基于ZoneRegion的时间偏移量)的日期时间表示。</li>
</ul>
<p>其他的类库还有<code>Year</code>、<code>Month</code>、<code>DayOfWeek</code>、<code>MonthDay</code>、<code>YearMonth</code>等。值得注意的是：JSR-310增加的日期API是严格区分年月日-时分秒格式的日期表示类，例如XXXDateTime一定表示为年月日时分秒，XXXTime只能表示时分秒，XXXDate只能表示年月日。</p>
<p><strong>值得注意的是</strong>：这些新增的日期时间类都是不可变类，每次通过其方法更变或者修改都是返回一个全新的对象，因此它们都是<strong>线程安全</strong>的。</p>
<h2 id="Clock">Clock</h2>
<p><code>java.time.Clock</code>是一个抽象类，它表示时钟，一般情况下，它需要结合时区使用，提供获取当前时刻的功能。<code>Clock</code>主要提供下面四个方法，其他方法都是静态工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用于创建时钟的时区。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ZoneId	<span class="title">getZone</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取时钟的当前瞬时对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Instant <span class="title">instant</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取时钟的当前毫秒数值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">millis</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前时钟实例的一个新的拷贝时钟实例，并且使用入参作为新时钟实例的时区</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Clock <span class="title">withZone</span><span class="params">(ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>
<p>静态工厂方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public static Clock systemUTC()</td>
<td style="text-align:center">获取可以返回当前时刻的系统时钟，使用UTC(零)时区进行进行时间转换[SystemClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock systemDefaultZone()</td>
<td style="text-align:center">获取可以返回当前时刻的系统时钟，使用默认时区进行时间转换[SystemClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock system(ZoneId zone)</td>
<td style="text-align:center">获取可以返回当前时刻的系统时钟，使用指定时区ID进行时间转换[SystemClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tickMillis(ZoneId zone)</td>
<td style="text-align:center">获取以整数毫秒返回当前时刻的时钟，使用指定时区ID进行时间转换[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tickSeconds(ZoneId zone)</td>
<td style="text-align:center">获取以整数秒返回当前时刻的时钟，使用指定时区ID进行时间转换[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tickMinutes(ZoneId zone)</td>
<td style="text-align:center">获取以整数分钟返回当前时刻的时钟，使用指定时区ID进行时间转换[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock tick(Clock baseClock, Duration tickDuration)</td>
<td style="text-align:center">返回一个以基础时钟和时钟记录基础单位为构造的时钟[TickClock]</td>
</tr>
<tr>
<td style="text-align:center">public static Clock fixed(Instant fixedInstant, ZoneId zone)</td>
<td style="text-align:center">获得一个始终返回同一时刻的时钟，使用指定时区ID进行时间转换[FixedClock]</td>
</tr>
<tr>
<td style="text-align:center">offset​(Clock baseClock, Duration offsetDuration)</td>
<td style="text-align:center">返回一个以基础时钟和固定时间偏移量为构造的时钟[OffsetClock]</td>
</tr>
</tbody>
</table>
<p><code>java.time.Clock</code>主要有四个实现，它们都是<code>java.time.Clock</code>的内部类，上面的工厂方法创建的实例一定是这四个实现之一：</p>
<ul>
<li><code>SystemClock</code>：总是基于<code>System#currentTimeMillis()</code>返回最新的时间<code>SystemClock.UTC</code>是典型的实现。</li>
<li><code>FixedClock</code>：总是返回相同的瞬时时间，可以认为是一个固定时刻的时钟，通常使用于测试。</li>
<li><code>OffsetClock</code>：基于一个确定的Clock实现，为它添加一个时间偏移量，时间偏移量的单位是<code>Duration</code>。</li>
<li><code>TickClock</code>：基于一个确定的Clock实现，为它添加一个时间偏移量，时间偏移量的单位是纳秒。</li>
</ul>
<p>上面比较难理解的是<code>TickClock</code>，这里举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TickClockMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Clock tickMillis = Clock.tickMillis(ZoneId.systemDefault());</span><br><span class="line">		Clock tickSeconds = Clock.tickSeconds(ZoneId.systemDefault());</span><br><span class="line">		System.out.println(tickMillis.millis());</span><br><span class="line">		System.out.println(tickSeconds.millis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">1546010945575</span></span><br><span class="line"><span class="number">1546010945000</span></span><br></pre></td></tr></table></figure>
<p>简单来说，<code>Clock#tickMillis()</code>构造的时钟的计时单位是毫秒，而<code>Clock#tickSeconds()</code>构造的时钟的计时单位是秒(毫秒部分会被截断)，以此类推。</p>
<p><code>FixedClock</code>是一个固定时刻的时钟，<strong>一般用于测试</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedClockMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Clock fixed = Clock.fixed(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(fixed.millis());</span><br><span class="line">		System.out.println(fixed.millis());</span><br><span class="line">		System.out.println(fixed.millis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="number">1546011492590</span></span><br><span class="line"><span class="number">1546011492590</span></span><br><span class="line"><span class="number">1546011492590</span></span><br></pre></td></tr></table></figure>
<p>最常用的是默认ZoneId下的系统时钟<code>SystemClock</code>和UTC系统时钟：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClockMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Clock clock = Clock.systemDefaultZone();</span><br><span class="line">		System.out.println(clock.millis());</span><br><span class="line">		Clock utc = Clock.systemUTC();</span><br><span class="line">		System.out.println(utc.millis());</span><br><span class="line">		System.out.println(System.currentTimeMillis());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//某个时刻的输出结果</span></span><br><span class="line"><span class="number">1546011686413</span></span><br><span class="line"><span class="number">1546011686413</span></span><br><span class="line"><span class="number">1546011686413</span></span><br></pre></td></tr></table></figure>
<h2 id="Instant">Instant</h2>
<p><code>java.time.Instant</code>字面意思是瞬时时间，它是<code>java.sql.Timestamp</code>的对应类，代表时间线(time-line)上的一个瞬时时间点，准确来说，它内部持有一个long类型的纪元秒属性(seconds)和一个int类型的纳秒属性(nanos，nanos的取值范围是[0,999_999_999])，纪元秒如果为正数，表示该瞬时时间点位于格林威治新纪元<code>1970-01-01T00:00:00Z</code>之后，而纪元秒如果为负数，则表示该瞬时时间点位于格林威治新纪元之前。因此<code>Instant</code>能表示的时间点其实是有上下界的，逻辑上的界限就是<code>1970-01-01T00:00:00Z - 31557014167219200秒</code>到<code>1970-01-01T00:00:00Z + 31556889864403199秒 + 999_999_999纳秒</code>或者表示为<code>Instant#MIN</code>到<code>Instant#MAX</code>，这个范围很大，因此暂时不需要考虑超限的问题。<code>Instant</code>中已经提供了一个公有静态实例用于表示格林威治新纪元，它就是<code>Instant#EPOCH</code>，代表1970-01-01T00:00:00Z这个瞬时时间点。先看一下<code>Instant</code>的常用静态工厂方法(<code>Instant</code>没有公有构造器，必须通过工厂方法构造实例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时刻的瞬时时间点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于时钟实例获取瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于距离新纪元的秒数创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">ofEpochSecond</span><span class="params">(<span class="keyword">long</span> epochSecond)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于距离新纪元的秒数和纳秒创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">ofEpochSecond</span><span class="params">(<span class="keyword">long</span> epochSecond, <span class="keyword">long</span> nanoAdjustment)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于毫秒数创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">ofEpochMilli</span><span class="params">(<span class="keyword">long</span> epochMilli)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于其他日期时间API创建瞬时时间点</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">from</span><span class="params">(TemporalAccessor temporal)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于特定格式字符串创建瞬时时间点，如2007-12-03T10:15:30.00Z</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">parse</span><span class="params">(<span class="keyword">final</span> CharSequence text)</span></span></span><br></pre></td></tr></table></figure>
<p>当然还有其他常用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前Instant实例对于不同计时单位的值，见ChronoField</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(TemporalField field)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前Instant实例的纪元秒属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEpochSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前Instant实例的纳秒属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNano</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取当前Instant实例的毫秒值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toEpochMilli</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于TemporalField实例(TemporalField)和新的值调整并且创建一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">with</span><span class="params">(TemporalField field, <span class="keyword">long</span> newValue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 当前Instant实例基于TemporalUnit(ChronoUnit)截断并且返回一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">truncatedTo</span><span class="params">(TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 顾名思义，基于一个时间基准单位进行时间量增加，返回一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">plus</span><span class="params">(<span class="keyword">long</span> amountToAdd, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 顾名思义，基于一个时间基准单位进行时间量减少，返回一个新的Instant</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Instant <span class="title">minus</span><span class="params">(<span class="keyword">long</span> amountToSubtract, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 计算当前Instant实例和入参endExclusive基于时间基准单位unit之间的时间量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">until</span><span class="params">(Temporal endExclusive, TemporalUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>举个使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Instant instant = Instant.now();</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.now(Clock.systemDefaultZone());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.ofEpochSecond(<span class="keyword">new</span> Date().toInstant().getEpochSecond());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.ofEpochMilli(System.currentTimeMillis());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.from(Instant.now());</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">		instant = Instant.parse(<span class="string">"2018-12-31T10:15:30.00Z"</span>);</span><br><span class="line">		System.out.println(String.format(<span class="string">"Second:%d,Nano:%d"</span>, instant.getEpochSecond(), instant.getNano()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">261861900</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">291941900</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">0</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">292000000</span></span><br><span class="line">Second:<span class="number">1546187685</span>,Nano:<span class="number">292946400</span></span><br><span class="line">Second:<span class="number">1546251330</span>,Nano:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="LocalDate">LocalDate</h2>
<p><code>java.time.LocalDate</code>代表ISO-8601日历系统中<strong>不包含时区的日期(当然也不包含具体的时间)表示</strong>，例如2007-12-03。<code>LocalDate</code>是一个不可变的日期对象，也就是只能表示日期，通常的表示格式为年-月-日，同时提供其他日期字段的访问，例如一年中的第几日(day-of-year)、星期几(day-of-week)和一年中的第几周(week-of-year)等。不同的<code>LocalDate</code>之间的比较只能通过<code>LocalDate#equals()</code>方法，其他比较操作如<code>==</code>或者<code>hash()</code>方法会产生无法预知的结果。<code>LocalDate</code>提供的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -999999999-01-01</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate MIN = LocalDate.of(Year.MIN_VALUE, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 999999999-12-31</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate MAX = LocalDate.of(Year.MAX_VALUE, <span class="number">12</span>, <span class="number">31</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDate EPOCH = LocalDate.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>LocalDate</code>的工厂方法比较多，这里只列举部分常用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前日期获取LocalDate实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前日期和时区获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前日期和时钟获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月(枚举)日获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月日获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年和具体该年中的某一日获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">ofYearDay</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> dayOfYear)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于新纪元1970-01-01的偏移天数获取LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">ofEpochDay</span><span class="params">(<span class="keyword">long</span> epochDay)</span></span></span><br></pre></td></tr></table></figure>
<p><code>LocalDate</code>的实例方法也比较多，这里也列举部分常用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取年份值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取月份值，范围是1-12</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonthValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取月份枚举</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Month <span class="title">getMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例的该年中具体的第几天</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDayOfYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例的具体是星期几</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DayOfWeek <span class="title">getDayOfWeek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 是否闰年</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例月份长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回当前LocalDate实例年份长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期属性修改对应的值返回一个新的LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">with</span><span class="params">(TemporalField field, <span class="keyword">long</span> newValue)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期时间基准单位增加对应的值返回一个新的LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">plus</span><span class="params">(<span class="keyword">long</span> amountToAdd, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期时间基准单位减去对应的值返回一个新的LocalDate实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalDate <span class="title">minus</span><span class="params">(<span class="keyword">long</span> amountToSubtract, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一个日期时间基准单位计算以入参为endExclusive计算日期或者时间的间隔</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">until</span><span class="params">(Temporal endExclusive, TemporalUnit unit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回基于新纪元年1970-1-1的偏移天数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">toEpochDay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 如果入参为LocalDate类型功能和equals一致，否则通过基于纪元年的偏移天数比较</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(ChronoLocalDate other)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 只有年月日三个成员同时相等此方法才返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		localDate = LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		localDate = localDate.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		System.out.println(localDate.equals(LocalDate.of(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>)));</span><br><span class="line">		System.out.println(localDate.toEpochDay());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某天执行的输出结果</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">12</span>-<span class="number">31</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="number">17897</span></span><br></pre></td></tr></table></figure>
<h2 id="LocalTime">LocalTime</h2>
<p><code>java.time.LocalTime</code>代表ISO-8601日历系统中<strong>不包含时区的时间(当然也不包含具体的日期)表示</strong>，例如10:15:30。<code>LocalTime</code>是一个不可变的时间对象，也就是只能表示时间，通常的表示格式为时:分:秒，也可以包含一个纳秒属性(nano取值范围[0,999999999])，通俗来说，它表示的就是挂钟上所见的时间的描述。同样，不同的<code>LocalTime</code>实例必须通过<code>LocalTime#equals()</code>方法比较。<code>LocalTime</code>提供的静态实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一天的起始时间 - 00:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime MIN</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一天的结束时间 - 23:59:59.999999999</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime MAX</span><br><span class="line"></span><br><span class="line"><span class="comment">// 午夜 - 00:00 其实和MIN是一样的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime MIDNIGHT</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中午 - 12:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalTime NOON</span><br></pre></td></tr></table></figure>
<p><code>LocalTime</code>常用的工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前时间构造LocalTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前时间和时区ID构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于当前时间和时钟实例构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于小时、分钟(、秒和纳秒)构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于瞬时时间实例和时区ID构造LocalTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一天当中的具体秒数构造LocalTime实例,secondOfDay范围是[0,24 * 60 * 60 - 1]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">ofSecondOfDay</span><span class="params">(<span class="keyword">long</span> secondOfDay)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于一天当中的具体纳秒数构造LocalTime实例,nanoOfDay[0,24 * 60 * 60 * 1,000,000,000 - 1]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">ofNanoOfDay</span><span class="params">(<span class="keyword">long</span> nanoOfDay)</span></span></span><br></pre></td></tr></table></figure>
<p><code>LocalTime</code>常用的实例方法有很多，套路和上面章节提到过的方法类似，这里不啰嗦分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回小时值，范围[0,23]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回分钟值，范围[0,59]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回秒数值，范围[0,59]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSecond</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回纳秒数值，范围[0,999_999_999]</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNano</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalTime localTime = LocalTime.now();</span><br><span class="line">		System.out.println(localTime);</span><br><span class="line">		localTime = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line">		System.out.println(localTime);</span><br><span class="line">		localTime = LocalTime.MAX;</span><br><span class="line">		System.out.println(String.format(<span class="string">"Hour:%d,minute:%d,second:%d,nano:%d"</span>, localTime.getHour(),</span><br><span class="line">				localTime.getMinute(), localTime.getSecond(), localTime.getNano()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻下的输出结果</span></span><br><span class="line"><span class="number">00</span>:<span class="number">46</span>:<span class="number">08.845848800</span></span><br><span class="line"><span class="number">23</span>:<span class="number">59</span></span><br><span class="line">Hour:<span class="number">23</span>,minute:<span class="number">59</span>,second:<span class="number">59</span>,nano:<span class="number">999999999</span></span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime">LocalDateTime</h2>
<p><code>java.time.LocalDateTime</code>实际上就是<code>LocalDate</code>和<code>LocalTime</code>的结合版本，代表ISO-8601日历系统中<strong>不包含时区(<code>LocalDateTime</code>不存储时区信息，但是可以使用时区ID构造<code>LocalDateTime</code>实例)的日期时间表示</strong>，例如2007-12-03T10:15:30。<code>LocalDateTime</code>是一个不可变的时间对象，也就是只能表示日期时间，通常的表示格式为年-月日 时:分:秒，也可以包含一个纳秒属性(nano取值范围[0,999999999])。不同的<code>LocalDateTime</code>实例必须通过<code>LocalDateTime#equals()</code>方法比较。<code>LocalDateTime</code>内部持有一个<code>LocalDate</code>实例和一个<code>LocalTime</code>实例。它定义了两个公有的静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime能够表示的最小日期时间，即-999999999-01-01T00:00:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDateTime MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN)</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDateTime能够表示的最大日期时间，即999999999-12-31T23:59:59.999999999</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> LocalDateTime MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX)</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>常用的静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前日期时间、时区ID、时钟创建LocalDateTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月(枚举)日时分秒纳秒创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, Month month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth, <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDate和LocalTime实例创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于Instant实例和时区ID实例创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于新纪元偏移秒数、纳秒数和时间偏移量创建LocalDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">ofEpochSecond</span><span class="params">(<span class="keyword">long</span> epochSecond, <span class="keyword">int</span> nanoOfSecond, ZoneOffset offset)</span></span></span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>的实例方法和前面介绍过的类差不多，这里不做详细展开，举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now(ZoneId.systemDefault());</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">		localDateTime = LocalDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">		localDateTime = localDateTime.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T17:<span class="number">43</span>:<span class="number">48.260517400</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T17:<span class="number">43</span>:<span class="number">48.260517400</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">01</span>-<span class="number">01</span>T17:<span class="number">43</span>:<span class="number">48.260517400</span></span><br></pre></td></tr></table></figure>
<h2 id="OffsetTime">OffsetTime</h2>
<p><code>java.time.OffsetTime</code>表示ISO-8601日历系统中带有基于UTC/Greenwich时间偏移量的时间，例如10:15:30+01:00。<code>OffsetTime</code>也是一个不可变的时间对象，通常表示格式为时:分:秒-时间偏移量，当然它也可以包含一个纳秒属性(nano取值范围[0,999999999])。相比<code>LocalTime</code>，它多存储了一个时区时间偏移量(zone offset)属性。<code>OffsetTime</code>的公有静态实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表00:00:00+18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetTime MIN = LocalTime.MIN.atOffset(ZoneOffset.MAX)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表23:59:59.999999999-18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetTime MAX = LocalTime.MAX.atOffset(ZoneOffset.MIN)</span><br></pre></td></tr></table></figure>
<p><code>OffsetTime</code>的常用工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前时间、时区ID、时钟创建OffsetTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalTime实例和时间偏移量创建OffsetTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">of</span><span class="params">(LocalTime time, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于时分秒纳秒和时间偏移量创建OffsetTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">of</span><span class="params">(<span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于Instant实例和时区ID实例创建OffsetTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		OffsetTime offsetTime = OffsetTime.now();</span><br><span class="line">		System.out.println(offsetTime);</span><br><span class="line">		offsetTime = OffsetTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(offsetTime);</span><br><span class="line">		offsetTime = OffsetTime.of(LocalTime.now(), ZoneOffset.UTC);</span><br><span class="line">		System.out.println(offsetTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//某个时刻下的输出结果如下</span></span><br><span class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">26.263710800</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">26.264713600</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">18</span>:<span class="number">08</span>:<span class="number">26.264713600</span>Z</span><br></pre></td></tr></table></figure>
<h2 id="OffsetDateTime">OffsetDateTime</h2>
<p><code>java.time.OffsetDateTime</code>表示ISO-8601日历系统中带有基于UTC/Greenwich时间偏移量的日期时间，例如2007-12-03T10:15:30+01:00。<code>OffsetDateTime</code>也是一个不可变的日期时间对象，通常表示格式为年-月-日 时:分:秒-时间偏移量，当然它也可以包含一个纳秒属性(nano取值范围[0,999999999])。相比<code>LocalDateTime</code>，它多存储了一个时区时间偏移量(zone offset)属性。<code>OffsetDateTime</code>提供的公有静态实例常量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OffsetDateTime能表示的最小的日期时间-999999999-01-01T00:00:00+18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetDateTime MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OffsetDateTime能表示的最大的日期时间999999999-12-31T23:59:59.999999999-18:00</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> OffsetDateTime MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN)</span><br></pre></td></tr></table></figure>
<p><code>OffsetDateTime</code>的常用静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于当前的日期时间、时区ID、时钟创建OffsetDateTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDate实例、LocalTime实例和时间偏移量创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDateTime实例和时间偏移量创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">of</span><span class="params">(LocalDateTime dateTime, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月日时分秒纳秒和时间偏移量创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">of</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond, ZoneOffset offset)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于Instant实例和时区ID实例创建OffsetDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OffsetDateTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		OffsetDateTime offsetDateTime = OffsetDateTime.now();</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line">		offsetDateTime = OffsetDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line">		offsetDateTime = OffsetDateTime.of(LocalDateTime.now(), ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">		System.out.println(offsetDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T20:<span class="number">38</span>:<span class="number">03.388846400</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T20:<span class="number">38</span>:<span class="number">03.388846400</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T20:<span class="number">38</span>:<span class="number">03.388846400</span>+<span class="number">08</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>
<h2 id="ZonedDateTime">ZonedDateTime</h2>
<p><code>java.time.ZonedDateTime</code>应该是JSR-310中最复杂但是最全面的日期时间类(它的API文档中注释也是最多的，从这点也可以看出它的复杂性)。<code>ZonedDateTime</code>可以简单理解为<code>LocalDateTime</code>，时区ID和一个可处理的<code>ZoneOffset</code>三者的共同实现，或者更简单理解为日期时间、时间偏移量、区域时区等时区规则的多重实现。<code>ZonedDateTime</code>也是一个不可变的日期时间对象，常用的格式为：年-月-日 时:分:秒-时区偏移量-区域，例如2007-12-03T10:15:30+01:00 Europe/Paris。除了包含所有的日期时间属性之外，<code>ZonedDateTime</code>还包含一个纳秒属性(nano取值范围[0,999999999])。<code>ZonedDateTime</code>的常用静态工厂方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前的日期时间、时区ID和时钟创建ZonedDateTime实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">now</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">now</span><span class="params">(ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">now</span><span class="params">(Clock clock)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDate实例、LocalTime实例和时区ID创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDateTime实例和时区ID创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(LocalDateTime localDateTime, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于年月日时分秒纳秒和时区ID创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> dayOfMonth,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> hour, <span class="keyword">int</span> minute, <span class="keyword">int</span> second, <span class="keyword">int</span> nanoOfSecond, ZoneId zone)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 基于LocalDateTime实例、时区ID和候选偏好的时间偏移量创建ZonedDateTime实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">ofLocal</span><span class="params">(LocalDateTime localDateTime, ZoneId zone, ZoneOffset preferredOffset)</span></span></span><br></pre></td></tr></table></figure>
<p>举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZonedDateTime zonedDateTime = ZonedDateTime.now();</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">		zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">		zonedDateTime = ZonedDateTime.ofInstant(Instant.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的执行结果</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T21:<span class="number">00</span>:<span class="number">03.193242200</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T21:<span class="number">00</span>:<span class="number">03.193242200</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T21:<span class="number">00</span>:<span class="number">03.193242200</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="Year">Year</h3>
<p><code>java.time.Year</code>基于ISO-8601日期系统下表示年份，支持的范围是[-999_999_999,999_999_999]。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YearMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Year year = Year.now();</span><br><span class="line">		System.out.println(year);</span><br><span class="line">		System.out.println(year.isLeap());</span><br><span class="line">		year = Year.of(<span class="number">2016</span>);</span><br><span class="line">		System.out.println(year);</span><br><span class="line">		System.out.println(year.isLeap());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">2019</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">2016</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h3 id="Month">Month</h3>
<p><code>java.time.Month</code>是一个枚举，代表ISO-8601日期系统中的月份。枚举的成员一共有12个，就是JANUARY到DECEMBER一共12个月份的英文大写表示。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonthMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Month month = Month.of(<span class="number">12</span>);</span><br><span class="line">		System.out.println(month);</span><br><span class="line">		month = Month.JANUARY;</span><br><span class="line">		System.out.println(month);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">DECEMBER</span><br><span class="line">JANUARY</span><br></pre></td></tr></table></figure>
<h3 id="DayOfWeek">DayOfWeek</h3>
<p><code>java.time.DayOfWeek</code>是一个枚举，表示一个星期中具体是星期几。枚举成员一共有7个，就是从MONDAY到SUNDAY一共7个指代具体星期几的英文大写表示。举个简单的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeekMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		DayOfWeek dayOfWeek = DayOfWeek.of(<span class="number">1</span>);</span><br><span class="line">		System.out.println(dayOfWeek);</span><br><span class="line">		dayOfWeek = DayOfWeek.SUNDAY;</span><br><span class="line">		System.out.println(dayOfWeek);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">MONDAY</span><br><span class="line">SUNDAY</span><br></pre></td></tr></table></figure>
<h3 id="MonthDay">MonthDay</h3>
<p><code>java.time.MonthDay</code>代表月份和对应月份一共存在的天数，内部维护着整型的属性month和整型的属性day。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonthDayMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		MonthDay monthDay = MonthDay.now();</span><br><span class="line">		System.out.println(monthDay);</span><br><span class="line">		monthDay = MonthDay.of(<span class="number">2</span>, <span class="number">29</span>);</span><br><span class="line">		System.out.println(monthDay);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//某个时刻的输出结果</span></span><br><span class="line">--<span class="number">01</span>-<span class="number">01</span></span><br><span class="line">--<span class="number">02</span>-<span class="number">29</span></span><br></pre></td></tr></table></figure>
<p><code>MonthDay</code>通过静态工厂方法构建实例的时候会判断月份或者天数是否超过实际的限制，如果超限会抛异常。</p>
<h3 id="YearMonth">YearMonth</h3>
<p><code>java.time.YearMonth</code>代表年份和月份，内部维护着整型的属性month和整型的属性month。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YearMonthMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		YearMonth yearMonth = YearMonth.now();</span><br><span class="line">		System.out.println(yearMonth);</span><br><span class="line">		yearMonth = YearMonth.of(<span class="number">2019</span>, <span class="number">12</span>);</span><br><span class="line">		System.out.println(yearMonth);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<p>这里主要总结一下JSR-310的日期时间类之间的转换以及JSR-310的日期时间类和已经存在的旧Java日期时间类之间的转换关系。</p>
<h3 id="Instant和其他日期时间类互转">Instant和其他日期时间类互转</h3>
<p>如果有注意到上面介绍日期时间类的时候会发现每个类的工厂方法都包含<code>ofInstant()</code>方法，也就是<code>Instant</code>实例可以转化为其他日期时间类实例，这里总结一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantConvertTo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Instant instant = Instant.now();</span><br><span class="line">		ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zoneId);</span><br><span class="line">		LocalDate localDate = LocalDate.ofInstant(instant, zoneId);</span><br><span class="line">		LocalTime localTime = LocalTime.ofInstant(instant, zoneId);</span><br><span class="line">		OffsetTime offsetTime = OffsetTime.ofInstant(instant, zoneId);</span><br><span class="line">		OffsetDateTime offsetDateTime = OffsetDateTime.ofInstant(instant,zoneId);</span><br><span class="line">		ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(instant, zoneId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实很好理解，即使在旧的Java日期时间API中，长整型的时间戳毫秒也可以通过各种日期时间类的构造或者静态工厂方法创建对应的实例。值得注意的是，只有同时包含日期和时间的类才能转换为<code>Instant</code>实例，这一点也很好理解，只包含时间或者只包含日期的类转换成瞬时时间会丢失部分时间值。这里举个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantConvertFrom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 这里只以LocalDateTime为例,其他类似</span></span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		Instant instant = localDateTime.toInstant(ZoneOffset.UTC);</span><br><span class="line">		<span class="comment">// 或者</span></span><br><span class="line">		instant = Instant.ofEpochMilli(localDateTime.toEpochSecond(ZoneOffset.UTC) * <span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSR-310日期时间类之间互相转换">JSR-310日期时间类之间互相转换</h3>
<p>日期时间类本身就包含日期和时间的维度，一般它们直接保存时间类实例作为成员属性，所以转换也十分方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeToTime</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">		LocalTime localTime = localDateTime.toLocalTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日期类不包含时间部分，所以日期类转换为日期时间类的时候，时间部分会取最小，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateToDateTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		LocalDate localDate = LocalDate.now();</span><br><span class="line">		System.out.println(localDate);</span><br><span class="line">		LocalDateTime localDateTime = localDate.atStartOfDay();</span><br><span class="line">		System.out.println(localDateTime);</span><br><span class="line">		ZonedDateTime zonedDateTime = localDate.atStartOfDay(ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 某个时刻的输出如下</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">00</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">01</span>T00:<span class="number">00</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>
<p>带有时区ID(时间偏移量或者地区)的类型可以轻易转变为不带有时区ID的类型，如果要反过来，则需要添加对应的时区ID属性，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdDateTimeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());</span><br><span class="line">		System.out.println(zonedDateTime);</span><br><span class="line">		LocalDateTime localDateTime = zonedDateTime.toLocalDateTime();</span><br><span class="line">		LocalDate localDate = zonedDateTime.toLocalDate();</span><br><span class="line">		LocalTime localTime = zonedDateTime.toLocalTime();</span><br><span class="line">		zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.systemDefault());</span><br><span class="line"></span><br><span class="line">		OffsetDateTime offsetDateTime = OffsetDateTime.of(LocalDateTime.now(), ZoneOffset.UTC);</span><br><span class="line">		localDateTime = offsetDateTime.toLocalDateTime();</span><br><span class="line">		localDate = offsetDateTime.toLocalDate();</span><br><span class="line">		localTime = offsetDateTime.toLocalTime();</span><br><span class="line">		offsetDateTime = OffsetDateTime.of(localDateTime, ZoneOffset.UTC);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSR-310中的类和旧的日期时间相关类之间的转换">JSR-310中的类和旧的日期时间相关类之间的转换</h3>
<p><code>java.sql.Timestamp</code>和<code>java.time.LocalDateTime</code>之间的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampLocalDateTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">		Timestamp timestamp = Timestamp.valueOf(localDateTime);</span><br><span class="line">		LocalDateTime ldt = timestamp.toLocalDateTime();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.sql.Date</code>和<code>java.time.LocalDate</code>之间的转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateLocalDate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Date date = <span class="keyword">new</span> Date(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		LocalDate localDate = date.toLocalDate();</span><br><span class="line">		date = <span class="keyword">new</span> Date(localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要是能使用毫秒表示的旧的日期时间类，都可以和<code>java.time.Instant</code>相互转换，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToInstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Timestamp timestamp = <span class="keyword">new</span> Timestamp(System.currentTimeMillis());</span><br><span class="line">		Instant instant = timestamp.toInstant();</span><br><span class="line">		java.util.Date date = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">		instant = date.toInstant();</span><br><span class="line">		timestamp = <span class="keyword">new</span> Timestamp(instant.toEpochMilli());</span><br><span class="line">		date = <span class="keyword">new</span> Date(instant.toEpochMilli());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>JSR-310的新时间日期类库的设计相比已经存在的旧的日期时间类库来说，个人认为有以下的优点：</p>
<ul>
<li>线程安全。</li>
<li>类的职责更加分明，时间、日期、日期时间需要使用明确的类去表示。</li>
<li>API封装更加合理，使得易用性提高。</li>
</ul>
<p>不过会存在一些问题，最明显的是已有的旧类库存在兼容性问题，例如JDBC模块里面处理日期时间需要进行新的日期时间类和<code>java.sql.Timestamp</code>进行转换的问题，不过转换成本并不高。</p>
<p>(本文完 c-3-d e-a-20181230)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/23/java-jsr310-zone-id/">
      JSR310新日期API(一)-时区与时间偏移量
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月23日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.2k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：12分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-01T22:04:05+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月1日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>JSR310新日期API(一)-时区与时间偏移量</h1>
<h2 id="前提">前提</h2>
<p>最近刚好有新项目使用到JSR-310(JDK8)中引入的新日期API，打算做一下总结。本文编写基于JDK11，部分API可能是JDK9之后新增的。</p>
<h2 id="地理知识补充">地理知识补充</h2>
<p>主要补充一下一些地理知识：时区、UTC、GMT、CST、DST和ISO-8601的相关概念。</p>
<h3 id="时区">时区</h3>
<p>时区(Time Zone)是地球上的区域使用同一个时间定义。1884年在华盛顿召开国际经度会议时，为了克服时间上的混乱，规定将全球划分为24个时区。造成时间上的混乱是由于世界各个国家位于地球不同位置上，因此不同国家，特别是东西跨度大的国家日出、日落时间必定有所偏差(<strong>这个偏差我们通常叫做时差</strong>)。</p>
<p>前边提到全球共分为24个时区(<strong>东、西各12个时区</strong>)，也就是每个时区的经度宽度为15度，其中本初子午线(0度经线)为0时区的中心线，而东、西12时区合并为一个时区，这些时区的经度分布如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">时区</th>
<th style="text-align:center">时区经度范围</th>
<th style="text-align:center">时区中心线</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UTC(0时区)</td>
<td style="text-align:center">7.5°W~7.5°E</td>
<td style="text-align:center">0°</td>
</tr>
<tr>
<td style="text-align:center">UTC+1(东1区)</td>
<td style="text-align:center">7.5°E~22.5°E</td>
<td style="text-align:center">15°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+2(东2区)</td>
<td style="text-align:center">22.5°E~37.5°E</td>
<td style="text-align:center">30°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+3(东3区)</td>
<td style="text-align:center">37.5°E~52.5°E</td>
<td style="text-align:center">45°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+4(东4区)</td>
<td style="text-align:center">52.5°E~67.5°E</td>
<td style="text-align:center">60°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+5(东5区)</td>
<td style="text-align:center">67.5°E~82.5°E</td>
<td style="text-align:center">75°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+6(东6区)</td>
<td style="text-align:center">82.5°E~97.5°E</td>
<td style="text-align:center">90°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+7(东7区)</td>
<td style="text-align:center">97.5°E~112.5°E</td>
<td style="text-align:center">105°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+8(东8区)</td>
<td style="text-align:center">112.5°E~127.5°E</td>
<td style="text-align:center">120°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+9(东9区)</td>
<td style="text-align:center">127.5°E~142.5°E</td>
<td style="text-align:center">135°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+10(东10区)</td>
<td style="text-align:center">142.5°E~157.5°E</td>
<td style="text-align:center">150°E</td>
</tr>
<tr>
<td style="text-align:center">UTC+11(东11区)</td>
<td style="text-align:center">157.5°E~172.5°E</td>
<td style="text-align:center">165°E</td>
</tr>
<tr>
<td style="text-align:center">UTC12(东、西12区)</td>
<td style="text-align:center">172.5°E~172.5°W</td>
<td style="text-align:center">180°</td>
</tr>
<tr>
<td style="text-align:center">UTC-11(西11区)</td>
<td style="text-align:center">172.5°W~157.5°W</td>
<td style="text-align:center">165°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-10(西10区)</td>
<td style="text-align:center">157.5°W~142.5°W</td>
<td style="text-align:center">150°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-9(西9区)</td>
<td style="text-align:center">142.5°W~127.5°W</td>
<td style="text-align:center">135°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-8(西8区)</td>
<td style="text-align:center">127.5°W~112.5°W</td>
<td style="text-align:center">120°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-7(西7区)</td>
<td style="text-align:center">112.5°W~97.5°W</td>
<td style="text-align:center">105°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-6(西6区)</td>
<td style="text-align:center">97.5°W~82.5°W</td>
<td style="text-align:center">90°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-5(西5区)</td>
<td style="text-align:center">82.5°W~67.5°W</td>
<td style="text-align:center">75°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-4(西4区)</td>
<td style="text-align:center">67.5°W~52.5°W</td>
<td style="text-align:center">60°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-3(西3区)</td>
<td style="text-align:center">52.5°W~37.5°W</td>
<td style="text-align:center">45°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-2(西2区)</td>
<td style="text-align:center">37.5°W~22.5°W</td>
<td style="text-align:center">30°W</td>
</tr>
<tr>
<td style="text-align:center">UTC-1(西1区)</td>
<td style="text-align:center">22.5°W~7.5°W</td>
<td style="text-align:center">15°W</td>
</tr>
</tbody>
</table>
<p>但是实际上，通常1个国家或1个省份同时跨着多个时区，是因为为了照顾到行政上的方便，常将1个国家或1个省份划在同一个时区。例如，中国跨5个时区，但为了使用方便简单并且全国统一使用一个区时，实际上在中国使用东8区的区时一般称为北京时间作为标准时间。全球的标准时区划分如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/Standard_World_Time_Zones.png" alt="Standard_World_Time_Zones"></p>
<h3 id="UTC、GMT、CST、DST与ISO-8601">UTC、GMT、CST、DST与ISO-8601</h3>
<p><strong>GMT</strong>，Greenwich Mean Time，格林尼治(或者有时候翻译为格林威治)标准时间，是指位于伦敦郊区的皇家格林尼治天文台的标准时间。<strong>格林尼治所在地的标准时间也叫世界时UT</strong>。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点(见分至点)和平太阳，由此确定的时间分别称为恒星时和平太阳时。对于世界上发生的重大事件，都以格林尼治的地方时间记录下来。一旦知道了格林尼治时间，人们就很容易推算出相对应的本地时间。指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。 自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息。 格林威治子午线上的地方时，或零时区（中时区）的区时叫做格林威治时间(又译为&quot;格林尼治时间&quot;)，也叫&quot;世界时&quot;。原是采用格林威治的平正午作为一个平太阳日的开始，但在使用中有些不便。因此，国际天文学联合会于1928年决定，将由格林威治平子夜起算的平太阳时作为世界时，也就是通常所说的<strong>格林威治时间</strong>。格林威治时间所在时区为0时区，可以推算出使用GMT+8表示中国的时间，是因为中国位于东八区，时间上比格林威治时间快8个小时。</p>
<p><strong>UTC</strong>，Coordinated Universal Time，也就是协调世界时，由于英文(CUT)和法文(TUC)的缩写不同，作为妥协，简称UTC。协调世界时是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统(<strong>由实验室用足够精确的铯原子钟导出的时间作为原子时，原子时的精确度极高，精度可以达到每2000万年才误差1秒</strong>)。国际原子时的准确度为每日数纳秒，而世界时的准确度为每日数毫秒。许多应用部门要求时间系统接近世界时UT，对于这种情况，一种称为协调世界时的折衷时标于1972年面世。为确保协调世界时与世界时相差不会超过0.9秒，在有需要的情况下会在协调世界时内加上正或负闰秒。因此协调世界时与国际原子时之间会出现若干整数秒的差别，两者之差逐年积累，便采用跳秒(闰秒)的方法使协调时与世界时的时刻相接近，其差不超过1s。<strong>通常将GMT和UTC视作等同</strong>，但UTC更加科学更加精确，它是以原子时为基础，在时刻上尽量接近世界时的一种时间计量系统。类似的，可以使用UTC+8表示中国的时间。</p>
<p><strong>CST</strong>，China Standard Time，也就是中国标准时间，当格林威治时间为凌晨0:00时，中国标准时间正好为上午8:00，也就是CST实际上是参照于UTC，通用公式为：CST = UTC/GMT +8。</p>
<p><strong>DST</strong>，Daylight Saving Time，阳光节约时，在我国称为夏时制，又称夏令时，是一种为节约能源而人为调整地方时间的制度。有些国家DST的使用时间较长，(如美国长达7个月)跨越了春夏秋等三个季节，因此简单地用夏时制的概念已经不能完全表达DST的确切含义了，所以有人也称其为节能时。所谓的DST，就是利用夏季天亮得早这一自然现象，人为地将时间提前一小时。这样就可以使人们早起早睡，以充分利用光照资源，减少照明时间，从而节约照明用电。目前中国已经弃用DST。</p>
<p><strong>ISO-8601</strong>，是国际标准化组织的日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是2004年12月1日发行的第三版&quot;ISO8601:2004&quot;以替代1998年的第一版&quot;ISO8601:1988&quot;与2000年的第二版&quot;ISO8601:2000&quot;。该表示方法规定：年由4位数字组成YYYY，或者带正负号的四或五位数字表示±YYYYY，月、日用两位数字表示：MM、DD。只使用数字为基本格式。使用短横线&quot;-“间隔开年、月、日为扩展格式。时间只使用数字为基本格式。使用冒号”:&quot;间隔开小时、分、秒的为扩展格式。小时、分和秒都用2位数表示。合并表示时，要在时间前面加一大写字母T，如要表示北京时间2004年5月3日下午5点30分8秒，可以写成2004-05-03T17:30:08+08:00或20040503T173008+08。如果时间在零时区，并恰好与协调世界时相同，那么(不加空格地)在时间最后加一个大写字母Z。Z是相对协调世界时时间0偏移的代号。如下午2点30分5秒表示为14:30:05Z或143005Z；只表示小时和分，为1430Z或14:30Z；只表示小时，则为14Z或14Z。其他时区用实际时间加时差表示，当时的UTC+8时间表示为22:30:05+08:00或223005+0800，也可以简化成223005+08。Java中已存在的类<code>java.util.Date</code>默认就是使用ISO-8601表示的。</p>
<h2 id="ZoneId">ZoneId</h2>
<p>JSR-310中引入了抽象类<code>java.time.ZoneId</code>表示时区ID，它是旧API<code>java.util.TimeZone</code>的替代。<code>ZoneRulesProvider</code>用于加载Zone Rule(时区规则，ZoneRules)，自定义实现是可以通过系统变量设置<code>java.time.zone.DefaultZoneRulesProvider=全类名</code>为<code>ZoneRulesProvider</code>自定义的提供类，或者通过SPI加载，默认的实现类是<code>TzdbZoneRulesProvider</code>，<code>TzdbZoneRulesProvider</code>会加载${JAVA_HONE}/lib/tzdb.dat文件(可以打开这个文件看下里面是怎么定义和描述时区的相应规则，这里不做详细分析，实际上如果深入了解这个规则文件的定义可以自行编写规则文件和实现加载类加载自定义的规则)，这个DAT文件中存放着时区的规则映射。<code>ZoneId</code>就是时区ID主要用于定制<code>Instant</code>和<code>LocalDateTime</code>之间的转换规则的。时区ID一共有两种不同的类型：</p>
<ul>
<li>固定时间偏移量(Fixed Offset) - 实际上对应<code>ZoneOffset</code>。</li>
<li>地理区域(Geographical Region) - 实际上对应<code>ZoneRegion</code>。</li>
</ul>
<p>静态方法<code>ZoneId#of(String zoneId)</code>会根据入参自动适配最终的时区ID到底表示固定时间偏移量还是地理区域，此方法支持如下的参数：</p>
<ul>
<li>
<p>地理区域参数，形式是：洲(州、国家)/城市，如<code>ZoneId.of(&quot;Asia/Shanghia&quot;)</code>，值得注意的是默认加载的规则里面没有北京。</p>
</li>
<li>
<p>固定时间偏移量格式(offset-style)，支持的格式比较多：</p>
<ul>
<li>UTC或者GMT。</li>
<li>Z(相当于UTC)。</li>
<li>+h或者-h。</li>
<li>+hh或者-hh。</li>
<li>+hh:mm或者-hh:mm。</li>
<li>+hh:mm:ss或者-hh:mm:ss。</li>
<li>+hhmmss或者-hhmmss。</li>
</ul>
</li>
</ul>
<p>基于固定时间偏移量格式举几个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZoneId z;</span><br><span class="line">z = ZoneId.of(<span class="string">"Z"</span>); <span class="comment">//for UTC</span></span><br><span class="line">z = ZoneId.of(<span class="string">"+02:00"</span>);</span><br><span class="line">z = ZoneId.of(<span class="string">"-02:00"</span>);</span><br><span class="line"></span><br><span class="line">ZoneId.of(<span class="string">"GMT+2"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"UTC"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"UT+01:00"</span>);</span><br><span class="line"></span><br><span class="line">ZoneId.of(<span class="string">"Asia/Aden"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"Etc/GMT+9"</span>);</span><br><span class="line">ZoneId.of(<span class="string">"Asia/Aqtau"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="固定时间偏移量-ZoneOffset">固定时间偏移量-ZoneOffset</h3>
<p><code>java.time.ZoneOffset</code>是<code>java.time.ZoneId</code>实现类，表示固定时间偏移量，这个偏移量是以格林尼治(GMT)/协调世界时(UTC)为基准的偏移时间量。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneOffsetMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+02:00"</span>);</span><br><span class="line">		System.out.println(zoneOffset);</span><br><span class="line">		zoneOffset = ZoneOffset.of(<span class="string">"-02:00"</span>);</span><br><span class="line">		System.out.println(zoneOffset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ZoneOffset.of(&quot;+02:00&quot;)</code>表示UTC下2小时的时间偏移(简单理解为东2区)，<code>ZoneOffset.of(&quot;-02:00&quot;)</code>表示UTC下-2小时的时间偏移(简单理解为西2区)。</p>
<h3 id="地理区域-ZoneRegion">地理区域-ZoneRegion</h3>
<p><code>java.time.ZoneRegion</code>是<code>java.time.ZoneId</code>实现类(不过其修饰符为default，因此无法直接访问，只能通过<code>ZoneId</code>操作)，表示地理区域，格式是：洲(州、国家)/城市。注释中提到：最常见的区域分类是时区数据库(TZDB)，TZDB使用Europe/Paris’和’Asia/Tokyo’等形式区分地区。举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneRegionMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">		System.out.println(zoneId);</span><br><span class="line">		Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">		<span class="keyword">for</span> (String z : availableZoneIds) &#123;</span><br><span class="line">			<span class="keyword">if</span> (z.contains(<span class="string">"Beijing"</span>) || z.contains(<span class="string">"BeiJing"</span>)) &#123;</span><br><span class="line">				System.out.println(z);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后控制台输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>
<p>实际上，执行这个方法的时候，笔者在广州，得到的系统默认zoneId是Asia/Shanghai，并且默认加载的地理区域中没有北京相关的zoneId。</p>
<h2 id="小结">小结</h2>
<p>JSR-310中引入的时间API类<code>ZoneId</code>表示时区ID，具体有两种类型：固定时间偏移量-<code>ZoneOffset</code>和地理区域-<code>ZoneRegion</code>，这两种类型可以再细分为三种表示方式：</p>
<ul>
<li>地理区域表示，如：<code>ZoneId.of(&quot;Asia/Aden&quot;)</code>。</li>
<li>GMT/UTC偏移量详细表示，如：<code>ZoneId.of(&quot;UTC&quot;)</code>、<code>ZoneId.of(&quot;GMT+2&quot;)</code>。</li>
<li>GMT/UTC偏移量简单表示，如：<code>ZoneId.of(&quot;Z&quot;)</code>、<code>ZoneId.of(&quot;+2:00&quot;)</code>。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Time_zone" target="_blank" rel="noopener">维基百科-Time zone</a></li>
<li><a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">维基百科-ISO 8601</a></li>
<li>Bing互动百科相关资料</li>
<li><a href="https://stackoverflow.com/questions/32931871/java-8-how-to-derive-a-zoneid-from-zoneoffset" target="_blank" rel="noopener">Java 8: how to derive a ZoneId from ZoneOffset</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 c-1-d e-a-20181223)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/JSR-310/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> JSR-310</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/blog/tags/Java/page/2/">
            <section class="post prev white-box card-shadow " >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          3 / 5
        </p>
        
          <a class="next" rel="next" href="/blog/tags/Java/page/4/">
            <section class="post next white-box card-shadow ">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


    
  
</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
