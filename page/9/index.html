<!DOCTYPE html>
<html>
<head hexo-theme='Volantis' version='1.5.2' docs='https://xaoxuu.com/wiki/volantis/'>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Throwable&#39;s Blog</title>
  
  <meta name="keywords" content="thorwable,doge,Thorwable">
  
  
  <meta name="description" content="一棵还在尝试努力生存的90后韭菜Doge">
  

  
  <link rel="alternate" href="/atom.xml" title="Throwable's Blog">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/gb.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_favicon.ico">
  

  

  
    
<link rel="stylesheet" href="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/css/throwable.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4df6907aebab752244c3ca1432b4ff57";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

<body>
  
  
  <header class="l_header ">
  <div id="loading-bar-wrapper">
    <div id="loading-bar"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" target="_self" href='/' >
        
          
          
            Throwable
          
        
      </a>
			<div class='menu navigation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/"
                  
                  
                    target="_self"
                  
                  id="home">
									<i class='fas fa-hourglass-half fa-fw'></i>&nbsp;近期
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/categories/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="categories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/tags/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="tags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/friends/"
                  
                    rel="nofollow"
                  
                  
                  id="friends">
									<i class='fas fa-link fa-fw'></i>&nbsp;友接
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/about/"
                  
                    rel="nofollow"
                  
                  
                    target="_self"
                  
                  id="about">
									<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于
								</a>
							</li>
      			
      		
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="(゜-゜)つロ搜一搜有没有想看的" />
        </form>
      </div>

			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone white-box">
    <header>
		<nav class="menu navigation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/"
                
                
                id="home">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                  rel="nofollow"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/projects/"
                
                
                id="projects">
								<i class='fas fa-code-branch fa-fw'></i>&nbsp;开源项目
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/friends/"
                
                  rel="nofollow"
                
                
                id="friends">
								<i class='fas fa-link fa-fw'></i>&nbsp;我的友链
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/about/"
                
                  rel="nofollow"
                
                
                id="about">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      <div class='l_main'>
  
  <section class="post-list ">
    
    
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/zookeeper-curator-usage/">
      Zookeeper客户端Curator使用详解
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Middleware/Zookeeper/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Middleware&nbsp;/&nbsp;Zookeeper</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：12.8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：58分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T15:39:39+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>Zookeeper客户端Curator使用详解</h1>
<h2 id="前提">前提</h2>
<p>因为最近项目需要使用Zookeeper这个中间件，提前了解一下它的客户端Curator的使用。</p>
<h2 id="简介">简介</h2>
<p>Curator是Netflix公司开源的一套zookeeper客户端框架，解决了很多Zookeeper客户端非常底层的细节开发工作，包括连接重连、反复注册Watcher和NodeExistsException异常等等。Patrixck Hunt（Zookeeper）以一句“Guava is to Java that Curator to Zookeeper”给Curator予高度评价。</p>
<p><strong>引子和趣闻：</strong><br>
Zookeeper名字的由来是比较有趣的，下面的片段摘抄自《从PAXOS到ZOOKEEPER分布式一致性原理与实践》一书：<br>
Zookeeper最早起源于雅虎的研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型的系统需要依赖一个类似的系统进行分布式协调，但是这些系统往往存在分布式单点问题。所以雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架。在立项初期，考虑到很多项目都是用动物的名字来命名的(例如著名的Pig项目)，雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家Raghu Ramakrishnan开玩笑说：再这样下去，我们这儿就变成动物园了。此话一出，大家纷纷表示就叫动物园管理员吧——因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而Zookeeper正好用来进行分布式环境的协调——于是，Zookeeper的名字由此诞生了。</p>
<p>Curator无疑是Zookeeper客户端中的瑞士军刀，它译作&quot;馆长&quot;或者’‘管理者’’，不知道是不是开发小组有意而为之，笔者猜测有可能这样命名的原因是说明Curator就是Zookeeper的馆长(脑洞有点大：Curator就是动物园的园长)。<br>
Curator包含了几个包：</p>
<ul>
<li><strong>curator-framework</strong>：对zookeeper的底层api的一些封装。</li>
<li><strong>curator-client</strong>：提供一些客户端的操作，例如重试策略等。</li>
<li><strong>curator-recipes</strong>：封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式Barrier等。</li>
</ul>
<p>Maven依赖(使用curator的版本：2.12.0，对应Zookeeper的版本为：3.4.x，<strong>如果跨版本会有兼容性问题，很有可能导致节点操作失败</strong>)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>Curator的基本Api</h1>
<h2 id="创建会话">创建会话</h2>
<h3 id="1-使用静态工程方法创建客户端">1.使用静态工程方法创建客户端</h3>
<p>一个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework client =</span><br><span class="line">CuratorFrameworkFactory.newClient(</span><br><span class="line">						connectionInfo,</span><br><span class="line">						<span class="number">5000</span>,</span><br><span class="line">						<span class="number">3000</span>,</span><br><span class="line">						retryPolicy);</span><br></pre></td></tr></table></figure>
<p>newClient静态工厂方法包含四个主要参数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">connectionString</td>
<td style="text-align:center">服务器列表，格式host1:port1,host2:port2,…</td>
</tr>
<tr>
<td style="text-align:left">retryPolicy</td>
<td style="text-align:center">重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口</td>
</tr>
<tr>
<td style="text-align:left">sessionTimeoutMs</td>
<td style="text-align:center">会话超时时间，单位毫秒，默认60000ms</td>
</tr>
<tr>
<td style="text-align:left">connectionTimeoutMs</td>
<td style="text-align:center">连接创建超时时间，单位毫秒，默认60000ms</td>
</tr>
</tbody>
</table>
<h3 id="2-使用Fluent风格的Api创建会话">2.使用Fluent风格的Api创建会话</h3>
<p>核心参数变为流式设置，一个列子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">      RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework client =</span><br><span class="line">CuratorFrameworkFactory.builder()</span><br><span class="line">		.connectString(connectionInfo)</span><br><span class="line">		.sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">		.connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">		.retryPolicy(retryPolicy)</span><br><span class="line">		.build();</span><br></pre></td></tr></table></figure>
<h3 id="3-创建包含隔离命名空间的会话">3.创建包含隔离命名空间的会话</h3>
<p>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（<strong>NameSpace</strong>），即指定一个Zookeeper的根路径（官方术语：<em><strong>为Zookeeper添加“Chroot”特性</strong></em>）。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">		CuratorFramework client =</span><br><span class="line">		CuratorFrameworkFactory.builder()</span><br><span class="line">				.connectString(connectionInfo)</span><br><span class="line">				.sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">				.connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">				.retryPolicy(retryPolicy)</span><br><span class="line">				.namespace(<span class="string">"base"</span>)</span><br><span class="line">				.build();</span><br></pre></td></tr></table></figure>
<h2 id="启动客户端">启动客户端</h2>
<p>当创建会话成功，得到client的实例然后可以直接调用其start( )方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.start();</span><br></pre></td></tr></table></figure>
<h2 id="数据节点操作">数据节点操作</h2>
<h3 id="创建数据节点">创建数据节点</h3>
<p><strong>Zookeeper的节点创建模式</strong>：</p>
<ul>
<li>PERSISTENT：持久化</li>
<li>PERSISTENT_SEQUENTIAL：持久化并且带序列号</li>
<li>EPHEMERAL：临时</li>
<li>EPHEMERAL_SEQUENTIAL：临时并且带序列号</li>
</ul>
<p><strong>创建一个节点，初始内容为空</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：如果没有设置节点属性，节点创建模式默认为持久化节点，内容默认为空</p>
<p><strong>创建一个节点，附带初始化内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().forPath(&quot;path&quot;,&quot;init&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p><strong>创建一个节点，指定创建模式（临时节点），内容为空</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(&quot;path&quot;,&quot;init&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.create()</span><br><span class="line">      .creatingParentContainersIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .forPath(<span class="string">"path"</span>,<span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>这个creatingParentContainersIfNeeded()接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出NoNodeException，使用creatingParentContainersIfNeeded()之后Curator能够自动递归创建所有所需的父节点。</p>
<h3 id="删除数据节点">删除数据节点</h3>
<p><strong>删除一个节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意，此方法只能删除<strong>叶子节点</strong>，否则会抛出异常。</p>
<p><strong>删除一个节点，并且递归删除其所有的子节点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().deletingChildrenIfNeeded().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>删除一个节点，强制指定版本进行删除</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().withVersion(10086).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>删除一个节点，强制保证删除</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>guaranteed()接口是一个保障措施，只要客户端会话有效，那么Curator会在后台持续进行删除操作，直到删除节点成功。</p>
<p>**注意：**上面的多个流式接口是可以自由组合的，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.delete().guaranteed().deletingChildrenIfNeeded().withVersion(10086).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="读取数据节点数据">读取数据节点数据</h3>
<p><strong>读取一个节点的数据内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getData().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意，此方法返的返回值是byte[ ];</p>
<p><strong>读取一个节点的数据内容，同时获取到该节点的stat</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stat stat &#x3D; new Stat();</span><br><span class="line">client.getData().storingStatIn(stat).forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="更新数据节点数据">更新数据节点数据</h3>
<p><strong>更新一个节点的数据内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.setData().forPath(&quot;path&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<p>注意：该接口会返回一个Stat实例</p>
<p><strong>更新一个节点的数据内容，强制指定版本进行更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.setData().withVersion(10086).forPath(&quot;path&quot;,&quot;data&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="检查节点是否存在">检查节点是否存在</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.checkExists().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：该方法返回一个Stat实例，用于检查ZNode是否存在的操作. 可以调用额外的方法(监控或者后台处理)并在最后调用<code>forPath()</code>指定要操作的ZNode</p>
<h3 id="获取某个节点的所有子节点路径">获取某个节点的所有子节点路径</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.getChildren().forPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>
<p>注意：该方法的返回值为List<String>,获得ZNode的子节点Path列表。 可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的父ZNode</p>
<h3 id="事务">事务</h3>
<p>CuratorFramework的实例包含inTransaction( )接口方法，调用此方法开启一个ZooKeeper事务. 可以复合create, setData, check, and/or delete 等操作然后调用commit()作为一个原子操作提交。一个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client.inTransaction().check().forPath(<span class="string">"path"</span>)</span><br><span class="line">      .and()</span><br><span class="line">      .create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"path"</span>,<span class="string">"data"</span>.getBytes())</span><br><span class="line">      .and()</span><br><span class="line">      .setData().withVersion(<span class="number">10086</span>).forPath(<span class="string">"path"</span>,<span class="string">"data2"</span>.getBytes())</span><br><span class="line">      .and()</span><br><span class="line">      .commit();</span><br></pre></td></tr></table></figure>
<h3 id="异步接口">异步接口</h3>
<p>上面提到的创建、删除、更新、读取等方法都是同步的，Curator提供异步接口，引入了<strong>BackgroundCallback</strong>接口用于处理异步接口调用之后服务端返回的结果信息。<strong>BackgroundCallback</strong>接口中一个重要的回调值为CuratorEvent，里面包含事件类型、响应吗和节点的详细信息。</p>
<p><strong>CuratorEventType</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">事件类型</th>
<th style="text-align:center">对应CuratorFramework实例的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:center">#create()</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">#delete()</td>
</tr>
<tr>
<td style="text-align:center">EXISTS</td>
<td style="text-align:center">#checkExists()</td>
</tr>
<tr>
<td style="text-align:center">GET_DATA</td>
<td style="text-align:center">#getData()</td>
</tr>
<tr>
<td style="text-align:center">SET_DATA</td>
<td style="text-align:center">#setData()</td>
</tr>
<tr>
<td style="text-align:center">CHILDREN</td>
<td style="text-align:center">#getChildren()</td>
</tr>
<tr>
<td style="text-align:center">SYNC</td>
<td style="text-align:center">#sync(String,Object)</td>
</tr>
<tr>
<td style="text-align:center">GET_ACL</td>
<td style="text-align:center">#getACL()</td>
</tr>
<tr>
<td style="text-align:center">SET_ACL</td>
<td style="text-align:center">#setACL()</td>
</tr>
<tr>
<td style="text-align:center">WATCHED</td>
<td style="text-align:center">#Watcher(Watcher)</td>
</tr>
<tr>
<td style="text-align:center">CLOSING</td>
<td style="text-align:center">#close()</td>
</tr>
</tbody>
</table>
<p><strong>响应码(#getResultCode())</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">响应码</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">OK，即调用成功</td>
</tr>
<tr>
<td style="text-align:center">-4</td>
<td style="text-align:center">ConnectionLoss，即客户端与服务端断开连接</td>
</tr>
<tr>
<td style="text-align:center">-110</td>
<td style="text-align:center">NodeExists，即节点已经存在</td>
</tr>
<tr>
<td style="text-align:center">-112</td>
<td style="text-align:center">SessionExpired，即会话过期</td>
</tr>
</tbody>
</table>
<p>一个异步创建节点的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">client.create()</span><br><span class="line">      .creatingParentsIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .inBackground((curatorFramework, curatorEvent) -&gt; &#123;      System.out.println(String.format(<span class="string">"eventType:%s,resultCode:%s"</span>,curatorEvent.getType(),curatorEvent.getResultCode()));</span><br><span class="line">      &#125;,executor)</span><br><span class="line">      .forPath(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>
<p>注意：如果#inBackground()方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</p>
<h2 id="Curator食谱-高级特性">Curator食谱(高级特性)</h2>
<p><strong>提醒：首先你必须添加curator-recipes依赖，下文仅仅对recipes一些特性的使用进行解释和举例，不打算进行源码级别的探讨</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>重要提醒：强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，curator-recipes下的所有Api将会失效或者过期，尽管后面所有的例子都没有使用到ConnectionStateListener。</strong></p>
<h3 id="缓存">缓存</h3>
<p>Zookeeper原生支持通过注册Watcher来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。Cache是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听。Curator提供了三种Watcher(Cache)来监听结点的变化。</p>
<h4 id="Path-Cache">Path Cache</h4>
<p>Path Cache用来监控一个ZNode的子节点. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态，而状态的更变将通过PathChildrenCacheListener通知。</p>
<p>实际使用时会涉及到四个类：</p>
<ul>
<li>PathChildrenCache</li>
<li>PathChildrenCacheEvent</li>
<li>PathChildrenCacheListener</li>
<li>ChildData</li>
</ul>
<p>通过下面的构造函数创建Path Cache:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span></span><br></pre></td></tr></table></figure>
<p>想使用cache，必须调用它的<code>start</code>方法，使用完后调用<code>close</code>方法。 可以设置StartMode来实现启动的模式，</p>
<p>StartMode有下面几种：</p>
<ol>
<li>NORMAL：正常初始化。</li>
<li>BUILD_INITIAL_CACHE：在调用<code>start()</code>之前会调用<code>rebuild()</code>。</li>
<li>POST_INITIALIZED_EVENT： 当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件</li>
</ol>
<p><code>public void addListener(PathChildrenCacheListener listener)</code>可以增加listener监听缓存的变化。</p>
<p><code>getCurrentData()</code>方法返回一个<code>List&lt;ChildData&gt;</code>对象，可以遍历所有的子节点。</p>
<p><strong>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/pathCache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		client.start();</span><br><span class="line">		PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(client, PATH, <span class="keyword">true</span>);</span><br><span class="line">		cache.start();</span><br><span class="line">		PathChildrenCacheListener cacheListener = (client1, event) -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">"事件类型："</span> + event.getType());</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != event.getData()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"节点数据："</span> + event.getData().getPath() + <span class="string">" = "</span> + <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		cache.getListenable().addListener(cacheListener);</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(<span class="string">"/example/pathCache/test01"</span>, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(<span class="string">"/example/pathCache/test02"</span>, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		client.setData().forPath(<span class="string">"/example/pathCache/test01"</span>, <span class="string">"01_V2"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (ChildData data : cache.getCurrentData()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"getCurrentData:"</span> + data.getPath() + <span class="string">" = "</span> + <span class="keyword">new</span> String(data.getData()));</span><br><span class="line">		&#125;</span><br><span class="line">		client.delete().forPath(<span class="string">"/example/pathCache/test01"</span>);</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		client.delete().forPath(<span class="string">"/example/pathCache/test02"</span>);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		client.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**如果new PathChildrenCache(client, PATH, true)中的参数cacheData值设置为false，则示例中的event.getData().getData()、data.getData()将返回null，cache将不会缓存节点数据。</p>
<p>**注意：**示例中的Thread.sleep(10)可以注释掉，但是注释后事件监听的触发次数会不全，这可能与PathCache的实现原理有关，不能太过频繁的触发事件！</p>
<h4 id="Node-Cache">Node Cache</h4>
<p>Node Cache与Path Cache类似，Node Cache只是监听某一个特定的节点。它涉及到下面的三个类：</p>
<ul>
<li><code>NodeCache</code> - Node Cache实现类</li>
<li><code>NodeCacheListener</code> - 节点监听器</li>
<li><code>ChildData</code> - 节点数据</li>
</ul>
<p>**注意：**使用cache，依然要调用它的<code>start()</code>方法，使用完后调用<code>close()</code>方法。</p>
<p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/cache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		client.start();</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(PATH);</span><br><span class="line">		<span class="keyword">final</span> NodeCache cache = <span class="keyword">new</span> NodeCache(client, PATH);</span><br><span class="line">		NodeCacheListener listener = () -&gt; &#123;</span><br><span class="line">			ChildData data = cache.getCurrentData();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != data) &#123;</span><br><span class="line">				System.out.println(<span class="string">"节点数据："</span> + <span class="keyword">new</span> String(cache.getCurrentData().getData()));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"节点被删除!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">		cache.start();</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.delete().deletingChildrenIfNeeded().forPath(PATH);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		client.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**示例中的Thread.sleep(10)可以注释，但是注释后事件监听的触发次数会不全，这可能与NodeCache的实现原理有关，不能太过频繁的触发事件！</p>
<p>**注意：**NodeCache只能监听一个节点的状态变化。</p>
<h4 id="Tree-Cache">Tree Cache</h4>
<p>Tree Cache可以监控整个树上的所有节点，类似于PathCache和NodeCache的组合，主要涉及到下面四个类：</p>
<ul>
<li>TreeCache - Tree Cache实现类</li>
<li>TreeCacheListener - 监听器类</li>
<li>TreeCacheEvent - 触发的事件类</li>
<li>ChildData - 节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/cache"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		client.start();</span><br><span class="line">		client.create().creatingParentsIfNeeded().forPath(PATH);</span><br><span class="line">		TreeCache cache = <span class="keyword">new</span> TreeCache(client, PATH);</span><br><span class="line">		TreeCacheListener listener = (client1, event) -&gt;</span><br><span class="line">				System.out.println(<span class="string">"事件类型："</span> + event.getType() +</span><br><span class="line">						<span class="string">" | 路径："</span> + (<span class="keyword">null</span> != event.getData() ? event.getData().getPath() : <span class="keyword">null</span>));</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">		cache.start();</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"01"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.setData().forPath(PATH, <span class="string">"02"</span>.getBytes());</span><br><span class="line">		Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		client.delete().deletingChildrenIfNeeded().forPath(PATH);</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">2</span>);</span><br><span class="line">		cache.close();</span><br><span class="line">		client.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**在此示例中没有使用Thread.sleep(10)，但是事件触发次数也是正常的。</p>
<p>**注意：**TreeCache在初始化(调用<code>start()</code>方法)的时候会回调<code>TreeCacheListener</code>实例一个事TreeCacheEvent，而回调的TreeCacheEvent对象的Type为INITIALIZED，ChildData为null，此时<code>event.getData().getPath()</code>很有可能导致空指针异常，这里应该主动处理并避免这种情况。</p>
<h3 id="Leader选举">Leader选举</h3>
<p>在分布式计算中， <strong>leader elections</strong>是很重要的一个功能， 这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是leader(领导者)或者coordinator(协调者). 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务leader. 除此之外， 选举还经常会发生在leader意外宕机的情况下，新的leader要被选举出来。</p>
<p>在zookeeper集群中，leader负责写操作，然后通过Zab协议实现follower的同步，leader或者follower都可以处理读操作。</p>
<p>Curator 有两种leader选举的recipe,分别是<strong>LeaderSelector</strong>和<strong>LeaderLatch</strong>。</p>
<p>前者是所有存活的客户端不间断的轮流做Leader，大同社会。后者是一旦选举出Leader，除非有客户端挂掉重新触发选举，否则不会交出领导权。某党?</p>
<h4 id="LeaderLatch">LeaderLatch</h4>
<p>LeaderLatch有两个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath,  String id)</span></span></span><br></pre></td></tr></table></figure>
<p>LeaderLatch的启动：</p>
<p><strong>leaderLatch.start( );</strong></p>
<p>一旦启动，LeaderLatch会和其它使用相同latch path的其它LeaderLatch交涉，然后其中一个最终会被选举为leader，可以通过<code>hasLeadership</code>方法查看LeaderLatch实例是否leader：</p>
<p><strong>leaderLatch.hasLeadership( );</strong>     //返回true说明当前实例是leader</p>
<p>类似JDK的CountDownLatch， LeaderLatch在请求成为leadership会block(阻塞)，一旦不使用LeaderLatch了，必须调用<code>close</code>方法。 如果它是leader,会释放leadership， 其它的参与者将会选举一个leader。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,EOFException</span></span><br><span class="line"><span class="function"><span class="comment">/*Causes the current thread to wait until this instance acquires leadership</span></span></span><br><span class="line"><span class="function"><span class="comment">unless the thread is interrupted or closed.*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p><strong>异常处理：</strong> LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader。当LOST后连接重连后RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个。LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p>
<p>一个LeaderLatch的使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderLatchDemo</span> <span class="keyword">extends</span> <span class="title">BaseConnectionInfo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> String PATH = <span class="string">"/francis/leader"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">		List&lt;LeaderLatch&gt; examples = Lists.newArrayList();</span><br><span class="line">		TestingServer server=<span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; i++) &#123;</span><br><span class="line">				CuratorFramework client</span><br><span class="line">						= CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">20000</span>, <span class="number">3</span>));</span><br><span class="line">				clients.add(client);</span><br><span class="line">				LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line">				latch.addListener(<span class="keyword">new</span> LeaderLatchListener() &#123;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						System.out.println(<span class="string">"I am Leader"</span>);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						System.out.println(<span class="string">"I am not Leader"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				examples.add(latch);</span><br><span class="line">				client.start();</span><br><span class="line">				latch.start();</span><br><span class="line">			&#125;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			LeaderLatch currentLeader = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">				<span class="keyword">if</span> (latch.hasLeadership()) &#123;</span><br><span class="line">					currentLeader = latch;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">			System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">			currentLeader.close();</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">				<span class="keyword">if</span> (latch.hasLeadership()) &#123;</span><br><span class="line">					currentLeader = latch;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">			System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> != latch.getState())</span><br><span class="line">				CloseableUtils.closeQuietly(latch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(client);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以添加test module的依赖方便进行测试，不需要启动真实的zookeeper服务端：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先我们创建了10个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>
通过<code>hasLeadership</code>查看自己是否是leader， 如果是的话返回true。<br>
可以通过<code>.getLeader().getId()</code>可以得到当前的leader的ID。<br>
只能通过<code>close</code>释放当前的领导权。<br>
<code>await</code>是一个阻塞方法， 尝试获取leader地位，但是未必能上位。</p>
<h4 id="LeaderSelector">LeaderSelector</h4>
<p>LeaderSelector使用的时候主要涉及下面几个类：</p>
<ul>
<li>LeaderSelector</li>
<li>LeaderSelectorListener</li>
<li>LeaderSelectorListenerAdapter</li>
<li>CancelLeadershipException</li>
</ul>
<p>核心类是LeaderSelector，它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></span></span><br></pre></td></tr></table></figure>
<p>类似LeaderLatch,LeaderSelector必须<code>start</code>: <code>leaderSelector.start();</code> 一旦启动，当实例取得领导权时你的listener的<code>takeLeadership()</code>方法被调用。而takeLeadership()方法只有领导权被释放时才返回。 当你不再使用LeaderSelector实例时，应该调用它的close方法。</p>
<p><strong>异常处理</strong> LeaderSelectorListener类继承ConnectionStateListener。LeaderSelector必须小心连接状态的改变。如果实例成为leader, 它应该响应SUSPENDED 或 LOST。 当 SUSPENDED 状态出现时， 实例必须假定在重新连接成功之前它可能不再是leader了。 如果LOST状态出现， 实例不再是leader， takeLeadership方法返回。</p>
<p><strong>重要</strong>: 推荐处理方式是当收到SUSPENDED 或 LOST时抛出CancelLeadershipException异常.。这会导致LeaderSelector实例中断并取消执行takeLeadership方法的异常.。这非常重要， 你必须考虑扩展LeaderSelectorListenerAdapter. LeaderSelectorListenerAdapter提供了推荐的处理逻辑。</p>
<p>下面的一个例子摘抄自官方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorAdapter</span> <span class="keyword">extends</span> <span class="title">LeaderSelectorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger leaderCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LeaderSelectorAdapter</span><span class="params">(CuratorFramework client, String path, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		leaderSelector = <span class="keyword">new</span> LeaderSelector(client, path, <span class="keyword">this</span>);</span><br><span class="line">		leaderSelector.autoRequeue();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		leaderSelector.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		leaderSelector.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> waitSeconds = (<span class="keyword">int</span>) (<span class="number">5</span> * Math.random()) + <span class="number">1</span>;</span><br><span class="line">		System.out.println(name + <span class="string">" is now the leader. Waiting "</span> + waitSeconds + <span class="string">" seconds..."</span>);</span><br><span class="line">		System.out.println(name + <span class="string">" has been leader "</span> + leaderCount.getAndIncrement() + <span class="string">" time(s) before."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.err.println(name + <span class="string">" was interrupted."</span>);</span><br><span class="line">			Thread.currentThread().interrupt();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(name + <span class="string">" relinquishing leadership.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在takeLeadership进行任务的分配等等，并且不要返回，如果你想要要此实例一直是leader的话可以加一个死循环。调用 <code>leaderSelector.autoRequeue();</code>保证在此实例释放领导权之后还可能获得领导权。 在这里我们使用AtomicInteger来记录此client获得领导权的次数， 它是”fair”， 每个client有平等的机会获得领导权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> String PATH = <span class="string">"/francis/leader"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">		List&lt;LeaderSelectorAdapter&gt; examples = Lists.newArrayList();</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; i++) &#123;</span><br><span class="line">				CuratorFramework client</span><br><span class="line">						= CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">20000</span>, <span class="number">3</span>));</span><br><span class="line">				clients.add(client);</span><br><span class="line">				LeaderSelectorAdapter selectorAdapter = <span class="keyword">new</span> LeaderSelectorAdapter(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line">				examples.add(selectorAdapter);</span><br><span class="line">				client.start();</span><br><span class="line">				selectorAdapter.start();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</span><br><span class="line">			<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Shutting down..."</span>);</span><br><span class="line">			<span class="keyword">for</span> (LeaderSelectorAdapter exampleClient : examples) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(exampleClient);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(client);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比可知，LeaderLatch必须调用<code>close()</code>方法才会释放领导权，而对于LeaderSelector，通过<code>LeaderSelectorListener</code>可以对领导权进行控制， 在适当的时候释放领导权，这样每个节点都有可能获得领导权。从而，LeaderSelector具有更好的灵活性和可控性，建议有LeaderElection应用场景下优先使用LeaderSelector。</p>
<h3 id="分布式锁">分布式锁</h3>
<p><strong>提醒：</strong></p>
<p>1.推荐使用ConnectionStateListener监控连接的状态，因为当连接LOST时你不再拥有锁</p>
<p>2.分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p>
<h4 id="可重入共享锁—Shared-Reentrant-Lock">可重入共享锁—Shared Reentrant Lock</h4>
<p><strong>Shared意味着锁是全局可见的</strong>， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似，即可重入， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。 它是由类<code>InterProcessMutex</code>来实现。 它的构造函数为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span></span><br></pre></td></tr></table></figure>
<p>通过<code>acquire()</code>获得锁，并提供超时机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Acquire the mutex - blocking until it's available. Note: the same thread can call acquire</span></span><br><span class="line"><span class="function">re-entrantly. Each call to acquire must be balanced by a call to <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span></span></span><br><span class="line"><span class="function">Acquire the mutex - blocks until it's available or the given time expires. Note: the same thread can call acquire re-entrantly. Each call to acquire that returns <span class="keyword">true</span> must be balanced by a call to <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">time - time to wait</span></span><br><span class="line"><span class="function">unit - time unit</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function"><span class="keyword">true</span> <span class="keyword">if</span> the mutex was acquired, <span class="keyword">false</span> <span class="keyword">if</span> not</span></span><br></pre></td></tr></table></figure>
<p>通过<code>release()</code>方法释放锁。 InterProcessMutex 实例可以重用。</p>
<p><strong>Revoking</strong> ZooKeeper recipes wiki定义了可协商的撤销机制。 为了撤销mutex, 调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRevocable</span><span class="params">(RevocationListener&lt;T&gt; listener)</span></span></span><br><span class="line"><span class="function">将锁设为可撤销的. 当别的进程或线程想让你释放锁时Listener会被调用。</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">listener - the listener</span></span><br></pre></td></tr></table></figure>
<p>如果你请求撤销当前的锁， 调用<code>attemptRevoke()</code>方法,注意锁释放时<code>RevocationListener</code>将会回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRevoke</span><span class="params">(CuratorFramework client,String path)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Utility to mark a lock <span class="keyword">for</span> revocation. Assuming that the lock has been registered</span></span><br><span class="line"><span class="function">with a RevocationListener, it will get called and the lock should be released. Note,</span></span><br><span class="line"><span class="function">however, that revocation is cooperative.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">path - the path of the lock - usually from something like InterProcessMutex.<span class="title">getParticipantNodes</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>二次提醒：错误处理</strong> 还是强烈推荐你使用<code>ConnectionStateListener</code>处理连接状态的改变。 当连接LOST时你不再拥有锁。</p>
<p>首先让我们创建一个模拟的共享资源， 这个资源期望只能单线程的访问，否则会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeLimitedResource</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean inUse = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// 真实环境中我们会在这里访问/维护一个共享的资源</span></span><br><span class="line">		<span class="comment">//这个例子在使用锁的情况下不会非法并发异常IllegalStateException</span></span><br><span class="line">		<span class="comment">//但是在无锁的情况由于sleep了一段时间，很容易抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (!inUse.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Needs to be used by one client at a time"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			inUse.set(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个<code>InterProcessMutexDemo</code>类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutexDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutexDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		<span class="keyword">this</span>.lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" get the lock"</span>);</span><br><span class="line">			resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">			lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> InterProcessMutexDemo example = <span class="keyword">new</span> InterProcessMutexDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也很简单，生成10个client， 每个client重复执行10次 请求锁–访问资源–释放锁的过程。每个client都在独立的线程中。 结果可以看到，锁是随机的被每个实例排他性的使用。</p>
<p>既然是可重用的，你可以在一个线程中多次调用<code>acquire()</code>,在线程拥有锁时它总是返回true。</p>
<p><strong>你不应该在多个线程中用同一个<code>InterProcessMutex</code></strong>， 你可以在每个线程中都生成一个新的InterProcessMutex实例，它们的path都一样，这样它们可以共享同一个锁。</p>
<h4 id="不可重入共享锁—Shared-Lock">不可重入共享锁—Shared Lock</h4>
<p>这个锁和上面的<code>InterProcessMutex</code>相比，就是少了Reentrant的功能，也就意味着它不能在同一个线程中重入。这个类是<code>InterProcessSemaphoreMutex</code>,使用方法和<code>InterProcessMutex</code>类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreMutexDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> InterProcessSemaphoreMutex lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InterProcessSemaphoreMutexDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		<span class="keyword">this</span>.lock = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, lockPath);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到互斥锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 已获取到互斥锁"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到互斥锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 再次获取到互斥锁"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" get the lock"</span>);</span><br><span class="line">			resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">			lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">			lock.release(); <span class="comment">// 获取锁几次 释放锁也要几次</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> InterProcessSemaphoreMutexDemo example = <span class="keyword">new</span> InterProcessSemaphoreMutexDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后发现，有且只有一个client成功获取第一个锁(第一个<code>acquire()</code>方法返回true)，然后它自己阻塞在第二个<code>acquire()</code>方法，获取第二个锁超时；其他所有的客户端都阻塞在第一个<code>acquire()</code>方法超时并且抛出异常。</p>
<p>这样也就验证了<code>InterProcessSemaphoreMutex</code>实现的锁是不可重入的。</p>
<h4 id="可重入读写锁—Shared-Reentrant-Read-Write-Lock">可重入读写锁—Shared Reentrant Read Write Lock</h4>
<p>类似JDK的<strong>ReentrantReadWriteLock</strong>。一个读写锁管理一对相关的锁。一个负责读操作，另外一个负责写操作。读操作在写锁没被使用时可同时由多个进程使用，而写锁在使用时不允许读(阻塞)。</p>
<p>此锁是可重入的。<strong>一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁</strong>。这也意味着<strong>写锁可以降级成读锁， 比如请求写锁 —&gt;请求读锁—&gt;释放读锁 ----&gt;释放写锁</strong>。从读锁升级成写锁是不行的。</p>
<p>可重入读写锁主要由两个类实现：<code>InterProcessReadWriteLock</code>、<code>InterProcessMutex</code>。使用时首先创建一个<code>InterProcessReadWriteLock</code>实例，然后再根据你的需求得到读锁或者写锁，读写锁的类型是<code>InterProcessMutex</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessReadWriteLock lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex readLock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex writeLock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLockDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, lockPath);</span><br><span class="line">		readLock = lock.readLock();</span><br><span class="line">		writeLock = lock.writeLock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 注意只能先得到写锁再得到读锁，不能反过来！！！</span></span><br><span class="line">		<span class="keyword">if</span> (!writeLock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到写锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 已得到写锁"</span>);</span><br><span class="line">		<span class="keyword">if</span> (!readLock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" 不能得到读锁"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" 已得到读锁"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			resource.use(); <span class="comment">// 使用资源</span></span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" 释放读写锁"</span>);</span><br><span class="line">			readLock.release();</span><br><span class="line">			writeLock.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> ReentrantReadWriteLockDemo example = <span class="keyword">new</span> ReentrantReadWriteLockDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量—Shared-Semaphore">信号量—Shared Semaphore</h4>
<p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(<strong>permits</strong>)，而Curator中称之为租约(<strong>Lease</strong>)。 有两种方式可以决定semaphore的最大租约数。第一种方式是用户给定path并且指定最大LeaseSize。第二种方式用户给定path并且使用<code>SharedCountReader</code>类。<strong>如果不使用SharedCountReader, 必须保证所有实例在多进程中使用相同的(最大)租约数量,否则有可能出现A进程中的实例持有最大租约数量为10，但是在B进程中持有的最大租约数量为20，此时租约的意义就失效了。</strong></p>
<p>这次调用<code>acquire()</code>会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。 租约还可以通过下面的方式返还：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLease</span><span class="params">(Lease lease)</span></span></span><br></pre></td></tr></table></figure>
<p>注意你可以一次性请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty, <span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure>
<p>Shared Semaphore使用的主要类包括下面几个：</p>
<ul>
<li><code>InterProcessSemaphoreV2</code></li>
<li><code>Lease</code></li>
<li><code>SharedCountReader</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEASE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line"></span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line"></span><br><span class="line">			InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(client, PATH, MAX_LEASE);</span><br><span class="line">			Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="number">5</span>);</span><br><span class="line">			System.out.println(<span class="string">"get "</span> + leases.size() + <span class="string">" leases"</span>);</span><br><span class="line">			Lease lease = semaphore.acquire();</span><br><span class="line">			System.out.println(<span class="string">"get another lease"</span>);</span><br><span class="line"></span><br><span class="line">			resource.use();</span><br><span class="line"></span><br><span class="line">			Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">			System.out.println(<span class="string">"Should timeout and acquire return "</span> + leases2);</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"return one lease"</span>);</span><br><span class="line">			semaphore.returnLease(lease);</span><br><span class="line">			System.out.println(<span class="string">"return another 5 leases"</span>);</span><br><span class="line">			semaphore.returnAll(leases);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们先获得了5个租约， 最后我们把它还给了semaphore。 接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。 然后再请求一个租约，因为租约不够，<strong>阻塞到超时，还是没能满足，返回结果为null(租约不足会阻塞到超时，然后返回null，不会主动抛出异常；如果不设置超时时间，会一致阻塞)。</strong></p>
<p>上面说讲的锁都是公平锁(fair)。 总ZooKeeper的角度看， 每个客户端都按照请求的顺序获得锁，不存在非公平的抢占的情况。</p>
<h4 id="多共享锁对象-—Multi-Shared-Lock">多共享锁对象 —Multi Shared Lock</h4>
<p>Multi Shared Lock是一个锁的容器。 当调用<code>acquire()</code>， 所有的锁都会被<code>acquire()</code>，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(<strong>失败被忽略</strong>)。 基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p>
<p>主要涉及两个类：</p>
<ul>
<li><code>InterProcessMultiLock</code></li>
<li><code>InterProcessLock</code></li>
</ul>
<p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span></span></span><br></pre></td></tr></table></figure>
<p>用法和Shared Lock相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiSharedLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH1 = <span class="string">"/examples/locks1"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH2 = <span class="string">"/examples/locks2"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line"></span><br><span class="line">			InterProcessLock lock1 = <span class="keyword">new</span> InterProcessMutex(client, PATH1);</span><br><span class="line">			InterProcessLock lock2 = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, PATH2);</span><br><span class="line"></span><br><span class="line">			InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(Arrays.asList(lock1, lock2));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"could not acquire the lock"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"has got all lock"</span>);</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"has got lock1: "</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">			System.out.println(<span class="string">"has got lock2: "</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"releasing the lock"</span>);</span><br><span class="line">				lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"has got lock1: "</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">			System.out.println(<span class="string">"has got lock2: "</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建一个<code>InterProcessMultiLock</code>， 包含一个重入锁和一个非重入锁。 调用<code>acquire()</code>后可以看到线程同时拥有了这两个锁。 调用<code>release()</code>看到这两个锁都被释放了。</p>
<p><strong>最后再重申一次， 强烈推荐使用ConnectionStateListener监控连接的状态，当连接状态为LOST，锁将会丢失。</strong></p>
<h3 id="分布式计数器">分布式计数器</h3>
<p>顾名思义，计数器是用来计数的, 利用ZooKeeper可以实现一个集群共享的计数器。 只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数(<code>SharedCount</code>)，一个用long来计数(<code>DistributedAtomicLong</code>)。</p>
<h4 id="分布式int计数器—SharedCount">分布式int计数器—SharedCount</h4>
<p>这个类使用int类型来计数。 主要涉及三个类。</p>
<ul>
<li>SharedCount</li>
<li>SharedCountReader</li>
<li>SharedCountListener</li>
</ul>
<p><code>SharedCount</code>代表计数器， 可以为它增加一个<code>SharedCountListener</code>，当计数器改变时此Listener可以监听到改变的事件，而<code>SharedCountReader</code>可以读取到最新的值， 包括字面值和带版本信息的值VersionedValue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedCounterDemo</span> <span class="keyword">implements</span> <span class="title">SharedCountListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/counter"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">		SharedCounterDemo example = <span class="keyword">new</span> SharedCounterDemo();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line"></span><br><span class="line">			SharedCount baseCount = <span class="keyword">new</span> SharedCount(client, PATH, <span class="number">0</span>);</span><br><span class="line">			baseCount.addListener(example);</span><br><span class="line">			baseCount.start();</span><br><span class="line"></span><br><span class="line">			List&lt;SharedCount&gt; examples = Lists.newArrayList();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> SharedCount count = <span class="keyword">new</span> SharedCount(client, PATH, <span class="number">0</span>);</span><br><span class="line">				examples.add(count);</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">					count.start();</span><br><span class="line">					Thread.sleep(rand.nextInt(<span class="number">10000</span>));</span><br><span class="line">					System.out.println(<span class="string">"Increment:"</span> + count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(<span class="number">10</span>)));</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				examples.get(i).close();</span><br><span class="line">			&#125;</span><br><span class="line">			baseCount.close();</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework arg0, ConnectionState arg1)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"State changed: "</span> + arg1.toString());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countHasChanged</span><span class="params">(SharedCountReader sharedCount, <span class="keyword">int</span> newCount)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Counter's value is changed to "</span> + newCount);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用<code>baseCount</code>来监听计数值(<code>addListener</code>方法来添加SharedCountListener )。 任意的SharedCount， 只要使用相同的path，都可以得到这个计数值。 然后我们使用5个线程为计数值增加一个10以内的随机数。相同的path的SharedCount对计数值进行更改，将会回调给<code>baseCount</code>的SharedCountListener。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(10))</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>trySetCount</code>去设置计数器。 <strong>第一个参数提供当前的VersionedValue,如果期间其它client更新了此计数值， 你的更新可能不成功， 但是这时你的client更新了最新的值，所以失败了你可以尝试再更新一次。 而<code>setCount</code>是强制更新计数器的值</strong>。</p>
<p>注意计数器必须<code>start</code>,使用完之后必须调用<code>close</code>关闭它。</p>
<p>强烈推荐使用<code>ConnectionStateListener</code>。 在本例中<code>SharedCountListener</code>扩展<code>ConnectionStateListener</code>。</p>
<h4 id="分布式long计数器—DistributedAtomicLong">分布式long计数器—DistributedAtomicLong</h4>
<p>再看一个Long类型的计数器。 除了计数的范围比<code>SharedCount</code>大了之外， 它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用<code>InterProcessMutex</code>方式来更新计数值。</p>
<p>可以从它的内部实现<code>DistributedAtomicValue.trySet()</code>中看出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AtomicValue&lt;<span class="keyword">byte</span>[]&gt;   trySet(MakeValue makeValue) <span class="keyword">throws</span> Exception</span><br><span class="line"> &#123;</span><br><span class="line">     MutableAtomicValue&lt;<span class="keyword">byte</span>[]&gt;  result = <span class="keyword">new</span> MutableAtomicValue&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">     tryOptimistic(result, makeValue);</span><br><span class="line">     <span class="keyword">if</span> ( !result.succeeded() &amp;&amp; (mutex != <span class="keyword">null</span>) )</span><br><span class="line">     &#123;</span><br><span class="line">         tryWithMutex(result, makeValue);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>此计数器有一系列的操作：</p>
<ul>
<li>get(): 获取当前值</li>
<li>increment()： 加一</li>
<li>decrement(): 减一</li>
<li>add()： 增加特定的值</li>
<li>subtract(): 减去特定的值</li>
<li>trySet(): 尝试设置计数值</li>
<li>forceSet(): 强制设置计数值</li>
</ul>
<p>你<strong>必须</strong>检查返回结果的<code>succeeded()</code>， 它代表此操作是否成功。 如果操作成功， <code>preValue()</code>代表操作前的值， <code>postValue()</code>代表操作后的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedAtomicLongDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/counter"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">		List&lt;DistributedAtomicLong&gt; examples = Lists.newArrayList();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedAtomicLong count = <span class="keyword">new</span> DistributedAtomicLong(client, PATH, <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">				examples.add(count);</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						AtomicValue&lt;Long&gt; value = count.increment();</span><br><span class="line">						System.out.println(<span class="string">"succeed: "</span> + value.succeeded());</span><br><span class="line">						<span class="keyword">if</span> (value.succeeded())</span><br><span class="line">							System.out.println(<span class="string">"Increment: from "</span> + value.preValue() + <span class="string">" to "</span> + value.postValue());</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">			Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式队列">分布式队列</h3>
<p>使用Curator也可以简化Ephemeral Node (<strong>临时节点</strong>)的操作。Curator也提供ZK Recipe的分布式队列实现。 利用ZK的 PERSISTENTS_EQUENTIAL节点， 可以保证放入到队列中的项目是按照顺序排队的。 如果单一的消费者从队列中取数据， 那么它是先入先出的，这也是队列的特点。 如果你严格要求顺序，你就的使用单一的消费者，可以使用Leader选举只让Leader作为唯一的消费者。</p>
<p>但是， 根据Netflix的Curator作者所说， ZooKeeper真心不适合做Queue，或者说ZK没有实现一个好的Queue，详细内容可以看 <a href="https://cwiki.apache.org/confluence/display/CURATOR/TN4" target="_blank" rel="noopener">Tech Note 4</a>， 原因有五：</p>
<ol>
<li>ZK有1MB 的传输限制。 实践中ZNode必须相对较小，而队列包含成千上万的消息，非常的大。</li>
<li>如果有很多节点，ZK启动时相当的慢。 而使用queue会导致好多ZNode. 你需要显著增大 initLimit 和 syncLimit.</li>
<li>ZNode很大的时候很难清理。Netflix不得不创建了一个专门的程序做这事。</li>
<li>当很大量的包含成千上万的子节点的ZNode时， ZK的性能变得不好</li>
<li>ZK的数据库完全放在内存中。 大量的Queue意味着会占用很多的内存空间。</li>
</ol>
<p>尽管如此， Curator还是创建了各种Queue的实现。 如果Queue的数据量不太多，数据量不太大的情况下，酌情考虑，还是可以使用的。</p>
<h4 id="分布式队列—DistributedQueue">分布式队列—DistributedQueue</h4>
<p>DistributedQueue是最普通的一种队列。 它设计以下四个类：</p>
<ul>
<li>QueueBuilder - 创建队列使用QueueBuilder,它也是其它队列的创建类</li>
<li>QueueConsumer - 队列中的消息消费者接口</li>
<li>QueueSerializer - 队列消息序列化和反序列化接口，提供了对队列中的对象的序列化和反序列化</li>
<li>DistributedQueue - 队列实现类</li>
</ul>
<p>QueueConsumer是消费者，它可以接收队列的数据。处理队列中的数据的代码逻辑可以放在QueueConsumer.consumeMessage()中。</p>
<p>正常情况下先将消息从队列中移除，再交给消费者消费。但这是两个步骤，不是原子的。可以调用Builder的lockPath()消费者加锁，当消费者消费数据时持有锁，这样其它消费者不能消费此消息。如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。最好还是单消费者模式使用队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework clientA = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		clientA.start();</span><br><span class="line">		CuratorFramework clientB = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">		clientB.start();</span><br><span class="line">		DistributedQueue&lt;String&gt; queueA;</span><br><span class="line">		QueueBuilder&lt;String&gt; builderA = QueueBuilder.builder(clientA, createQueueConsumer(<span class="string">"A"</span>), createQueueSerializer(), PATH);</span><br><span class="line">		queueA = builderA.buildQueue();</span><br><span class="line">		queueA.start();</span><br><span class="line"></span><br><span class="line">		DistributedQueue&lt;String&gt; queueB;</span><br><span class="line">		QueueBuilder&lt;String&gt; builderB = QueueBuilder.builder(clientB, createQueueConsumer(<span class="string">"B"</span>), createQueueSerializer(), PATH);</span><br><span class="line">		queueB = builderB.buildQueue();</span><br><span class="line">		queueB.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			queueA.put(<span class="string">" test-A-"</span> + i);</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">			queueB.put(<span class="string">" test-B-"</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span> * <span class="number">10</span>);<span class="comment">// 等待消息消费完成</span></span><br><span class="line">		queueB.close();</span><br><span class="line">		queueA.close();</span><br><span class="line">		clientB.close();</span><br><span class="line">		clientA.close();</span><br><span class="line">		System.out.println(<span class="string">"OK!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 队列消息序列化实现类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义队列消费者</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"连接状态改变: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"消费消息("</span> + name + <span class="string">"): "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中定义了两个分布式队列和两个消费者，因为PATH是相同的，会存在消费者抢占消费消息的情况。</p>
<h4 id="带Id的分布式队列—DistributedIdQueue">带Id的分布式队列—DistributedIdQueue</h4>
<p>DistributedIdQueue和上面的队列类似，<strong>但是可以为队列中的每一个元素设置一个ID</strong>。 可以通过ID把队列中任意的元素移除。 它涉及几个类：</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedQueue</li>
</ul>
<p>通过下面方法创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.buildIdQueue()</span><br></pre></td></tr></table></figure>
<p>放入元素时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.put(aMessage, messageId);</span><br></pre></td></tr></table></figure>
<p>移除元素时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int numberRemoved &#x3D; queue.remove(messageId);</span><br></pre></td></tr></table></figure>
<p>在这个例子中， 有些元素还没有被消费者消费前就移除了，这样消费者不会收到删除的消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedIdQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedIdQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line"></span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildIdQueue();</span><br><span class="line">			queue.start();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				queue.put(<span class="string">" test-"</span> + i, <span class="string">"Id"</span> + i);</span><br><span class="line">				Thread.sleep((<span class="keyword">long</span>) (<span class="number">15</span> * Math.random()));</span><br><span class="line">				queue.remove(<span class="string">"Id"</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"consume one message: "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先级分布式队列—DistributedPriorityQueue">优先级分布式队列—DistributedPriorityQueue</h4>
<p>优先级队列对队列中的元素按照优先级进行排序。 <strong>Priority越小， 元素越靠前， 越先被消费掉</strong>。 它涉及下面几个类：</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedPriorityQueue</li>
</ul>
<p>通过builder.buildPriorityQueue(minItemsBeforeRefresh)方法创建。 当优先级队列得到元素增删消息时，它会暂停处理当前的元素队列，然后刷新队列。minItemsBeforeRefresh指定刷新前当前活动的队列的最小数量。 主要设置你的程序可以容忍的不排序的最小值。</p>
<p>放入队列时需要指定优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.put(aMessage, priority);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedPriorityQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedPriorityQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line"></span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildPriorityQueue(<span class="number">0</span>);</span><br><span class="line">			queue.start();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> priority = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">				System.out.println(<span class="string">"test-"</span> + i + <span class="string">" priority:"</span> + priority);</span><br><span class="line">				queue.put(<span class="string">"test-"</span> + i, priority);</span><br><span class="line">				Thread.sleep((<span class="keyword">long</span>) (<span class="number">50</span> * Math.random()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(<span class="string">"consume one message: "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候你可能会有错觉，优先级设置并没有起效。那是因为优先级是对于队列积压的元素而言，如果消费速度过快有可能出现在后一个元素入队操作之前前一个元素已经被消费，这种情况下DistributedPriorityQueue会退化为DistributedQueue。</p>
<h4 id="分布式延迟队列—DistributedDelayQueue">分布式延迟队列—DistributedDelayQueue</h4>
<p>JDK中也有DelayQueue，不知道你是否熟悉。 DistributedDelayQueue也提供了类似的功能， 元素有个delay值， 消费者隔一段时间才能收到元素。 涉及到下面四个类。</p>
<ul>
<li>QueueBuilder</li>
<li>QueueConsumer</li>
<li>QueueSerializer</li>
<li>DistributedDelayQueue</li>
</ul>
<p>通过下面的语句创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueBuilder&lt;MessageType&gt;    builder &#x3D; QueueBuilder.builder(client, consumer, serializer, path);</span><br><span class="line">... more builder method calls as needed ...</span><br><span class="line">DistributedDelayQueue&lt;MessageType&gt; queue &#x3D; builder.buildDelayQueue();</span><br></pre></td></tr></table></figure>
<p>放入元素时可以指定<code>delayUntilEpoch</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.put(aMessage, delayUntilEpoch);</span><br></pre></td></tr></table></figure>
<p>注意<code>delayUntilEpoch</code>不是离现在的一个时间间隔， 比如20毫秒，而是未来的一个时间戳，如 System.currentTimeMillis() + 10秒。 如果delayUntilEpoch的时间已经过去，消息会立刻被消费者接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedDelayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedDelayQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line"></span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildDelayQueue();</span><br><span class="line">			queue.start();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				queue.put(<span class="string">"test-"</span> + i, System.currentTimeMillis() + <span class="number">10000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> Date().getTime() + <span class="string">": already put all items"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="keyword">new</span> Date().getTime() + <span class="string">": consume one message: "</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SimpleDistributedQueue">SimpleDistributedQueue</h4>
<p>前面虽然实现了各种队列，但是你注意到没有，这些队列并没有实现类似JDK一样的接口。 <code>SimpleDistributedQueue</code>提供了和JDK基本一致的接口(但是没有实现Queue接口)。 创建很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client,String path)</span></span></span><br></pre></td></tr></table></figure>
<p>增加元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(byte[] data) throws Exception</span><br></pre></td></tr></table></figure>
<p>删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] take() <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>
<p>另外还提供了其它方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] peek() <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] poll(<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] poll() <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] remove() <span class="keyword">throws</span> Exception</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] element() <span class="keyword">throws</span> Exception</span><br></pre></td></tr></table></figure>
<p>没有<code>add</code>方法， 多了<code>take</code>方法。</p>
<p><code>take</code>方法在成功返回之前会被阻塞。 而<code>poll</code>方法在队列为空时直接返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDistributedQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		SimpleDistributedQueue queue;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener((client1, event) -&gt; System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name()));</span><br><span class="line">			client.start();</span><br><span class="line">			queue = <span class="keyword">new</span> SimpleDistributedQueue(client, PATH);</span><br><span class="line">			Producer producer = <span class="keyword">new</span> Producer(queue);</span><br><span class="line">			Consumer consumer = <span class="keyword">new</span> Consumer(queue);</span><br><span class="line">			<span class="keyword">new</span> Thread(producer, <span class="string">"producer"</span>).start();</span><br><span class="line">			<span class="keyword">new</span> Thread(consumer, <span class="string">"consumer"</span>).start();</span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> SimpleDistributedQueue queue;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(SimpleDistributedQueue queue)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.queue = queue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">boolean</span> flag = queue.offer((<span class="string">"zjc-"</span> + i).getBytes());</span><br><span class="line">					<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">						System.out.println(<span class="string">"发送一条消息成功："</span> + <span class="string">"zjc-"</span> + i);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						System.out.println(<span class="string">"发送一条消息失败："</span> + <span class="string">"zjc-"</span> + i);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> SimpleDistributedQueue queue;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(SimpleDistributedQueue queue)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.queue = queue;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">byte</span>[] datas = queue.take();</span><br><span class="line">				System.out.println(<span class="string">"消费一条消息成功："</span> + <span class="keyword">new</span> String(datas, <span class="string">"UTF-8"</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际上发送了100条消息，消费完第一条之后，后面的消息无法消费，目前没找到原因。查看一下官方文档推荐的demo使用下面几个Api：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Creating a SimpleDistributedQueue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleDistributedQueue</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String path)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">path - path to store queue nodes</span></span><br><span class="line"><span class="function">Add to the queue</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(<span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Inserts data into queue.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">data - the data</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function"><span class="keyword">true</span> <span class="keyword">if</span> data was successfully added</span></span><br><span class="line"><span class="function">Take from the queue</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">byte</span>[] <span class="title">take</span><span class="params">()</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Removes the head of the queue and returns it, blocks until it succeeds.</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function">The former head of the queue</span></span><br><span class="line"><span class="function">NOTE: see the Javadoc <span class="keyword">for</span> additional methods</span></span><br></pre></td></tr></table></figure>
<p>但是实际使用发现还是存在消费阻塞问题。</p>
<h3 id="分布式屏障—Barrier">分布式屏障—Barrier</h3>
<p>分布式Barrier是这样一个类： 它会阻塞所有节点上的等待进程，直到某一个被满足， 然后所有的节点继续进行。</p>
<p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p>
<h4 id="DistributedBarrier">DistributedBarrier</h4>
<p><code>DistributedBarrier</code>类实现了栅栏的功能。 它的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedBarrier</span><span class="params">(CuratorFramework client, String barrierPath)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - client</span></span><br><span class="line"><span class="function">barrierPath - path to use as the barrier</span></span><br></pre></td></tr></table></figure>
<p>首先你需要设置栅栏，它将阻塞在它上面等待的线程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setBarrier();</span><br></pre></td></tr></table></figure>
<p>然后需要阻塞的线程调用方法等待放行条件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void waitOnBarrier()</span><br></pre></td></tr></table></figure>
<p>当条件满足时，移除栅栏，所有等待的线程将继续执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeBarrier();</span><br></pre></td></tr></table></figure>
<p><strong>异常处理</strong> DistributedBarrier 会监控连接状态，当连接断掉时<code>waitOnBarrier()</code>方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/barrier"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			DistributedBarrier controlBarrier = <span class="keyword">new</span> DistributedBarrier(client, PATH);</span><br><span class="line">			controlBarrier.setBarrier();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedBarrier barrier = <span class="keyword">new</span> DistributedBarrier(client, PATH);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">					Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" waits on Barrier"</span>);</span><br><span class="line">					barrier.waitOnBarrier();</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" begins"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			System.out.println(<span class="string">"all Barrier instances should wait the condition"</span>);</span><br><span class="line">			controlBarrier.removeBarrier();</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子创建了<code>controlBarrier</code>来设置栅栏和移除栅栏。 我们创建了5个线程，在此Barrier上等待。 最后移除栅栏后所有的线程才继续执行。</p>
<p>如果你开始不设置栅栏，所有的线程就不会阻塞住。</p>
<h4 id="双栅栏—DistributedDoubleBarrier">双栅栏—DistributedDoubleBarrier</h4>
<p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。 双栅栏类是<code>DistributedDoubleBarrier</code>。 构造函数为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String barrierPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> memberQty)</span></span></span><br><span class="line"><span class="function">Creates the barrier abstraction. memberQty is the number of members in the barrier. When <span class="title">enter</span><span class="params">()</span> is called, it blocks until</span></span><br><span class="line"><span class="function">all members have entered. When <span class="title">leave</span><span class="params">()</span> is called, it blocks until all members have left.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">barrierPath - path to use</span></span><br><span class="line"><span class="function">memberQty - the number of members in the barrier</span></span><br></pre></td></tr></table></figure>
<p><code>memberQty</code>是成员数量，当<code>enter()</code>方法被调用时，成员被阻塞，直到所有的成员都调用了<code>enter()</code>。 当<code>leave()</code>方法被调用时，它也阻塞调用线程，直到所有的成员都调用了<code>leave()</code>。 就像百米赛跑比赛， 发令枪响， 所有的运动员开始跑，等所有的运动员跑过终点线，比赛才结束。</p>
<p>DistributedDoubleBarrier会监控连接状态，当连接断掉时<code>enter()</code>和<code>leave()</code>方法会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedDoubleBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/barrier"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedDoubleBarrier barrier = <span class="keyword">new</span> DistributedDoubleBarrier(client, PATH, QTY);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">					Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" enters"</span>);</span><br><span class="line">					barrier.enter();</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" begins"</span>);</span><br><span class="line">					Thread.sleep((<span class="keyword">long</span>) (<span class="number">3000</span> * Math.random()));</span><br><span class="line">					barrier.leave();</span><br><span class="line">					System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" left"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">			Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<ul>
<li>《从PAXOS到ZOOKEEPER分布式一致性原理与实践》</li>
<li>《跟着实例学习ZooKeeper的用法》博客系列</li>
</ul>
<p><strong>项目仓库：</strong></p>
<ul>
<li><a href="https://github.com/zjcscut/curator-seed" target="_blank" rel="noopener">https://github.com/zjcscut/curator-seed</a></li>
</ul>
<p>(e-a-2017-5-13 13:10 c-14-d r-a-20181216)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Middleware/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Middleware</a>
        
          <a href="/blog/tags/Zookeeper/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Zookeeper</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/java-reflection-optimal-performance/">
      深入分析Java反射(八)-优化反射调用性能
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.9k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：8分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T12:01:22+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(八)-优化反射调用性能</h1>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>前一篇文章已经介绍了反射调用的底层原理，其实在实际中对大多数Java使用者来说更关系的是如何提升反射调用的性能，本文主要提供几个可行的方案。另外，由于方法调用时频率最高的反射操作，会着重介绍方法的反射调用优化。</p>
<h2 id="方法一：选择合适的API">方法一：选择合适的API</h2>
<p>选择合适的API主要是在获取反射相关元数据的时候尽量避免使用遍历的方法，例如：</p>
<ul>
<li>获取Field实例：尽量避免频繁使用<code>Class#getDeclaredFields()</code>或者<code>Class#getFields()</code>，应该根据Field的名称直接调用<code>Class#getDeclaredField()</code>或者<code>Class#getField()</code>。</li>
<li>获取Method实例：尽量避免频繁使用<code>Class#getDeclaredMethods()</code>或者<code>Class#getMethods()</code>，应该根据Method的名称和参数类型数组调用<code>Class#getDeclaredMethod()</code>或者<code>Class#getMethod()</code>。</li>
<li>获取Constructor实例：尽量避免频繁使用<code>Class#getDeclaredConstructors()</code>或者<code>Class#getConstructors()</code>，应该根据Constructor参数类型数组调用<code>Class#getDeclaredConstructor()</code>或者<code>Class#getConstructor()</code>。</li>
</ul>
<p>其实思路很简单，除非我们想要获取Class的所有Field、Method或者Constructor，否则应该避免使用返回一个集合或者数组的API，这样子能减少遍历或者判断带来的性能损耗。</p>
<h2 id="方法二：缓存反射操作相关元数据">方法二：缓存反射操作相关元数据</h2>
<p>使用缓存机制缓存反射操作相关元数据的原因是因为反射操作相关元数据的实时获取是比较耗时的，这里列举几个相对耗时的场景：</p>
<ul>
<li>获取Class实例：<code>Class#forName()</code>，此方法可以查看源码，耗时相对其他方法高得多。</li>
<li>获取Field实例：<code>Class#getDeclaredField()</code>、<code>Class#getDeclaredFields()</code>、<code>Class#getField()</code>、<code>Class#getFields()</code>。</li>
<li>获取Method实例：<code>Class#getDeclaredMethod()</code>、<code>Class#getDeclaredMethods()</code>、<code>Class#getMethod()</code>、<code>Class#getMethods()</code>。</li>
<li>获取Constructor实例：<code>Class#getDeclaredConstructor()</code>、<code>Class#getDeclaredConstructors()</code>、<code>Class#getConstructor()</code>、<code>Class#getConstructors()</code>。</li>
</ul>
<p>这里举个简单的例子，需要反射调用一个普通JavaBean的Setter和Getter方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;ReflectionMetadata&gt;&gt; METADATA = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; CLASSES = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析的时候尽量放在&lt;cinit&gt;里面</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		Class&lt;?&gt; clazz = JavaBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		CLASSES.put(clazz.getName(), clazz);</span><br><span class="line">		List&lt;ReflectionMetadata&gt; metadataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		METADATA.put(clazz, metadataList);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (Field f : clazz.getDeclaredFields()) &#123;</span><br><span class="line">				ReflectionMetadata metadata = <span class="keyword">new</span> ReflectionMetadata();</span><br><span class="line">				metadataList.add(metadata);</span><br><span class="line">				metadata.setTargetClass(clazz);</span><br><span class="line">				metadata.setField(f);</span><br><span class="line">				String name = f.getName();</span><br><span class="line">				Class&lt;?&gt; type = f.getType();</span><br><span class="line">				metadata.setReadMethod(clazz.getDeclaredMethod(String.format(<span class="string">"get%s%s"</span>, Character.toUpperCase(name.charAt(<span class="number">0</span>)), name.substring(<span class="number">1</span>))));</span><br><span class="line">				metadata.setWriteMethod(clazz.getDeclaredMethod(String.format(<span class="string">"set%s%s"</span>, Character.toUpperCase(name.charAt(<span class="number">0</span>)), name.substring(<span class="number">1</span>)), type));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String fieldName = <span class="string">"name"</span>;</span><br><span class="line">		Class&lt;JavaBean&gt; javaBeanClass = JavaBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		JavaBean javaBean = <span class="keyword">new</span> JavaBean();</span><br><span class="line">		invokeSetter(javaBeanClass, javaBean, fieldName , <span class="string">"Doge"</span>);</span><br><span class="line">		System.out.println(invokeGetter(javaBeanClass,javaBean, fieldName));</span><br><span class="line">		invokeSetter(javaBeanClass.getName(), javaBean, fieldName , <span class="string">"Throwable"</span>);</span><br><span class="line">		System.out.println(invokeGetter(javaBeanClass.getName(),javaBean, fieldName));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeSetter</span><span class="params">(String className, Object target, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		METADATA.get(CLASSES.get(className)).forEach(each -&gt; &#123;</span><br><span class="line">			Field field = each.getField();</span><br><span class="line">			<span class="keyword">if</span> (field.getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					each.getWriteMethod().invoke(target, value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeSetter</span><span class="params">(Class&lt;?&gt; clazz, Object target, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		METADATA.get(clazz).forEach(each -&gt; &#123;</span><br><span class="line">			Field field = each.getField();</span><br><span class="line">			<span class="keyword">if</span> (field.getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					each.getWriteMethod().invoke(target, value);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invokeGetter</span><span class="params">(String className, Object target, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ReflectionMetadata metadata : METADATA.get(CLASSES.get(className))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.getField().getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> metadata.getReadMethod().invoke(target);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">invokeGetter</span><span class="params">(Class&lt;?&gt; clazz, Object target, String fieldName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ReflectionMetadata metadata : METADATA.get(clazz)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (metadata.getField().getName().equals(fieldName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> metadata.getReadMethod().invoke(target);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Class&lt;?&gt; targetClass;</span><br><span class="line">		<span class="keyword">private</span> Field field;</span><br><span class="line">		<span class="keyword">private</span> Method readMethod;</span><br><span class="line">		<span class="keyword">private</span> Method writeMethod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，解析反射元数据进行缓存的操作最好放在静态代码块或者首次调用的时候(也就是懒加载)，这样能够避免真正调用的时候总是需要重新加载一次反射相关元数据。</p>
<h2 id="方法三：反射操作转变为直接调用">方法三：反射操作转变为直接调用</h2>
<p>&quot;反射操作转变为直接调用&quot;并不是完全不依赖于反射的类库，这里的做法是把反射操作相关元数据直接放置在类的成员变量中，这样就能省去从缓存中读取反射相关元数据的消耗，而所谓&quot;直接调用&quot;一般是通过继承或者实现接口实现。有一些高性能的反射类库也会使用一些创新的方法：例如使用成员属性缓存反射相关元数据，并且把方法调用通过数字建立索引[Number-&gt;Method]或者建立索引类(像<code>CGLIB</code>的<code>FastClass</code>)，<strong>这种做法在父类或者接口方法比较少的时候会有一定的性能提升，但是实际上性能评估需要从具体的场景通过测试分析结果而不能盲目使用</strong>，使用这个思想的类库有<code>CGLIB</code>、<code>ReflectASM</code>等。&quot;反射操作转变为直接调用&quot;的最典型的实现就是JDK的动态代理，这里翻出之前动态代理那篇文章的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的话<code>Simple</code>接口实例虽然最终是通过反射调用<code>sayHello(String var1)</code>方法，但是相关元数据在静态代码块中创建并且已经缓存在类成员属性中，那么反射调用方法的性能已经优化到极致，剩下的都只是Native方法的耗时，这一点使用者在编码层面已经没有办法优化，只能通过升级JVM(JDK)、使用JIT编译器等非编码层面的手段提升反射性能。</p>
<h2 id="小结">小结</h2>
<p>本文主要从编码层面分析反射操作一些性能优化的可行经验或者方案，或许有其他更好的优化方案，具体还是需要看使用场景。</p>
<p>(本文完 e-a-20181216 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/16/java-reflection-implementance/">
      深入分析Java反射(七)-简述反射调用的底层实现
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月16日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：14分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-16T01:09:52+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月16日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(七)-简述反射调用的底层实现</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射调用的底层实现，当然还没有能力分析JVM的实现，这里只分析到最终Native方法的调用点。底层会依赖到Unsafe类，可以的话可以看下笔者之前写的一篇文章《神奇的魔法类和双刃剑-Unsafe》。</p>
<h2 id="反射调用的底层实现探究">反射调用的底层实现探究</h2>
<p>主要考虑下面的情况：</p>
<ul>
<li>属性操作：<code>java.lang.reflect.Field#set(Object obj, Object value)</code>和<code>java.lang.reflect.Field#get(Object obj)</code>。</li>
<li>构造器调用：<code>java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>。</li>
<li>方法调用：<code>java.lang.reflect.Method#invoke(Object obj, Object... args)</code>。</li>
</ul>
<h3 id="处理属性操作的底层实现">处理属性操作的底层实现</h3>
<p>属性操作方法<code>Field#set(Object obj, Object value)</code>和<code>Field#get(Object obj)</code>底层都是委托到<code>jdk.internal.reflect.FieldAccessor</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FieldAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getShort</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setByte</span><span class="params">(Object obj, <span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChar</span><span class="params">(Object obj, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShort</span><span class="params">(Object obj, <span class="keyword">short</span> s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(Object obj, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Field&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FieldAccessor</code>接口有很多的实现，<code>FieldAccessor</code>接口实例是通过<code>jdk.internal.reflect.ReflectionFactory</code>这个工厂构造的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field field, <span class="keyword">boolean</span> override)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    Field root = langReflectAccess.getRoot(field);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// FieldAccessor will use the root unless the modifiers have</span></span><br><span class="line">        <span class="comment">// been overrridden</span></span><br><span class="line">        <span class="keyword">if</span> (root.getModifiers() == field.getModifiers() || !override) &#123;</span><br><span class="line">            field = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> UnsafeFieldAccessorFactory.newFieldAccessor(field, override);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终委托到<code>UnsafeFieldAccessorFactory#newFieldAccessor()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeFieldAccessorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FieldAccessor <span class="title">newFieldAccessor</span><span class="params">(Field field, <span class="keyword">boolean</span> override)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; type = field.getType();</span><br><span class="line">        <span class="keyword">boolean</span> isStatic = Modifier.isStatic(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isFinal = Modifier.isFinal(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isVolatile = Modifier.isVolatile(field.getModifiers());</span><br><span class="line">        <span class="keyword">boolean</span> isQualified = isFinal || isVolatile;</span><br><span class="line">        <span class="keyword">boolean</span> isReadOnly = isFinal &amp;&amp; (isStatic || !override);</span><br><span class="line">        <span class="keyword">if</span> (isStatic) &#123;</span><br><span class="line">            <span class="comment">// This code path does not guarantee that the field's</span></span><br><span class="line">            <span class="comment">// declaring class has been initialized, but it must be</span></span><br><span class="line">            <span class="comment">// before performing reflective operations.</span></span><br><span class="line">            UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(field.getDeclaringClass());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isQualified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticBooleanFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticByteFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticShortFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticCharacterFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticIntegerFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticLongFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticFloatFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticDoubleFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeStaticObjectFieldAccessorImpl(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticBooleanFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticByteFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticShortFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticCharacterFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticIntegerFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticLongFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticFloatFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticDoubleFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedStaticObjectFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isQualified) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeBooleanFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeByteFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeShortFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeCharacterFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeIntegerFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeLongFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeFloatFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeDoubleFieldAccessorImpl(field);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeObjectFieldAccessorImpl(field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == Boolean.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedBooleanFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Byte.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedByteFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Short.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedShortFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Character.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedCharacterFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Integer.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedIntegerFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Long.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedLongFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Float.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedFloatFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Double.TYPE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedDoubleFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeQualifiedObjectFieldAccessorImpl(field, isReadOnly);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意一下属性修饰符的判断：</p>
<ul>
<li>isStatic：静态属性，也就是static关键字修饰的属性。</li>
<li>isFinal：final关键字修饰的属性。</li>
<li>isVolatile：valatile关键字修饰的属性。</li>
<li>isQualified：valatile关键字或者final关键字修饰的属性。</li>
<li>isReadOnly：是否只读属性，final关键字修饰的属性或者static关键字修饰并且不能覆盖(override = false)的属性。</li>
</ul>
<p>通过上面修饰符做判断，得到最终的<code>FieldAccessor</code>实现。这里挑一个例子进行分析，例如<strong>一个普通非静态没有volatile和final关键字修饰属性</strong>最终就会得到<code>UnsafeObjectFieldAccessorImpl</code>的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnsafeObjectFieldAccessorImpl</span> <span class="keyword">extends</span> <span class="title">UnsafeFieldAccessorImpl</span> </span>&#123;</span><br><span class="line">    UnsafeObjectFieldAccessorImpl(Field field) &#123;</span><br><span class="line">        <span class="keyword">super</span>(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        ensureObj(obj);</span><br><span class="line">        <span class="keyword">return</span> unsafe.getObject(obj, fieldOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span>&#123;</span><br><span class="line">        ensureObj(obj);</span><br><span class="line">        <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">            throwFinalFieldIllegalAccessException(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!field.getType().isAssignableFrom(value.getClass())) &#123;</span><br><span class="line">                throwSetIllegalArgumentException(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.putObject(obj, fieldOffset, value);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> newGetBooleanIllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> newGetByteIllegalArgumentException();</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他直接抛出异常的方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>UnsafeObjectFieldAccessorImpl</code>中除了<code>get(Object obj)</code>和<code>set(Object obj, Object value)</code>方法，其他方法都是直接抛出IllegalArgumentException。而<code>get(Object obj)</code>和<code>set(Object obj, Object value)</code>底层分别依赖于<code>jdk.internal.misc.Unsafe</code>的<code>putObject(obj, fieldOffset, value)</code>和<code>getObject(obj, fieldOffset)</code>方法。而属性的内存偏移地址是在<code>UnsafeObjectFieldAccessorImpl</code>的父类<code>UnsafeFieldAccessorImpl</code>的构造函数中计算出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeFieldAccessorImpl</span> <span class="keyword">extends</span> <span class="title">FieldAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Field   field;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">long</span>    fieldOffset;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isFinal;</span><br><span class="line"></span><br><span class="line">    UnsafeFieldAccessorImpl(Field field) &#123;</span><br><span class="line">        <span class="keyword">this</span>.field = field;</span><br><span class="line">        <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers()))</span><br><span class="line">            fieldOffset = unsafe.staticFieldOffset(field);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fieldOffset = unsafe.objectFieldOffset(field);</span><br><span class="line">        isFinal = Modifier.isFinal(field.getModifiers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以做个小结，属性反射操作<code>Field</code>的<code>setXX</code>和<code>getXX</code>方法最终委托到<code>jdk.internal.misc.Unsafe</code>的<code>putXX</code>和<code>getXX</code>方法，而属性的内存偏移地址是通过<code>jdk.internal.misc.Unsafe</code>的<code>staticFieldBase()</code>、<code>staticFieldOffset</code>和<code>objectFieldOffset</code>几个方法计算的。</p>
<h3 id="处理构造器调用的底层实现">处理构造器调用的底层实现</h3>
<p><code>Constructor#newInstance()</code>方法调用依赖到<code>ConstructorAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, clazz, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot reflectively create enum objects"</span>);</span><br><span class="line">        ConstructorAccessor ca = constructorAccessor;   <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ca == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ca = acquireConstructorAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T inst = (T) ca.newInstance(initargs);</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConstructorAccessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstructorAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Constructor&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而获取<code>ConstructorAccessor</code>实例也是通过反射工厂类<code>ReflectionFactory</code>，具体是<code>ReflectionFactory#newConstructorAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConstructorAccessor <span class="title">newConstructorAccessor</span><span class="params">(Constructor&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line">    Class&lt;?&gt; declaringClass = c.getDeclaringClass();</span><br><span class="line">    <span class="comment">// 抽象方法会进入此if分支</span></span><br><span class="line">    <span class="keyword">if</span> (Modifier.isAbstract(declaringClass.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationExceptionConstructorAccessorImpl(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 宿主类直接是Class类型，则无法实例化</span></span><br><span class="line">    <span class="keyword">if</span> (declaringClass == Class<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstantiationExceptionConstructorAccessorImpl</span><br><span class="line">            (<span class="string">"Can not instantiate java.lang.Class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the root Constructor that will not cache caller class</span></span><br><span class="line">    Constructor&lt;?&gt; root = langReflectAccess.getRoot(c);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        c = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前声明构造的宿主类是ConstructorAccessorImpl的子类</span></span><br><span class="line">    <span class="keyword">if</span> (Reflection.isSubclassOf(declaringClass,</span><br><span class="line">                                ConstructorAccessorImpl<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BootstrapConstructorAccessorImpl(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                c.getParameterTypes(),</span><br><span class="line">                                c.getExceptionTypes(),</span><br><span class="line">                                c.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeConstructorAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeConstructorAccessorImpl(c);</span><br><span class="line">        DelegatingConstructorAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingConstructorAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见最终得到的<code>ConstructorAccessor</code>实例为<code>DelegatingConstructorAccessorImpl</code>，而<code>DelegatingConstructorAccessorImpl</code>只是一个委托实现，底层是调用<code>NativeConstructorAccessorImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeConstructorAccessorImpl</span> <span class="keyword">extends</span> <span class="title">ConstructorAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;?&gt; c;</span><br><span class="line">    <span class="keyword">private</span> DelegatingConstructorAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeConstructorAccessorImpl(Constructor&lt;?&gt; c) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate a constructor belonging to a vm-anonymous class</span></span><br><span class="line">        <span class="comment">// because that kind of class can't be referred to by name, hence can't</span></span><br><span class="line">        <span class="comment">// be found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123;</span><br><span class="line">            ConstructorAccessorImpl acc = (ConstructorAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateConstructor(c.getDeclaringClass(),</span><br><span class="line">                                        c.getParameterTypes(),</span><br><span class="line">                                        c.getExceptionTypes(),</span><br><span class="line">                                        c.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newInstance0(c, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingConstructorAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个就是最终构造实例化对象的native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">newInstance0</span><span class="params">(Constructor&lt;?&gt; c, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException,</span></span><br><span class="line"><span class="function">               IllegalArgumentException,</span></span><br><span class="line"><span class="function">               InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NativeConstructorAccessorImpl#newInstance0()</code>就是最终构造实例化对象的Native方法。当然有例外的情况，例如非正常调用下，如果构造器的宿主类是一个抽象类，那么最终会返回一个<code>InstantiationExceptionConstructorAccessorImpl</code>实例，里面直接抛出InstantiationException异常。</p>
<h3 id="处理方法调用的底层实现">处理方法调用的底层实现</h3>
<p><code>Method#invoke()</code>调用依赖于<code>MethodAccessor</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MethodAccessor接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Matches specification in &#123;<span class="doctag">@link</span> java.lang.reflect.Method&#125; */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">           InvocationTargetException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz,</span><br><span class="line">                        Modifier.isStatic(modifiers) ? <span class="keyword">null</span> : obj.getClass(),</span><br><span class="line">                        modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">        MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">        <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>获取<code>MethodAccessor</code>实例的逻辑和前两节类似，是通过<code>ReflectionFactory#newMethodAccessor()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    checkInitted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Reflection.isCallerSensitive(method)) &#123;</span><br><span class="line">        Method altMethod = findMethodForReflection(method);</span><br><span class="line">        <span class="keyword">if</span> (altMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            method = altMethod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use the root Method that will not cache caller class</span></span><br><span class="line">    Method root = langReflectAccess.getRoot(method);</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        method = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">            generateMethod(method.getDeclaringClass(),</span><br><span class="line">                           method.getName(),</span><br><span class="line">                           method.getParameterTypes(),</span><br><span class="line">                           method.getReturnType(),</span><br><span class="line">                           method.getExceptionTypes(),</span><br><span class="line">                           method.getModifiers());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NativeMethodAccessorImpl acc =</span><br><span class="line">            <span class="keyword">new</span> NativeMethodAccessorImpl(method);</span><br><span class="line">        DelegatingMethodAccessorImpl res =</span><br><span class="line">            <span class="keyword">new</span> DelegatingMethodAccessorImpl(acc);</span><br><span class="line">        acc.setParent(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会委托到<code>NativeMethodAccessorImpl#invoke(Object obj, Object[] args)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method method) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// We can't inflate methods belonging to vm-anonymous classes because</span></span><br><span class="line">        <span class="comment">// that kind of class can't be referred to by name, hence can't be</span></span><br><span class="line">        <span class="comment">// found from the generated bytecode.</span></span><br><span class="line">        <span class="keyword">if</span> (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br><span class="line">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br><span class="line">                <span class="keyword">new</span> MethodAccessorGenerator().</span><br><span class="line">                    generateMethod(method.getDeclaringClass(),</span><br><span class="line">                                   method.getName(),</span><br><span class="line">                                   method.getParameterTypes(),</span><br><span class="line">                                   method.getReturnType(),</span><br><span class="line">                                   method.getExceptionTypes(),</span><br><span class="line">                                   method.getModifiers());</span><br><span class="line">            parent.setDelegate(acc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(method, obj, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method m, Object obj, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>NativeMethodAccessorImpl#invoke0()</code>就是方法调用的最终调用的Native方法。</p>
<h2 id="小结">小结</h2>
<p>学习知识过程总是阶梯式上升的，JDK中的类库设计也类似这样，如果提前熟悉<code>Unsafe</code>类的相关方法，其实反射调用的底层实现也能够相对轻易地理解。属性、构造和方法反射调用底层的实现(<strong>只考虑正常调用的情况下</strong>)如下：</p>
<ul>
<li>对于属性(Field)：<code>Field#setXX()</code>和<code>Field#getXX()</code>分别对应<code>Unsafe</code>的<code>putXX()</code>和<code>getXX()</code>方法，也就是说完全依赖<code>Unsafe</code>中的Native方法。</li>
<li>对于构造(Constructor)：<code>Constructor#newInstance()</code>底层调用<code>NativeConstructorAccessorImpl#newInstance0()</code>。</li>
<li>对于方法(Method)：<code>Method#invoke()</code>底层调用<code>NativeMethodAccessorImpl#invoke0()</code></li>
</ul>
<p>(本文完 e-a-20181216 c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/15/java-reflection-handle-exception/">
      深入分析Java反射(六)-反射调用异常处理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月15日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：1.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：6分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-01-08T00:04:20+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2019年1月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(六)-反射调用异常处理</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍一个使用反射一定会遇到的问题-反射调用异常处理。</p>
<h2 id="反射调用异常处理">反射调用异常处理</h2>
<p>反射调用出现异常的方法主要考虑下面的情况：</p>
<ul>
<li>属性操作：<code>java.lang.reflect.Field#set(Object obj, Object value)</code>和<code>java.lang.reflect.Field#get(Object obj)</code>。</li>
<li>构造器调用：<code>java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>。</li>
<li>方法调用：<code>java.lang.reflect.Method#invoke(Object obj, Object... args)</code>。</li>
</ul>
<h3 id="处理属性操作异常">处理属性操作异常</h3>
<p>先看设置属性的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br></pre></td></tr></table></figure>
<p>实际上，通过方法注释可以得知会抛出四种异常：</p>
<ul>
<li>IllegalAccessException：非法访问异常，<strong>注意它是检查(checked)异常</strong>，也就是需要显示捕获，此异常会在修饰符禁用访问的时候抛出，可以通过<code>setAccessible(true)</code>抑制修饰符检查来避免抛出此异常。</li>
<li>IllegalArgumentException：非法参数异常，它是运行时异常，当入参实例obj不是当前Field所在类(包括父类、子类和接口)的时候会抛出此异常。</li>
<li>NullPointerException：空指针异常，当入参实例obj为null的时候会抛出此异常。</li>
<li>ExceptionInInitializerError：初始化器调用异常导致的错误，如果由于<code>set(Object obj, Object value)</code>方法引发的初始化失败会包装成ExceptionInInitializerError，此异常的父类为Error，常见的发生情况就是静态成员或者静态代码块依赖到反射属性设置。</li>
</ul>
<p>前面三种异常都很好理解，最后一个ExceptionInInitializerError可能有点陌生，它的抛出条件是：在静态代码块初始化解析过程总抛出异常或者静态变量初始化的时候抛出异常。笔者尝试了很多例子都没办法造出案例，从Stackoverflow找到一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field = Fail.class.getDeclaredField("number");</span><br><span class="line">        field.set(<span class="keyword">null</span>, <span class="number">42</span>); <span class="comment">// Fail class isn't initialized at this point</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> val = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); <span class="comment">// causes initialization to end with an exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说就是：静态代码块和静态变量的初始化顺序和它们在类文件编写的顺序是一致的，如果一个类未初始化直接使用它的静态代码块和静态变量通过<code>Field#set(Object obj, Object value)</code>调用就会出现ExceptionInInitializerError异常。</p>
<p>属性的获取方法抛出的异常和设置值方法是一致的，这里不做详细展开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException</span></span><br></pre></td></tr></table></figure>
<h3 id="处理构造器调用异常">处理构造器调用异常</h3>
<p>构造器调用主要是用于对象的实例化，先看<code>newInstance</code>方法的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(Object ... initargs)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>InstantiationException：实例化异常，抛出此异常的一般情况是：当前构造所在类型为一个抽象类型。</li>
<li>IllegalAccessException：非法访问异常。</li>
<li>IllegalArgumentException：非法参数异常，下面的情况会抛出此异常：参数数量或者类型不匹配，参数列表为原始类型但是实际使用了包装类型、参数列表为原始类型但是实际使用了包装类型、构造所在的类是枚举类型等。</li>
<li>InvocationTargetException：目标调用异常，这个是需要处理的重点异常，在下一节&quot;处理方法调用异常&quot;详细探讨。</li>
</ul>
<p>这里只举个例子说明一下InstantiationException出现的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractSample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Constructor&lt;AbstractSample&gt; declaredConstructor = AbstractSample<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>()</span>;</span><br><span class="line">		declaredConstructor.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面的抽象类<code>AbstractSample</code>包含一个默认的公有构造，使用<code>Constructor#newInstance()</code>会抛出InstantiationException异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.InstantiationException</span><br><span class="line">	at java.base/jdk.internal.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:<span class="number">48</span>)</span><br><span class="line">	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">490</span>)</span><br><span class="line">	at club.throwable.jdk.sample.reflection.reflect.AbstractSample.main(AbstractSample.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<h3 id="处理方法调用异常">处理方法调用异常</h3>
<p>方法调用是反射中使用频率最高的反射操作，主要是<code>Method#invoke(Object obj, Object... args)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException</span></span><br></pre></td></tr></table></figure>
<p>主要包括以下几种异常：</p>
<ul>
<li>IllegalAccessException：非法访问异常。</li>
<li>IllegalArgumentException：非法参数异常，下面的情况会抛出此异常：入参obj并不是当前实例方法对应的实例对象、参数数量或者类型不匹配，参数列表为原始类型但是实际使用了包装类型、参数列表为原始类型但是实际使用了包装类型等等。</li>
<li>NullPointerException：空指针异常，入参obj为null时候会抛出此异常。</li>
<li>ExceptionInInitializerError：初始化器调用异常导致的错误。</li>
<li>InvocationTargetException：目标调用异常。</li>
</ul>
<p>重点看InvocationTargetException(继承自ReflectiveOperationException，而ReflectiveOperationException继承自Exception，<strong>也就是它是checked异常，必须显式捕获</strong>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetException</span> <span class="keyword">extends</span> <span class="title">ReflectiveOperationException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4085088731926701167L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 持有的目标异常实例</span></span><br><span class="line">    <span class="keyword">private</span> Throwable target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);  <span class="comment">// Disallow initCause</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocationTargetException</span><span class="params">(Throwable target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Throwable)<span class="keyword">null</span>);  <span class="comment">// Disallow initCause</span></span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getTargetException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中得知：方法(Method)或者构造(Constructor)调用异常会抛出此InvocationTargetException异常，用于包装源异常，源异常实例作为目标被InvocationTargetException通过成员target持有，可以通过<code>InvocationTargetException#getTargetException()</code>或者<code>InvocationTargetException#getCause()</code>获取原始的目标异常。这里注意到，InvocationTargetException在覆盖父类构造的时候使用了null，所以调用其<code>getMessage()</code>方法会得到null。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationTargetExceptionMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		InvocationTargetExceptionMain main = <span class="keyword">new</span> InvocationTargetExceptionMain();</span><br><span class="line">		Method method = InvocationTargetExceptionMain.class.getDeclaredMethod("method");</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			method.invoke(main);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">			<span class="comment">//no-op</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"InvocationTargetException#message:"</span> + e.getMessage());</span><br><span class="line">			<span class="keyword">if</span> (e.getTargetException() <span class="keyword">instanceof</span> NullPointerException) &#123;</span><br><span class="line">				NullPointerException nullPointerException = (NullPointerException) e.getTargetException();</span><br><span class="line">				System.out.println(<span class="string">"NullPointerException#message:"</span> + nullPointerException.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvocationTargetException#message:null</span><br><span class="line">NullPointerException#message:Null</span><br></pre></td></tr></table></figure>
<p>构造器<code>Constructor#newInstance()</code>中抛出InvocationTargetException的场景是类似的。</p>
<h2 id="小结">小结</h2>
<p>在反射操作中，方法调用的频次是最高的，其次是通过构造器实例化对象。需要重点关注这两个地方的异常处理，特别是异常类型<code>InvocationTargetException</code>，紧记需要获取原始目标异常类型再进行判断，否则很容易导致逻辑错误(最近笔者在做一个功能的时候刚好踩了这个坑)。</p>
<p>(本文完 e-a-20181215 c-2-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/13/java-magic-unsafe/">
      神奇的魔法类和双刃剑-Unsafe
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月13日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：5.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：20分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-13T23:47:39+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月13日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>神奇的魔法类和双刃剑-Unsafe</h1>
<h2 id="前提">前提</h2>
<p>JDK9或者以后，<code>sun.misc</code>包的源码也可以上传到JDK类库中，可以直接导入IDE进行注释的阅读，这一点是比较好的改进。本文基于JDK11的源码阅读Unsafe类的注释，介绍一下这个类的使用方式。</p>
<h2 id="Unsafe简介">Unsafe简介</h2>
<p>在JDK9之后，<code>sun.misc.Unsafe</code>被移动到<code>jdk.unsupported</code>模块中，同时在<code>java.base</code>模块克隆了一个<code>jdk.internal.misc.Unsafe</code>类，代替了JDK8以前的<code>sun.misc.Unsafe</code>的功能，<code>jdk.internal</code>包不开放给开发者调用。</p>
<p>Unsafe是用于在实质上扩展Java语言表达能力、便于在更高层（Java层）代码里实现原本要在更低层（C层）实现的核心库功能用的。这些功能包括裸内存的申请/释放/访问，低层硬件的atomic/volatile支持，创建未初始化对象等。它原本的设计就只应该被标准库使用。</p>
<p>为了让开发者有机会过渡到尽量不使用<code>sun.misc.Unsafe</code>，默认不允许Java应用代码访问<code>sun.misc.Unsafe</code>类，同时在<code>java.base</code>模块克隆了一个不能被外部访问的<code>jdk.internal.misc.Unsafe</code>类用于JDK内部API演进。</p>
<h2 id="获取Unsafe实例">获取Unsafe实例</h2>
<p><code>sun.misc.Unsafe</code>提供了一个静态方法来获取其实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VM类中的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSystemDomainLoader</span><span class="params">(ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loader == <span class="keyword">null</span> || loader == ClassLoader.getPlatformClassLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个静态方法<code>getUnsafe()</code>必须在当前调用的类对应的类加载器为null(<strong>类加载器为null也就是当前调用的类必须使用Bootstrap类加载器加载</strong>)或者为<code>PlatformClassLoader</code>才不会抛出<code>SecurityException</code>异常。由于对<code>PlatformClassLoader</code>理解不深入，所以我们可以用VM参数<code>-Xbootclasspath:</code>让当前的调用类被Bootstrap类加载器加载。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-unsafe-1.png" alt="j-unsafe-1"></p>
<p>但是试验了一下(其实文档中已经提到此参数已经失效，不过这里还是试了下)，发现这个参数在JDK9之后已经不支持，使用的时候会导致JVM启动失败，异常信息是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">-Xbootclasspath is no longer a supported option.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure>
<p>此特性暂时在JDK9以后找不到替代的VM参数，所以这里只能选择其他可行方法。查看<code>sun.misc.Unsafe</code>所在模块的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> jdk.unsupported &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.sun.nio.file;</span><br><span class="line">    <span class="keyword">exports</span> sun.misc;</span><br><span class="line">    <span class="keyword">exports</span> sun.reflect;</span><br><span class="line"></span><br><span class="line">    opens sun.misc;</span><br><span class="line">    opens sun.reflect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>sun.misc</code>是opens修饰的，可以使用反射直接调用。因此可以像下面这样获取<code>sun.misc.Unsafe</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Field f = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">		f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		Unsafe unsafe = (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有特殊的技巧可以直接暴露<code>jdk.internal.misc.Unsafe</code>所在的模块让它可以直接使用反射调用，只需要使用参数<code>addExports:java.base/jdk.internal.misc=ALL-UNAMED</code>，这样子就可以反射获取<code>jdk.internal.misc.Unsafe</code>的实例，不过推荐这种做法，毕竟<code>jdk.internal.misc.Unsafe</code>中提供更多底层的方法，能力越大越容易失去控制。</p>
<h2 id="Unsafe的使用建议">Unsafe的使用建议</h2>
<p>使用Unsafe要注意以下几个问题：</p>
<p>1、Unsafe有可能在未来的JDK版本移除或者不允许Java应用代码使用，这一点可能导致使用了Unsafe的应用无法运行在高版本的JDK。<br>
2、Unsafe的不少方法中必须提供原始地址(内存地址)和被替换对象的地址，偏移量要自己计算，一旦出现问题就是JVM崩溃级别的异常，会导致整个JVM实例崩溃，表现为应用程序直接crash掉(<strong>其实这个很好理解，JVM是C语言写出来的软件，如果操作一个不存在的内存地址，在C程序中就是引发程序崩溃的操作</strong>)。<br>
3、Unsafe提供的直接内存访问的方法中使用的内存不受JVM管理(无法被GC)，需要手动管理，一旦出现疏忽很有可能成为内存泄漏的源头。</p>
<p>暂时总结出以上三点问题。Unsafe在JUC(java.util.concurrent)包中大量使用(主要是CAS)，在netty中方便使用直接内存，还有一些高并发的交易系统为了提高CAS的效率也有可能直接使用到Unsafe。总而言之，Unsafe类是魔法类，也可以说是一把双刃剑。</p>
<h2 id="Unsafe的核心方法">Unsafe的核心方法</h2>
<p><code>sun.misc.Unsafe</code>一共提供了89个public修饰的方法，下面针对核心方法按功能分组简单介绍一下。</p>
<h3 id="类操作">类操作</h3>
<p>类操作相关主要和类实例化、属性地址获取等等操作，原来存在一个<code>defineClass</code>方法，已经被移除，但是该方法在<code>jdk.internal.misc.Unsafe</code>中依然存在。</p>
<p><strong>ensureClassInitialized</strong></p>
<ul>
<li><code>public boolean shouldBeInitialized(Class&lt;?&gt; c)</code></li>
</ul>
<p>检测给定的类是否已经初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。</p>
<p><strong>shouldBeInitialized</strong></p>
<ul>
<li><code>public boolean shouldBeInitialized(Class&lt;?&gt; c)</code></li>
</ul>
<p>检测给定的类是否需要初始化。通常需要使用在获取一个类的静态属性的时候(因为一个类如果没初始化，它的静态属性也不会初始化)。 此方法当且仅当<code>ensureClassInitialized</code>方法不生效的时候才返回false。</p>
<p><strong>defineAnonymousClass</strong></p>
<ul>
<li>
<p><code>public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches)</code></p>
<ul>
<li>hostClass：宿主类。</li>
<li>data：字节码字节数组。</li>
<li>cpPatches：替换常量池(Constant Pool)中的字面量得到的引用数组。</li>
</ul>
</li>
</ul>
<p>这个方法的使用可以看R大的知乎回答：<a href="https://www.zhihu.com/question/51132462" target="_blank" rel="noopener">JVM crashes at libjvm.so</a>，下面截取一点内容解释此方法。</p>
<ul>
<li>1、VM Anonymous Class可以看作一种模板机制，如果程序要动态生成很多结构相同、只是若干变量不同的类的话，可以先创建出一个包含占位符常量的正常类作为模板，然后利用<code>sun.misc.Unsafe#defineAnonymousClass()</code>方法，传入该类(host class，宿主类或者模板类)以及一个作为&quot;constant pool path&quot;的数组来替换指定的常量为任意值，结果得到的就是一个替换了常量的<code>VM Anonymous Class</code>。</li>
<li>2、<code>VM Anonymous Class</code>从VM的角度看是真正的&quot;没有名字&quot;的，在构造出来之后只能通过<code>Unsafe#defineAnonymousClass()</code>返回出来一个Class实例来进行反射操作。</li>
</ul>
<p>还有其他几点看以自行阅读。这个方法虽然翻译为&quot;定义匿名类&quot;，但是它所定义的类和实际的匿名类有点不相同，因此一般情况下我们不会用到此方法。在JDK中Lambda表达式的构造依赖到此方法，可以看<code>InnerClassLambdaMetafactory</code>这个类。<strong>方法的注释：定义一个不被类加载器系统或者系统字典感知的类型</strong>。</p>
<p><strong>allocateInstance</strong></p>
<ul>
<li><code>public native Object allocateInstance(Class&lt;?&gt; cls)</code></li>
</ul>
<p>注意此方法是JVM本地接口方法，通过Class对象创建一个类的实例，不需要调用其构造函数、初始化代码、JVM安全检查等等。同时，它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化。</p>
<p><strong>staticFieldBase</strong></p>
<ul>
<li><code>public Object staticFieldBase(Field f)</code></li>
</ul>
<p>返回给定的静态属性所在的位置(其实就是所在的对象的内存快照)，配合<code>staticFieldOffset</code>方法使用。实际上，这个方法返回值就是静态属性所在的Class对象的一个内存快照。注释中说到，此方法返回的Object有可能为null，它只是一个’cookie’而不是真实的对象，不要直接使用的它的实例中的获取属性和设置属性的方法，它的作用只是方便调用像<code>getInt(Object,long)</code>等等的任意方法。</p>
<p><strong>staticFieldOffset</strong></p>
<ul>
<li><code>public long staticFieldOffset(Field f)</code></li>
</ul>
<p>返回给定的<strong>静态属性</strong>在它的类的内存分配中的位置(内存偏移地址)。不要在这个偏移量上执行任何类型的算术运算，它只是一个被传递给不安全的堆内存访问器的cookie。注意：这个方法仅仅针对静态属性，使用在非静态属性上会抛异常。</p>
<p><strong>objectFieldOffset</strong></p>
<ul>
<li><code>public long staticFieldOffset(Field f)</code></li>
</ul>
<p>返回给定的<strong>非静态属性</strong>在它的类的内存分配中的位置(内存偏移地址)。不要在这个偏移量上执行任何类型的算术运算，它只是一个被传递给不安全的堆内存访问器的cookie。注意：这个方法仅仅针对非静态属性，使用在静态属性上会抛异常。</p>
<p><strong>defineClass</strong></p>
<ul>
<li><code>public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain)</code></li>
</ul>
<p>这个方法位于<code>jdk.internal.misc.Unsafe</code>，也就是开发者无法直接使用。作用是：绕过安全检查告知JVM定义一个类。默认情况下，ClassLoader(类加载器)和ProtectionDomain(保护域)实例应该来源于调用者。</p>
<h3 id="基于内存地址直接存取属性">基于内存地址直接存取属性</h3>
<p>前一节中提供了一些方法可以直接获取静态或者非静态成员属性的内存地址，这一节介绍的API可以基于成员属性内存地址直接获取或者设置其值。</p>
<p><strong>getObject</strong></p>
<ul>
<li><code>public Object getObject(Object o, long offset)</code></li>
</ul>
<p>通过给定的Java对象和属性内存地址获取引用值。这里实际上是获取一个Java对象o中，获取偏移地址为offset的属性的值，此方法可以突破修饰符的抑制，也就是无视private、protected和default修饰符。类似的方法有<code>getInt</code>、<code>getDouble</code>等等。</p>
<p><strong>putObject</strong></p>
<ul>
<li>
<p><code>public void putObject(Object o, long offset, Object x)</code></p>
<ul>
<li>o：当前操作的对象。</li>
<li>offset：成员属性的内存地址。</li>
<li>x：需要设置的目标属性值。</li>
</ul>
</li>
</ul>
<p>将引用值存储到给定的Java变量中。这里实际上是设置一个Java对象o中偏移地址为offset的属性的值为x，此方法可以突破修饰符的抑制，也就是无视private、protected和default修饰符。类似的方法有putInt、putDouble等等。</p>
<p><strong>getObjectVolatile</strong></p>
<ul>
<li><code>public Object getObjectVolatile(Object o, long offset)</code></li>
</ul>
<p>此方法和上面的<code>getObject</code>功能类似，不过附加了<code>volatile</code>关键字加载语义，也就是强制从主存中获取属性值。类似的方法有<code>getIntVolatile</code>、<code>getDoubleVolatile</code>等等。这个方法要求被使用的属性被volatile修饰，否则功能和<code>getObject</code>方法相同。</p>
<p><strong>putObjectVolatile</strong></p>
<ul>
<li><code>public void putObjectVolatile(Object o, long offset, Object x)</code></li>
</ul>
<p>此方法和上面的<code>putObject</code>功能类似，不过附加了<code>volatile</code>关键字加载语义，也就是设置值的时候强制(JMM会保证获得锁到释放锁之间所有对象的状态更新都会在锁被释放之后)更新到主存，从而保证这些变更对其他线程是可见的。类似的方法有<code>putIntVolatile</code>、<code>putDoubleVolatile</code>等等。这个方法要求被使用的属性被volatile修饰，否则功能和putObject方法相同。</p>
<p><strong>putOrderedObject</strong></p>
<ul>
<li><code>public void putOrderedObject(Object o, long offset, Object x)</code></li>
</ul>
<p>设置o对象中offset偏移地址offset对应的Object型field的值为指定值x。这是一个有序或者有延迟的<code>putObjectVolatile</code>方法，并且不保证值的改变被其他线程立即看到。只有在属性被volatile修饰并且期望被修改的时候使用才会生效。类似的方法有<code>putOrderedInt</code>和<code>putOrderedLong</code>。方法注释中提到：相当于C11中的<code>atomic_store_explicit(..., memory_order_release)</code>。</p>
<h3 id="数组操作">数组操作</h3>
<p><strong>arrayBaseOffset</strong></p>
<ul>
<li><code>public int arrayBaseOffset(Class&lt;?&gt; arrayClass)</code></li>
</ul>
<p>返回数组类型的第一个元素的偏移地址(基础偏移地址)。如果arrayIndexScale方法返回的比例因子不为0，你可以通过结合基础偏移地址和比例因子访问数组的所有元素。Unsafe中已经初始化了很多类似的常量如<code>ARRAY_BOOLEAN_BASE_OFFSET</code>等。</p>
<p><strong>arrayIndexScale</strong></p>
<ul>
<li><code>public int arrayIndexScale(Class&lt;?&gt; arrayClass)</code></li>
</ul>
<p>返回数组类型的比例因子(其实就是数据中元素偏移地址的增量，因为数组中的元素的地址是连续的)。此方法不适用于数组类型为&quot;narrow&quot;类型的数组，&quot;narrow&quot;类型的数组类型使用此方法会返回0(这里narrow应该是狭义的意思，但是具体指哪些类型暂时不明确，笔者查了很多资料也没找到结果)。Unsafe中已经初始化了很多类似的常量如<code>ARRAY_BOOLEAN_INDEX_SCALE</code>等。</p>
<h3 id="低级同步原语">低级同步原语</h3>
<p>低级同步原语的相关方法在JDK8还能通过<code>sun.misc.Unsafe</code>使用，在JDK9以后<code>sun.misc.Unsafe</code>和<code>jdk.internal.misc.Unsafe</code>都移除了相关的方法。低级同步原语主要包括监视器锁定、解锁方法。</p>
<p><strong>monitorEnter</strong></p>
<ul>
<li><code>public native void monitorEnter(Object o)</code></li>
</ul>
<p>锁定对象，必须通过monitorExit方法才能解锁。此方法经过实验是可以重入的，也就是可以多次调用，然后通过多次调用monitorExit进行解锁。</p>
<p><strong>monitorExit</strong></p>
<ul>
<li><code>public native void monitorExit(Object o)</code></li>
</ul>
<p>解锁对象，前提是对象必须已经调用monitorEnter进行加锁，否则抛出IllegalMonitorStateException异常。</p>
<p><strong>tryMonitorEnter</strong></p>
<ul>
<li><code>public native boolean tryMonitorEnter(Object o)</code></li>
</ul>
<p>尝试锁定对象，如果加锁成功返回true，否则返回false。必须通过monitorExit方法才能解锁。</p>
<h3 id="线程挂起与恢复">线程挂起与恢复</h3>
<p>JDK1.5引入了并发包<code>java.util.concurrent</code>中组件控制线程挂起和恢复就是依赖于<code>java.util.concurrent.locks.LockSupport</code>完成，而<code>LockSupport</code>底层依赖于<code>sun.misc.Unsafe</code>中下面提到线程的挂起和恢复方法完成的。相关方法主要是用于替代线程类<code>Thread</code>中过时并且不安全的<code>suspend</code>和<code>resume</code>方法。</p>
<p><strong>park</strong></p>
<ul>
<li>
<p><code>public void park(boolean isAbsolute, long time)</code></p>
<ul>
<li>time：时间长度，单位由isAbsolute控制，0表示永久阻塞。</li>
<li>isAbsolute：如果isAbsolute为true，time是相对于新纪元之后的毫秒，否则time表示纳秒。</li>
</ul>
</li>
</ul>
<p>注释：阻塞当前线程直到一个<code>unpark</code>方法出现(被调用)、一个用于<code>unpark</code>方法已经出现过(在此<code>park</code>方法调用之前已经调用过)、线程被中断或者time时间到期(也就是阻塞超时)。在time非零的情况下，如果isAbsolute为true，time是相对于新纪元之后的毫秒，否则time表示纳秒。这个方法执行时也可能不合理地返回(没有具体原因)。</p>
<p><strong>unpark</strong></p>
<ul>
<li><code>public void unpark(Object thread)</code></li>
</ul>
<p>释放被<code>park</code>创建的在一个线程上的阻塞。这个方法也可以被使用来终止一个先前调用<code>park</code>导致的阻塞。这个操作是不安全的，因此必须保证线程是存活的(thread has not been destroyed)。从Java代码中判断一个线程是否存活的是显而易见的，所以解除阻塞的时候需要对线程的存活性做判断。</p>
<p><strong>重点注意：</strong></p>
<ul>
<li><code>unpark</code>方法调用多次，实际上只有一次会生效，可以简单理解为它是一个只有0和1两个值的计数器，调用<code>unpark</code>多次，计数仍然为1。</li>
<li><code>park</code>方法总是针对当前线程，如果预先已经调用过一次<code>unpark</code>方法后再调用<code>park</code>方法，那么<strong>将不会进入阻塞状态直接释放</strong>。</li>
</ul>
<h3 id="CAS操作">CAS操作</h3>
<p>CAS，也就是Compare And Swap，也就是在一个原子操作中完成比较和交互。</p>
<p><strong>compareAndSwapObject</strong></p>
<ul>
<li>
<p><code>public final boolean compareAndSwapObject(Object o, long offset, Object expected, Object x)</code></p>
<ul>
<li>o：目标Java变量引用。</li>
<li>offset：目标Java变量中的目标属性的偏移地址。</li>
<li>expected：目标Java变量中的目标属性的期望的当前值。</li>
<li>x：目标Java变量中的目标属性的目标更新值。</li>
</ul>
</li>
</ul>
<p>针对Object对象进行CAS操作。即是对应Java变量引用o，原子性地更新o中偏移地址为offset的属性的值为x，当且仅的偏移地址为offset的属性的当前值为expected才会更新成功返回true，否则返回false。类似的方法有<code>compareAndSwapInt</code>和<code>compareAndSwapLong</code>，在Jdk8中基于CAS扩展出来的相关方法有<code>getAndAddInt</code>、<code>getAndAddLong</code>、<code>getAndSetInt</code>、<code>getAndSetLong</code>、<code>getAndSetObject</code>，它们的作用都是：通过CAS设置新的值，返回旧的值。</p>
<p><strong>getAndSetObject</strong></p>
<ul>
<li><code>public final Object getAndSetObject(Object o, long offset, Object newValue)</code></li>
</ul>
<p>见<strong>compareAndSwapObject</strong>中的描述。</p>
<h3 id="内存管理">内存管理</h3>
<p><strong>addressSize</strong></p>
<ul>
<li><code>public int addressSize();</code></li>
</ul>
<p>获取本地指针的大小(单位是byte)，通常值为4或者8。常量ADDRESS_SIZE就是调用此方法。</p>
<p><strong>pageSize</strong></p>
<ul>
<li><code>public int pageSize();</code></li>
</ul>
<p>获取本地内存的页数，此值为2的幂次方。</p>
<p><strong>allocateMemory</strong></p>
<ul>
<li><code>public long allocateMemory(long bytes);</code></li>
</ul>
<p>分配一块新的本地内存，通过bytes指定内存块的大小(单位是byte)，返回新开辟的内存的地址。如果内存块的内容不被初始化，那么它们一般会变成内存垃圾。生成的本机指针永远不会为零，并将对所有值类型进行对齐。可以通过<code>freeMemory</code>方法释放内存块，或者通过<code>reallocateMemory</code>方法调整内存块大小。bytes值为负数或者过大会抛出IllegalArgumentException异常，如果系统拒绝分配内存会抛出OutOfMemoryError异常。</p>
<p><strong>reallocateMemory</strong></p>
<ul>
<li><code>public long reallocateMemory(long address, long bytes);</code></li>
</ul>
<p>通过指定的内存地址address重新调整本地内存块的大小，调整后的内存块大小通过bytes指定(单位为byte)。可以通过<code>freeMemory</code>方法释放内存块，或者通过<code>reallocateMemory</code>方法调整内存块大小。bytes值为负数或者过大会抛出IllegalArgumentException异常，如果系统拒绝分配内存会抛出OutOfMemoryError异常。</p>
<p><strong>setMemory</strong></p>
<ul>
<li><code>public void setMemory(Object o, long offset, long bytes, byte value);</code></li>
</ul>
<p>将给定内存块中的所有字节设置为固定值(通常是0)。内存块的地址由对象引用o和偏移地址共同决定，如果对象引用o为null，offset就是绝对地址。第三个参数就是内存块的大小，如果使用<code>allocateMemory</code>进行内存开辟的话，这里的值应该和<code>allocateMemory</code>的参数一致。value就是设置的固定值，一般为0(这里可以参考netty的DirectByteBuffer)。一般而言，o为null，所有有个重载方法是<code>public void setMemory(long offset, long bytes, byte value);</code>，等效于<code>setMemory(null, long offset, long bytes, byte value);</code>。</p>
<p><strong>copyMemory</strong></p>
<ul>
<li><code>public void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes) </code></li>
</ul>
<p>拷贝给定内存地址的字节长度对应的字节到指定内存地址中。如果srcBase或者destBase为null，则srcOffset或者destOffset分别指代绝对地址。</p>
<h3 id="内存屏障">内存屏障</h3>
<p>内存屏障相关的方法是在Jdk8添加的。内存屏障相关的知识可以先自行查阅，笔者目前也没有深入了解相关知识。</p>
<p><strong>loadFence</strong></p>
<ul>
<li><code>public void loadFence();</code></li>
</ul>
<p>在该方法之前的所有读操作，一定在load屏障之前执行完成。</p>
<p><strong>storeFence</strong></p>
<ul>
<li><code>public void storeFence();</code></li>
</ul>
<p>在该方法之前的所有写操作，一定在store屏障之前执行完成</p>
<p><strong>fullFence</strong></p>
<ul>
<li><code>public void fullFence();</code></li>
</ul>
<p>在该方法之前的所有读写操作，一定在full屏障之前执行完成，这个内存屏障相当于上面两个(load屏障和store屏障)的合体功能。</p>
<h3 id="其它">其它</h3>
<p><strong>invokeCleaner</strong></p>
<ul>
<li><code>public void invokeCleaner(java.nio.ByteBuffer directBuffer)</code></li>
</ul>
<p>清空使用了堆外内存的<code>ByteBuffer</code>实例占据的内存，一般是<code>DirectBuffer</code>的子类。</p>
<p><strong>throwException</strong></p>
<ul>
<li><code>public void throwException(Throwable ee)</code></li>
</ul>
<p>绕过检测机制直接抛出异常。</p>
<p><strong>getLoadAverage</strong></p>
<ul>
<li><code>public int getLoadAverage(double[] loadavg, int nelems);</code></li>
</ul>
<p>获取系统的平均负载值，loadavg这个double数组将会存放负载值的结果，nelems决定样本数量，nelems只能取值为1到3，分别代表最近1、5、15分钟内系统的平均负载。如果无法获取系统的负载，此方法返回-1，否则返回获取到的样本数量(loadavg中有效的元素个数)。实验中这个方法一直返回-1，其实完全可以使用<strong>JMX</strong>中的相关方法替代此方法。</p>
<h2 id="使用例子">使用例子</h2>
<p>先封装一下获取<code>Unsafe</code>实例的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Field f = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">	f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> (Unsafe) f.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过内存地址直接操作属性">通过内存地址直接操作属性</h3>
<p>通过<code>staticFieldOffset</code>和<code>objectFieldOffset</code>可以获取静态和非静态成员属性的偏移地址，然后直接进行存取值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Integer STATIC_INT = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line">   Long longField = <span class="number">1024L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Unsafe unsafe = getUnsafe();</span><br><span class="line">		Field staticInt = Simple.class.getDeclaredField("STATIC_INT");</span><br><span class="line">		staticInt.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		Object staticFieldBase = unsafe.staticFieldBase(staticInt);</span><br><span class="line">		<span class="keyword">long</span> staticFieldOffset = unsafe.staticFieldOffset(staticInt);</span><br><span class="line">		<span class="comment">// 注意这里一定要getObject,getInt是针对原始类型int,包装类型要自己强转</span></span><br><span class="line">		System.out.println(<span class="string">"Sample初始化前,STATIC_INT = "</span> + unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line">		Simple simple = <span class="keyword">new</span> Simple();</span><br><span class="line">		System.out.println(<span class="string">"Sample初始化后,STATIC_INT = "</span> + unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line"></span><br><span class="line">		Field longField = Simple.class.getDeclaredField("longField");</span><br><span class="line">		longField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">long</span> objectFieldOffset = unsafe.objectFieldOffset(longField);</span><br><span class="line">		System.out.println(<span class="string">"Sample初始化后,longField = "</span> + unsafe.getObject(simple, objectFieldOffset));</span><br><span class="line">		unsafe.putObject(simple,objectFieldOffset, <span class="number">4201L</span>);</span><br><span class="line">		System.out.println(<span class="string">"Sample属性被覆盖后,longField = "</span> + simple.longField);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line">Sample初始化前,STATIC_INT = <span class="keyword">null</span></span><br><span class="line">Sample初始化后,STATIC_INT = <span class="number">10086</span></span><br><span class="line">Sample初始化后,longField = <span class="number">1024</span></span><br><span class="line">Sample属性被覆盖后,longField = <span class="number">4201</span></span><br></pre></td></tr></table></figure>
<h3 id="线程挂起和恢复">线程挂起和恢复</h3>
<p>主要介绍一下<code>park</code>和<code>unpark</code>的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Unsafe unsafe = getUnsafe();</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"线程park!"</span>);</span><br><span class="line">				unsafe.park(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">				System.out.println(<span class="string">"线程恢复运行!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">"主线程unpark阻塞着的线程!"</span>);</span><br><span class="line">		unsafe.unpark(thread);</span><br><span class="line">		TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行后输出：</span></span><br><span class="line">线程park!</span><br><span class="line">主线程unpark阻塞着的线程!</span><br><span class="line">线程恢复运行!</span><br></pre></td></tr></table></figure>
<h3 id=""></h3>
<h2 id="小结">小结</h2>
<p>存在即合理，虽然不推荐使用<code>Unsafe</code>，但是如果有需要的还是要挥动这把双刃剑。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.zhihu.com/question/29266773?sort=created" target="_blank" rel="noopener">为什么JUC中大量使用了sun.misc.Unsafe 这个类，但官方却不建议开发者使用？</a></li>
<li>JDK11相关源码</li>
<li><a href="http://ifeve.com/sun-misc-unsafe/" target="_blank" rel="noopener">Java Magic. Part 4: sun.misc.Unsafe</a></li>
</ul>
<p>(本文完 e-a-20181213 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/09/java-reflection-class-load/">
      深入分析Java反射(五)-类实例化和类加载
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月9日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：3.6k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：15分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-12T00:45:32+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月12日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(五)-类实例化和类加载</h1>
<h2 id="前提">前提</h2>
<p>其实在前面写过的《深入分析Java反射(一)-核心类库和方法》已经介绍过通过类名或者<code>java.lang.Class</code>实例去实例化一个对象，在《浅析Java中的资源加载》中也比较详细地介绍过类加载过程中的双亲委派模型，这篇文章主要是加深一些对类实例化和类加载的认识。</p>
<h2 id="类实例化">类实例化</h2>
<p>在反射类库中，用于实例化对象只有两个方法：</p>
<ul>
<li><code>T java.lang.Class#newInstance()</code>：这个方法只需要提供<code>java.lang.Class&lt;T&gt;</code>的实例就可以实例化对象，如果提供的是无限定类型<code>Class&lt;?&gt;</code>则得到的是Object类型的返回值，可以进行强转。这个方法不支持任何入参，底层实际上也是依赖无参数的构造器Constructor进行实例化。</li>
<li><code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>：这个方法需要提供<code>java.lang.reflect.Constructor&lt;T&gt;</code>实例和一个可变参数数组进行对象的实例化，上面提到的<code>T java.lang.Class#newInstance()</code>底层也是依赖此方法。这个方法除了可以传入构造参数之外，还有一个好处就是可以通过``抑制修饰符访问权限检查，也就是私有的构造器也可以用于实例化对象。</li>
</ul>
<p>在编写反射类库的时候，优先选择<code>T java.lang.reflect.Constructor#newInstance(Object ... initargs)</code>进行对象实例化，目前参考很多优秀的框架(例如Spring)都是用这个方法进行对象实例化。</p>
<h2 id="类加载">类加载</h2>
<p>类加载实际上由类加载器(ClassLoader)完成，<code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>方法提现了类加载过程中遵循了双亲委派模型，实际上，我们可以覆写此方法完全不遵循双亲委派模型，实现同一个类(这里指的是全类名完全相同)重新加载。JDK中提供类加载相关的特性有两个方法：</p>
<ul>
<li><code>protected Class&lt;?&gt; java.lang.ClassLoader#loadClass(String name, boolean resolve)</code>：通过类加载器实例去加载类，一般应用类路径下的类是由<code>jdk.internal.loader.ClassLoaders$AppClassLoader</code>加载，也可以自行继承<code>java.lang.ClassLoader</code>实现自己的类加载器。</li>
<li><code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>：通过全类名进行类加载，可以通过参数控制类初始化行为。</li>
</ul>
<h3 id="ClassLoader中的类加载">ClassLoader中的类加载</h3>
<p>类加载过程其实是一个很复杂的过程，主要包括下面的步骤：</p>
<ul>
<li>1、加载过程：使用(自定义)类加载器去获取类文件字节码字节类的过程，Class实例在这一步生成，作为方法区的各种数据类型的访问入口。</li>
<li>2、验证过程：JVM验证字节码的合法性。</li>
<li>3、准备过程：为类变量分配内存并且设置初始值。</li>
<li>4、解析过程：JVM把常量池中的符号替换为直接引用。</li>
<li>5、初始化过程：执行类构造器<code>&lt;cinit&gt;()</code>方法，<code>&lt;cinit&gt;()</code>方法是编译器自动收集所有类变量的赋值动作和静态代码块中的语句合并生成，收集顺序由语句在源文件中出现的顺序决定，JVM保证在子类<code>&lt;cinit&gt;()</code>方法调用前父类的<code>&lt;cinit&gt;()</code>方法已经执行完毕。</li>
</ul>
<p><code>ClassLoader#loadClass()</code>方法就是用于控制类加载过程的第一步-加载过程，也就是控制字节码字节数组和类名生成Class实例的过程。<code>ClassLoader</code>中还有一个<code>protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</code>方法用于指定全类名和字节码字节数组去定义一个类，我们再次看下<code>loadClass()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 检查类是否已经加载过，如果已经加载过，则直接返回</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="comment">// 委派父类加载器去加载类</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 委派父类加载器如果加载失败则调用findClass方法进行加载动作</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展点-1</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 扩展点-2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>loadClass()</code>方法留下了两个扩展点用于改变类加载的行为，而<code>findClass()</code>方法就是用于扩展父类加载器加载失败的情况下，子类加载器的行为。当然，实际上<code>Class&lt;?&gt; loadClass(String name, boolean resolve)</code>方法<strong>是非final的方法，可以整个方法覆写掉，这样子就有办法完全打破双亲委派机制</strong>。但是注意一点，即使打破双亲委派机制，子类加载器也不可能重新加载一些由Bootstrap类加载器加载的类库如<code>java.lang.String</code>，这些是由JVM验证和保证的。自定义类加载器的使用在下一节的&quot;类重新加载&quot;中详细展开。</p>
<p>最后还有两点十分重要：</p>
<ul>
<li>1、<strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性</strong>，也就是一个类在JVM中的签名是加载它的类加载器和它本身，<strong>对于每一个类加载器，都拥有一个独立的类命名空间</strong>。</li>
<li>2、<strong>比较两个类是否&quot;相等&quot;，只有这两个类是由同一个类加载器加载的前提下才有意义</strong>。即使这两个类的全类名一致、来源于同一个字节码文件、被同一个Java虚拟机加载，但是加载它们的类加载器不同，那么它们必定不相等。这里相等的范畴包括：<code>Class</code>对象的<code>equals()</code>方法、<code>isAssignableForm()</code>方法、<code>isInstance()</code>方法的返回结果以及使用<code>instanceof</code>关键字做对象所属关系时候的判定等情况。</li>
</ul>
<h3 id="Class中的类加载">Class中的类加载</h3>
<p><code>java.lang.Class</code>中的类加载主要由<code>public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</code>方法完成，该方法可以指定全类名、是否初始化和类加载器实例。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                               ClassLoader loader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    Class&lt;?&gt; caller = <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Reflective call to get caller class is only needed if a security manager</span></span><br><span class="line">        <span class="comment">// is present.  Avoid the overhead of making this call otherwise.</span></span><br><span class="line">        caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ClassLoader ccl = ClassLoader.getClassLoader(caller);</span><br><span class="line">            <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sm.checkPermission(</span><br><span class="line">                    SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                        ClassLoader loader,</span><br><span class="line">                                        Class&lt;?&gt; caller) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>
<p>它最终调用的是JVM的本地接口方法，由于暂时没有能力分析JVM的源码，只能通过<code>forName</code>方法的注释理解方法的功能：</p>
<blockquote>
<p>返回给定字符串全限定名称、指定类加载器的类或者接口的Class实例，此方法会尝试对类或者接口进行locate、load and link操作，如果loader参数为null，则使用bootstrap类加载器进行加载，如果initialize参数为true同时类或者接口在早期没有被初始化，则会进行初始化操作。</p>
</blockquote>
<p>也就是说initialize参数对于已经初始化过的类或者接口来说是没有意义的。这个方法的特性还可以参考<a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-12.html" target="_blank" rel="noopener">Java语言规范的12章中的内容</a>，这里不做展开。</p>
<p>虽然暂时没法分析JVM本地接口方法<code>native Class&lt;?&gt; forName0()</code>的功能，但是它依赖一个类加载器实例入参，可以大胆猜测它也是依赖于类加载器的<code>loadClass()</code>进行类加载的。</p>
<h2 id="类重新加载">类重新加载</h2>
<p>先提出一个实验，如果定义一个类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用字节码工具修改<code>say()</code>方法的内容为<code>System.out.println(&quot;Hello Throwable!&quot;);</code>，并且使用自定义的ClassLoader重新加载一个同类名的<code>Sample</code>类，那么通过<code>new</code>关键字实例化出来的<code>Sample</code>对象调用<code>say()</code>到底打印&quot;Hello Doge!“还是&quot;Hello Throwable!”？</p>
<p>先引入字节码工具javassist用于修改类的字节码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.24.0-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性使用的自定义类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">if</span> (!Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">		CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">		<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">		Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">        <span class="comment">// 类路径中的Demo类</span></span><br><span class="line">		Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">		demo.say();</span><br><span class="line">		<span class="comment">// 新的Demo类</span></span><br><span class="line">		newDemoClass.getDeclaredMethod(<span class="string">"say"</span>).invoke(newDemoClass.newInstance());</span><br><span class="line">		<span class="comment">// 比较</span></span><br><span class="line">		System.out.println(newDemoClass.equals(Demo<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello Doge!</span><br><span class="line">Hello Throwable!</span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>这里得出的结论是：</p>
<ul>
<li><code>new</code>关键字只能使用在当前类路径下的类的实例化，而这些类都是由应用类加载器加载，如果上面的例子中<code>newDemoClass.newInstance()</code>强制转换为Demo类型会报错。</li>
<li>通过自定义类加载器加载的和当前类路径相同名全类名的类只能通过反射去使用，而且即使全类名相同，由于类加载器隔离，它们其实是不相同的类。</li>
</ul>
<h3 id="如何避免类重新加载导致内存溢出">如何避免类重新加载导致内存溢出</h3>
<p>实际上，JDK没有提供方法去卸载一个已经加载的类，也就是类的生命周期是由JVM管理的，因此要解决类重新加载导致内存溢出的问题归根结底就是解决重新加载的类被回收的问题。由于创建出来是的<code>java.lang.Class</code>对象，如果需要回收它，则要考虑下面几点：</p>
<ul>
<li>1、<code>java.lang.Class</code>对象反射创建的实例需要被回收。</li>
<li>2、<code>java.lang.Class</code>对象不能被任何地方强引用。</li>
<li>3、加载<code>java.lang.Class</code>对象的<code>ClassLoder</code>已经被回收。</li>
</ul>
<p>基于这几点考虑可以做个试验验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里故意建立一个数组占用大量内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello Doge!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, List&lt;Class&lt;?&gt;&gt;&gt; CACHE = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		String name = Demo<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">		CtClass ctClass = ClassPool.getDefault().getCtClass(name);</span><br><span class="line">		CtMethod method = ctClass.getMethod(<span class="string">"say"</span>, <span class="string">"()V"</span>);</span><br><span class="line">		method.setBody(<span class="string">"&#123;System.out.println(\"Hello Throwable!\");&#125;"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = ctClass.toBytecode();</span><br><span class="line">			CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader(bytes);</span><br><span class="line">			<span class="comment">// 新的Demo类,只能反射调用,因为类路径中的Demo类已经被应用类加载器加载</span></span><br><span class="line">			Class&lt;?&gt; newDemoClass = classLoader.loadClass(name);</span><br><span class="line">			add(classLoader, newDemoClass);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理类加载器和它加载过的类</span></span><br><span class="line">		clear();</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (CACHE.containsKey(classLoader)) &#123;</span><br><span class="line">			CACHE.get(classLoader).add(clazz);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			CACHE.put(classLoader, classes);</span><br><span class="line">			classes.add(clazz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CACHE.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用VM参数<code>-XX:+PrintGC -XX:+PrintGCDetails</code>执行上面的方法，JDK11默认使用G1收集器，由于Z收集器还在实验阶段，不是很建议使用，执行main方法后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11.374</span>s][info   ][gc,task       ] GC(<span class="number">17</span>) Using <span class="number">8</span> workers of <span class="number">8</span> <span class="keyword">for</span> full compaction</span><br><span class="line">[<span class="number">11.374</span>s][info   ][gc,start      ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>)</span></span><br><span class="line"><span class="function">[11.374s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,stringtable ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Cleaned string and symbol table, strings: 5637 processed, 0 removed, symbols: 135915 processed, 0 removed</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 1: Mark live objects 54.378ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 2: Prepare <span class="keyword">for</span> compaction 0.422ms</span></span><br><span class="line"><span class="function">[11.429s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 3: Adjust pointers 0.598ms</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases,start] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap</span></span><br><span class="line"><span class="function">[11.430s][info   ][gc,phases      ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Phase 4: Compact heap 0.362ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Eden regions: 44-&gt;0<span class="params">(<span class="number">9</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Survivor regions: 12-&gt;0<span class="params">(<span class="number">12</span>)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Old regions: 146-&gt;7</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,heap        ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Humongous regions: 3-&gt;2</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,metaspace   ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Metaspace: 141897K-&gt;9084<span class="title">K</span><span class="params">(<span class="number">1062912</span>K)</span></span></span><br><span class="line"><span class="function">[11.648s][info   ][gc             ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 205M-&gt;3<span class="title">M</span><span class="params">(<span class="number">30</span>M)</span> 273.440ms</span></span><br><span class="line"><span class="function">[11.648s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.31</span>s Sys=<span class="number">0.08</span>s Real=<span class="number">0.27</span>s</span><br></pre></td></tr></table></figure>
<p>可见FullGC之后，元空间(Metaspace)回收了(141897-9084)KB，一共回收了202M的内存空间，初步可以认为元空间的内存被回收了，接下来注释掉main方法中调用的<code>clear()</code>方法，再调用一次main方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,heap        ] GC(<span class="number">17</span>) Humongous regions: <span class="number">3</span>-&gt;<span class="number">2</span></span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc,metaspace   ] GC(<span class="number">17</span>) Metaspace: <span class="number">141884</span>K-&gt;<span class="number">141884</span>K(<span class="number">1458176</span>K)</span><br><span class="line">[<span class="number">4.083</span>s][info   ][gc             ] GC(<span class="number">17</span>) <span class="function">Pause <span class="title">Full</span> <span class="params">(System.gc()</span>) 201M-&gt;166<span class="title">M</span><span class="params">(<span class="number">564</span>M)</span> 115.504ms</span></span><br><span class="line"><span class="function">[4.083s][info   ][gc,cpu         ] <span class="title">GC</span><span class="params">(<span class="number">17</span>)</span> User</span>=<span class="number">0.84</span>s Sys=<span class="number">0.00</span>s Real=<span class="number">0.12</span>s</span><br></pre></td></tr></table></figure>
<p>可见元空间在FullGC执行没有进行回收，而堆内存的回收率也比较低，由此可以得出一个经验性的结论：只需要通过ClassLoader对象做映射关系保存使用它加载出来的新的类，只需要确保这些类没有没强引用、类实例都已经销毁，那么只需要移除ClassLoader对象的引用，那么在JVM进行GC的时候会把ClassLoader对象以及使用它加载的类回收，这样做就可以避免元空间的内存泄漏。</p>
<h2 id="小结">小结</h2>
<p>通过一些资料和实验，深化了类加载过程的一些认识。</p>
<p>参考资料：</p>
<ul>
<li>《深入理解Java虚拟机-第二版》</li>
<li>JDK11部分源码</li>
</ul>
<p>(本文完 e-2018129 c-2-d r-20181212)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/08/java-reflection-dynamic-proxy/">
      深入分析Java反射(四)-动态代理
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月8日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.8k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：27分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-08T20:25:34+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月8日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(四)-动态代理</h1>
<h2 id="动态代理的简介">动态代理的简介</h2>
<p>Java动态代理机制的出现，使得Java开发人员不用手工编写代理类，只要简单地指定一组接口及委托类对象，便能动态地获得代理类。代理类会负责将所有的方法调用分派到委托对象上反射执行，在分派执行的过程中，开发人员还可以按需调整委托类对象及其功能，这是一套非常灵活有弹性的代理框架。Java动态代理实际上通过反射技术，把代理对象和被代理对象(真实对象)的代理关系建立延迟到程序运行之后，动态创建新的代理类去完成对真实对象的代理操作(可以改变原来真实对象的方法行为)，这一点成为了当前主流的AOP框架和延迟加载功能的基础。本文在查看和编写动态代理相关的代码使用的是JDK11，不过JDK动态代理相关的功能和接口已经相对稳定，不必担心JDK版本升级带来的兼容性问题，但是需要注意由于JDK9引入了模块概念，动态代理的源码也有不少的改动。下文先介绍设计模式中的代理模式，接着会分析JDK动态代理的核心类库、流程和机制，最后分析其底层源码级别实现。</p>
<h2 id="设计模式中的代理模式">设计模式中的代理模式</h2>
<p>代理模式是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-2.png" alt="j-r-d-p-2.png"></p>
<p>代理模式主要包括三种角色：</p>
<ul>
<li>Subject抽象主题角色：一般定义为抽象类或者接口，是作为功能的定义，提供一系列抽象的功能方法。</li>
<li>RealSubject具体(真实)主题角色：一般称为被委托角色或者被代理角色，它是Subject的一个具体实现。</li>
<li>ProxySubject代理主题角色：一般称为委托角色或者代理角色，一般ProxySubject也实现(或者继承)Subject，接收一个具体的Subject实例RealSubject，在RealSubject处理前后做预定义或者后置操作，甚至可以直接忽略RealSubject原来的方法。</li>
</ul>
<p>把上面的类图编写成代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"RealSubject doSomething..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Subject subject;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.subject = subject;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		subject.doSomething();</span><br><span class="line">		doOtherThing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ProxySubject doOtherThing..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		ProxySubject proxySubject = <span class="keyword">new</span> ProxySubject(subject);</span><br><span class="line">		proxySubject.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>Client#main()</code>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RealSubject doSomething...</span><br><span class="line">ProxySubject doOtherThing...</span><br></pre></td></tr></table></figure>
<p>代理模式在日常的场景中也经常碰到，比较常见的一个场景就是游戏代练，套进去上面的代码可以写个比较生动的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"操作Throwable游戏角色打怪升级"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Player player;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyPlayer</span><span class="params">(Player player)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.player = player;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		login();</span><br><span class="line">		<span class="keyword">this</span>.player.playGame();</span><br><span class="line">		logout();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"登录Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"退出Throwable游戏角色"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式有几个比较大的优点：</p>
<ul>
<li>职责清晰：也就是真实主题角色只需要实现具体的逻辑，不需关注代理类的职责，而代理类也只需要处理预处理和后置的逻辑，类的职责分明。</li>
<li>高扩展性：由于职责分明，也就是真实主题角色可以随时修改实现，这样就能通过更新或者替换真实主题的实现并且不改变代理主题角色的情况下改变具体功能。</li>
<li>高灵活性：主要体现在后面提到的动态代理。</li>
</ul>
<h2 id="JDK动态代理的核心API">JDK动态代理的核心API</h2>
<p>JDK动态代理提供外部使用的主要依赖两个类：</p>
<ul>
<li><code>java.lang.reflect.Proxy</code>：可以理解为代理类的工厂类(其实也是父类，见下文)。</li>
<li><code>java.lang.reflect.InvocationHandler</code>：代理实例需要实现的调用处理器接口。</li>
</ul>
<h3 id="Proxy">Proxy</h3>
<p><code>java.lang.reflect.Proxy</code>是JDK动态代理的核心类，它的核心功能是提供静态方法来为一组接口动态地生成代理类并且返回代理实例对象，类似于代理类实例的工厂类。<code>java.lang.reflect.Proxy</code>主要提供四个public静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title">getInvocationHandler</span><span class="params">(Object proxy)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; <span class="title">getProxyClass</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="comment">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>InvocationHandler getInvocationHandler(Object proxy)</code>：通过制定的代理类实例查找它关联的调用处理器实例。</li>
<li><code>Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces)</code>：用于获取关联于指定类装载器和一组接口的动态代理类的类对象，也就是获取<code>$ProxyXXX</code>的类型，此方法在JDK9以后标记为过期，原因是：在命名模块中生成的代理类是封闭的，模块外的代码无法访问这些类(违反模块规则调用了会抛异常)。</li>
<li><code>boolean isProxyClass(Class&lt;?&gt; cl)</code>：用于判断指定类是否是一个动态代理类。</li>
<li><code>Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code>：这个是JDK动态代理最核心的方法，用于为指定类装载器、一组接口及调用处理器生成动态代理类实例，也就是生成<code>$ProxyXXX</code>的实例。此方法需要指定类加载器<code>java.lang.ClassLoader</code>，Proxy静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是在运行时动态生成的而非预存在于任何一个.class文件中。interfaces是Class数组，也就是需要使用InvocationHandler进行代理访问的接口类型数组，这里的h参数就是调用处理器的实例。</li>
</ul>
<h3 id="InvocationHandler">InvocationHandler</h3>
<p><code>java.lang.reflect.InvocationHandler</code>是调用处理器接口，它自定义了一个<code>invoke</code>方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>proxy：Object类型，此参数即是代理类实例，也就是<code>$ProxyXXX</code>的实例。</li>
<li>method：<code>java.lang.reflect.Method</code>类型，被调用的方法的实例。</li>
<li>args：Object[]类型，被调用方法的参数数组。</li>
</ul>
<p>实现<code>java.lang.reflect.InvocationHandler</code>接口，通过实现<code>invoke</code>方法即可添加代理访问的逻辑，在这个逻辑代码块中除了可以调用委托类的方法，还可以织入额外的自定义逻辑，AOP就是这样实现的。</p>
<h2 id="JDK动态代理的流程">JDK动态代理的流程</h2>
<p>JDK动态代理的使用流程如下：</p>
<ul>
<li>1、通过实现<code>java.lang.reflect.InvocationHandler</code>接口创建自定义的调用处理器。</li>
<li>2、通过为<code>java.lang.reflect.Proxy</code>类指定<code>ClassLoader</code>对象和一组interface来创建动态代理类。</li>
<li>3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型。</li>
<li>4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line"><span class="comment">// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy为包括Interface接口在内的一组接口动态创建代理类的类对象</span></span><br><span class="line">Class clazz = Proxy.getProxyClass(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span>, ... &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过反射从生成的类对象获得构造函数对象</span></span><br><span class="line">Constructor constructor = clazz.getConstructor(<span class="keyword">new</span> Class[] &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;)</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过构造函数对象创建动态代理类实例</span></span><br><span class="line">Interface Proxy = (Interface)constructor.newInstance(<span class="keyword">new</span> Object[] &#123; handler &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的过程比较复杂，可以进行精简。简化后的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl实现了InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Proxy直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> Class[] &#123; Interface<span class="class">.<span class="keyword">class</span> &#125;, <span class="title">handler</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="JDK动态代理的机制">JDK动态代理的机制</h2>
<p>首先是JDK动态代理生成的代理类本身的特点：</p>
<ul>
<li>1、<strong>包(或者JDK9引入的模块)</strong>：如果所代理的接口都是public的，那么它将被定义在包<code>com.sun.proxy</code>；如果所代理的接口中有非public的接口(因为接口不能被定义为protect或private，所以除public之外就是默认的package访问级别，修饰符为default)，那么它将被定义在该接口所在包(假设代理了<code>throwable.club</code>包中的某非public接口A，那么新生成的代理类所在的包就是<code>throwable.club</code>)，值得注意的是，<strong>如果接口数组中存在非public的接口，那么它们必须在同一个包路径下，否则会抛异常</strong>。这样设计的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定义并访问。</li>
<li>2、<strong>类修饰符</strong>：该代理类具有final和public修饰符，<strong>意味着它可以被所有的类访问，但是不能被再度继承</strong>。</li>
<li>3、<strong>类名</strong>：代理类名称格式是<code>$ProxyN</code>，其中N是一个逐一递增的阿拉伯数字，代表<code>java.lang.reflect.Proxy</code>类第N次生成的动态代理类，值得注意的一点是，并不是每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口(包括接口排列的顺序相同)试图重复创建动态代理类，它会从缓存中获取先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率。</li>
<li>4、<strong>类继承关系</strong>：代理类的继承关系图如下：</li>
</ul>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201812/j-r-d-p-1.png" alt="j-r-d-p-1.png"></p>
<p>由图可知，<code>java.lang.reflect.Proxy</code>类是代理类的父类，这个规则适用于所有由<code>java.lang.reflect.Proxy</code>创建的动态代理类。而且该类还实现了其所代理的一组接口，这就是为什么它能够被安全地类型转换到其所代理的某接口的根本原因。</p>
<h3 id="代理类实例的特点">代理类实例的特点</h3>
<p>每个代理类实例都会关联一个调用处理器对象，可以通过<code>java.lang.reflect.Proxy</code>提供的静态方法<code>getInvocationHandler()</code>去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行，此外，值得注意的是，代理类的根类<code>java.lang.Object</code>中有三个方法也同样会被分派到调用处理器的<code>invoke</code>方法执行，它们是<code>hashCode</code>、<code>equals</code>和<code>toString</code>，可能的原因有：</p>
<ul>
<li>一、因为这些方法为public且非final类型，能够被代理类覆盖。</li>
<li>二、因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到委托类执行。当代理的一组接口有重复声明的方法且该方法被调用时，代理类总是从排在最前面的接口中获取方法对象并分派给调用处理器，而无论代理类实例是否正在以该接口(或继承于该接口的某子接口)的形式被外部引用，因为在代理类内部无法区分其当前的被引用类型。</li>
</ul>
<h3 id="被代理的一组接口的特点">被代理的一组接口的特点</h3>
<p>首先，要注意不能有重复的接口，以避免动态代理类代码生成时的编译错误。其次，这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败。再次，需被代理的所有非public的接口必须在同一个包中，否则代理类生成也会失败。最后，接口的数目不能超过65535，这是JVM设定的限制，这一点在代理类生成的时候也做了判断。</p>
<h3 id="异常处理">异常处理</h3>
<p>从调用处理器接口声明的方法中可以看到理论上它能够抛出任何类型的异常，因为所有的异常都继承于Throwable接口，但事实是否如此呢？答案是否定的，原因是我们必须遵守一个继承原则：即子类覆盖父类或实现父接口的方法时，抛出的异常必须在原方法支持的异常列表之内。所以虽然调用处理器理论上讲能够，但实际上往往受限制，除非父接口中的方法支持抛Throwable异常。那么如果在invoke方法中的确产生了接口方法声明中不支持的异常，那将如何呢？放心，Jdk动态代理类已经为我们设计好了解决方法：它将会抛出<code>UndeclaredThrowableException</code> 异常。这个异常是一个<code>RuntimeException</code>类型，所以不会引起编译错误。通过该异常的<code>getCause</code>方法，还可以获得原来那个不受支持的异常对象，以便于错误诊断。</p>
<h2 id="JDK动态代理源码分析">JDK动态代理源码分析</h2>
<p>因为JDK动态代理核心逻辑都在<code>java.lang.reflect.Proxy</code>类中，下面简单分析一下这个类的源码。先看<code>Proxy</code>类中的几个重要的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口组中接口都为为public时候代理类创建的包路径：com.sun.proxy</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROXY_PACKAGE_PREFIX = ReflectUtil.PROXY_PACKAGE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的构造方法参数类型数组，可见代理类的构造参数只有InvocationHandler类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存了所有已经调用过setAccessible(true)的代理类的构造(Constructor)实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Constructor&lt;?&gt;&gt; proxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这里注意到<code>ClassLoaderValue</code>，下文会调用到它的一个很复杂的调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//intf是Class&lt;?&gt;类型</span></span><br><span class="line"><span class="comment">//loader是类加载器实例</span></span><br><span class="line"><span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">    loader,</span><br><span class="line">    (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(ClassLoader cl,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BiFunction&lt;? <span class="keyword">super</span> ClassLoader,? <span class="keyword">super</span> CLV,? extends V&gt; mappingFunction)</span> </span></span><br><span class="line"><span class="function">						<span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>上面的<code>computeIfAbsent</code>中使用了函数式接口和Lambda表达式，如果Lambda表达式玩的比较熟练看起来应该没问题，它的功能可以解读为：通过接口类型和类加载器实例计算通过接口类型和类加载器实例构建<code>ProxyBuilder</code>实例并且调用<code>ProxyBuilder#build()</code>得到的结果，如果结果已经存在则直接返回缓存。其实<code>computeIfAbsent</code>在<code>Map</code>接口中也定义了同样的方法，功能是相似的。</p>
<p>接着看<code>Proxy</code>的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此可以明确一点，既然所有动态代理类都是<code>java.lang.reflect.Proxy</code>的子类，那么它们一定具备一个包含<code>InvocationHandler</code>参数的构造器。接着查看``方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空判断									  </span></span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="comment">// 当前调用类获取</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; caller = System.getSecurityManager() == <span class="keyword">null</span></span><br><span class="line">                                    ? <span class="keyword">null</span></span><br><span class="line">                                    : Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 获取代理类的构造器实例								</span></span><br><span class="line">    Constructor&lt;?&gt; cons = getProxyConstructor(caller, loader, interfaces);</span><br><span class="line">    <span class="comment">// 生成代理实例</span></span><br><span class="line">    <span class="keyword">return</span> newProxyInstance(caller, cons, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看<code>getProxyConstructor</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;?&gt; getProxyConstructor(Class&lt;?&gt; caller,</span><br><span class="line">                                                  ClassLoader loader,</span><br><span class="line">                                                  Class&lt;?&gt;... interfaces)&#123;</span><br><span class="line">    <span class="comment">// 这里需要区分代理接口数组中只有单个接口和多个接口的逻辑				  </span></span><br><span class="line">    <span class="comment">// 而基本的逻辑都是先校验当前调用类的权限，后续获取Constructor实例委托到ProxyBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length == <span class="number">1</span>) &#123;</span><br><span class="line">        Class&lt;?&gt; intf = interfaces[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intf).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 接口克隆</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfsArray = interfaces.clone();</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(caller, loader, intfsArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; intfs = Arrays.asList(intfsArray);</span><br><span class="line">        <span class="keyword">return</span> proxyCache.sub(intfs).computeIfAbsent(</span><br><span class="line">            loader,</span><br><span class="line">            (ld, clv) -&gt; <span class="keyword">new</span> ProxyBuilder(ld, clv.key()).build()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明确，核心的逻辑都交给了<code>Proxy</code>的内部类<code>ProxyBuilder</code>完成，先看<code>ProxyBuilder</code>的静态成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类的简单类名的前置字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成下一个代理类的数字计数器，记住它是静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录了已经生成的代理类-Boolean的映射，已经生成过对应代理类则记录为true</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ClassLoaderValue&lt;Boolean&gt; reverseProxyCache = <span class="keyword">new</span> ClassLoaderValue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单个代理接口的情况，其实也是把接口转换为List</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, Class&lt;?&gt; intf) &#123;</span><br><span class="line">    <span class="keyword">this</span>(loader, Collections.singletonList(intf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个代理接口的情况</span></span><br><span class="line">ProxyBuilder(ClassLoader loader, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    <span class="comment">// 通过JVM参数强制关闭动态代理功能则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isModuleSystemInited()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Proxy is not supported until "</span></span><br><span class="line">                + <span class="string">"module system is fully initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 代理接口数量不能超过65535，也就是最多代理65535个接口</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded: "</span></span><br><span class="line">                + interfaces.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 收集接口数组中所有接口的非静态方法的返回值类型、共享(shared)参数类型和共享(shared)异常类型，注释说是收集代理接口的方法签名</span></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; refTypes = referencedTypes(loader, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保上一步得到的代理接口方法签名的类型都是"可见(其实就是类型都存在)"的，通过遍历调用Class.forName(type.getName(), false, ld)去判断</span></span><br><span class="line">    validateProxyInterfaces(loader, interfaces, refTypes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="comment">// 获取代理类最终生成的模块，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、所有代理接口的修饰符都为public，接口所在模块都能公开访问，则返回unnamed模块</span></span><br><span class="line">    <span class="comment">// 2、如果有任意的代理接口是包私有，则返回该包所在的模块		、</span></span><br><span class="line">    <span class="comment">// 3、所有代理接口的修饰符都为public，有任意至少一个接口所在模块不能公开访问，则返回该不能公开访问的模块，</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = mapToModule(loader, interfaces, refTypes);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getLoader</span><span class="params">(<span class="keyword">module</span>)</span> </span>== loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个构造器处理的逻辑也是相对复杂，主要是因为引入模块管理的概念，接着看<code>ProxyBuilder#build()</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; build() &#123;</span><br><span class="line">    <span class="comment">// 定义代理类，实际上是动态生成代理类字节码和缓存它的类型的过程</span></span><br><span class="line">    Class&lt;?&gt; proxyClass = defineProxyClass(<span class="keyword">module</span>, interfaces);</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 返回代理类的构造</span></span><br><span class="line">        cons = proxyClass.getConstructor(constructorParams);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cons;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后到逻辑最复杂的代理类的生成过程<code>ProxyBuilder#defineProxyClass()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; defineProxyClass(Module m, List&lt;Class&lt;?&gt;&gt; interfaces) &#123;</span><br><span class="line">    String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">    <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">    <span class="comment">// 这里就是定义代理类包路径的逻辑，规则如下：</span></span><br><span class="line">    <span class="comment">// 1、代理接口数组所有接口都是public修饰，则代理类包路径为com.sun.proxy</span></span><br><span class="line">    <span class="comment">// 2、代理接口数组有任意接口是包私有的，则代理类包路径为该私有包的路径			</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">            accessFlags = Modifier.FINAL;  <span class="comment">// non-public, final</span></span><br><span class="line">            String pkg = intf.getPackageName();</span><br><span class="line">            <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                proxyPkg = pkg;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面几个if都是包路径的合法性判断</span></span><br><span class="line">    <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// all proxy interfaces are public</span></span><br><span class="line">        proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + <span class="string">"."</span> + m.getName()</span><br><span class="line">                               : PROXY_PACKAGE_PREFIX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proxyPkg.isEmpty() &amp;&amp; m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Unnamed package cannot be added to "</span> + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m.isNamed()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.getDescriptor().packages().contains(proxyPkg)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(proxyPkg + <span class="string">" not exist in "</span> + m.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数器加1返回新的计数值			</span></span><br><span class="line">    <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">    <span class="comment">// 生成代理类全类名，一个常见的格式是：com.sun.proxy.$Proxy1</span></span><br><span class="line">    String proxyName = proxyPkg.isEmpty()</span><br><span class="line">                            ? proxyClassNamePrefix + num</span><br><span class="line">                            : proxyPkg + <span class="string">"."</span> + proxyClassNamePrefix + num;</span><br><span class="line">    ClassLoader loader = getLoader(m);</span><br><span class="line">    trace(proxyName, m, loader, interfaces);</span><br><span class="line">    <span class="comment">// 动态生成代理类字节码字节数组			</span></span><br><span class="line">    <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces.toArray(EMPTY_CLASS_ARRAY), accessFlags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Unsafe定义代理类-这里是通过字节码定义新的类				</span></span><br><span class="line">        Class&lt;?&gt; pc = UNSAFE.defineClass(proxyName, proxyClassFile,</span><br><span class="line">                                         <span class="number">0</span>, proxyClassFile.length,</span><br><span class="line">                                         loader, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 缓存代理类已经生成过的标记												 </span></span><br><span class="line">        reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">         * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">         * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">         * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">         * exceeded).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这一步为止，代理类的生成过程已经大致分析完毕，<code>ProxyGenerator</code>中涉及到大量字节码操作，这里就不深入分析了。那么回到最前面的方法，得到代理类和它的构造实例，接着就可以生成代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(Class&lt;?&gt; caller, // <span class="keyword">null</span> <span class="keyword">if</span> no SecurityManager</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Constructor&lt;?&gt; cons,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(caller, cons.getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里简单反射调用Constructor#newInstance(h)</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结一下：</p>
<ul>
<li><strong>接口数组中所有接口元素的类修饰符最好一致为public。如果接口数组中存在非default修饰的接口元素，那么接口数组中的所有接口类都要放在同一个包下，并且都要使用default修饰。</strong></li>
<li>很少情况下我们修改接口的修饰符，默认为public，那么所有代理类的包路径都是<code>com.sun.proxy</code>，全类名是:<code>com.sun.proxy.$ProxyN</code>。</li>
<li>代理接口数量不能超过65535。</li>
</ul>
<h2 id="JDK动态代理类的源代码">JDK动态代理类的源代码</h2>
<p>前面已经分析完了代理类的生成过程，这里举个简单的使用例子，并且观察生成的动态代理类的源代码。</p>
<p><strong>使用例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSimple</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 场景类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Simple simple = <span class="keyword">new</span> DefaultSimple();</span><br><span class="line">        Object target = Proxy.newProxyInstance(Main.class.getClassLoader(), new Class[]&#123;Simple.class&#125;, new InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Before say hello..."</span>);</span><br><span class="line">                method.invoke(simple, args);</span><br><span class="line">                System.out.println(<span class="string">"After say hello..."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Simple proxy = (Simple) target;</span><br><span class="line">        proxy.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before say hello...</span><br><span class="line">throwable say hello!</span><br><span class="line">After say hello...</span><br></pre></td></tr></table></figure>
<p>可以看到，我们在被代理类<code>DefaultSimple</code>实例的方法调用前后织入了自定义的逻辑，这就是通过JDK动态代理实现AOP的底层原理。在JDK8中可以直接使用<code>sun.misc.ProxyGenerator</code>去输出代理类的class文件，但是JDK11中这个代理类生成器已经变成<code>java.lang.reflect.ProxyGenerator</code>，并且这个类是包私有的，我们无法使用，但是它提供了<code>jdk.proxy.ProxyGenerator.saveGeneratedFiles</code>这个VM参数让我们可以保存代理类的class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># JVM参数</span><br><span class="line">-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>配置好VM参数后，再次调用mian方法就能看到在项目的顶层包路径下看到对应的类<code>com.sun.proxy.$Proxy0</code>，目前从<code>java.lang.reflect.ProxyGenerator</code>源码看无法控制代理类文件的输出路径，生成的代理类内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Simple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"club.throwable.jdk.sample.reflection.proxy.Simple"</span>).getMethod(<span class="string">"sayHello"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类的代码比较简单，有如下几个特点：</p>
<ul>
<li>1、代理类继承于<code>java.lang.reflect.Proxy</code>，实现了接口数组中的接口元素类，构造函数只有一个<code>InvocationHandler</code>类型的参数。</li>
<li>2、接口中的所有被代理方法包括<code>equals</code>、<code>toString</code>、<code>hashCode</code>都建立了一个对应的Method私有静态实例，在最后面的静态代码块中实例化。</li>
<li>3、所有代理方法都是用public final修饰，也就是代理类中的代理方法是不能覆盖的。</li>
<li>4、所有代理方法都是通过<code>InvocationHandler</code>实例的<code>invoke</code>方法进行调用的，记得第一个参数是代理类实例本身，如果用了在<code>InvocationHandler#invoke()</code>方法实现过程中使用了这个参数有可能造成死循环。</li>
</ul>
<h2 id="小结">小结</h2>
<p>诚然，Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的<strong>单继承机制</strong>注定了这些动态代理类们无法实现对class的动态代理(所以只能代理接口，实际上是基于反射对方法级别的逻辑进行编织)。有很多条理由，可以否定对class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。但是，不完美并不等于不伟大，伟大是一种本质，JDK动态代理就是佐例。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第1部分</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy2/" target="_blank" rel="noopener">Java动态代理机制分析及扩展-第2部分</a></li>
<li>JDK11相关源码</li>
</ul>
<p>(本文完 e-20181208 c-3-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/05/java-reflection-generics/">
      深入分析Java反射(三)-泛型
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月5日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：6.7k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：28分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-05T23:20:21+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月5日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(三)-泛型</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射中一个比较难的问题-泛型。</p>
<h2 id="泛型的简介">泛型的简介</h2>
<p>泛型是在2004年JavaSE 5.0(JDK1.5)版本中添加到Java编程语言中的泛型编程工具。泛型的设计是为了应用在Java的类型系统，<strong>提供&quot;用类型或者方法操作各种类型的对象从而提供编译期的类型安全功能(原文：a type or method to operate on objects of various types while providing compile-time type safety)&quot;</strong>。但是在2016年的一些研究表明，泛型并不是在所有的情况下都能保证编译期的类型安全，例如切面(Aspect)编程的编译期类型安全并没有完全实现。</p>
<p><strong>泛型的一个最大的优点就是：提供编译期的类型安全</strong>。举个很简单的例子，在引入泛型之前，<code>ArrayList</code>内部只维护了一个Object数组引用，这种做法有两个问题：</p>
<ul>
<li>从数组列表获取一个元素的时候必须进行类型的强转。</li>
<li>向数组列表中可以添加任何类型的对象，导致无法得知数组列表中存放了什么类型的元素。</li>
</ul>
<p>引入泛型之后，我们可以通过类型参数明确定义<code>ArrayList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaSE 7以后的版本中构造函数可以省略类型，编译器可以推导出实际类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>下面先列举出Java中泛型的一些事实：</p>
<ul>
<li><strong>Java虚拟机中不存在泛型，只有普通的类和方法，但是字节码中存放着泛型相关的信息</strong>。</li>
<li>所有的类型参数都使用它们的限定类型替换。</li>
<li>桥方法(Bridge Method)由编译器合成，用于保持多态(<strong>Java虚拟机利用方法的参数类型、方法名称和方法返回值类型确定一个方法</strong>)。</li>
<li>为了保持类型的安全性，必要时需要进行类型的强制转换。</li>
</ul>
<h2 id="理解类型擦除">理解类型擦除</h2>
<h3 id="类型擦除是什么">类型擦除是什么</h3>
<p>类型擦除(或者更多时候喜欢称为&quot;<strong>泛型擦除</strong>&quot;)的具体表现是：无论何时定义一个泛型类型，都自动提供一个相应的原始类型(Raw Type，这里的原始类型并不是指int、boolean等基本数据类型)，原始类型的类名称就是带有泛型参数的类删去泛型参数后的类型名称，而原始类型会擦除(Erased)类型变量，并且把它们替换为限定类型(如果没有指定限定类型，则擦除为Object类型)，举个例子<code>Pair&lt;T&gt;</code>带有泛型参数的类型如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first,T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>擦除类型后的<code>Pair&lt;T&gt;</code>的原始类型为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first,Object second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个更复杂的例子，如果泛型参数类型是有上限的，变量会擦除为上限的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> T lower;</span><br><span class="line">	<span class="keyword">private</span> T upper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(T lower, T upper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lower = lower;</span><br><span class="line">		<span class="keyword">this</span>.upper = upper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型擦除后的<code>Interval&lt;T extends Comparable &amp; Serializable&gt;</code>原始类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Comparable lower;</span><br><span class="line">	<span class="keyword">private</span> Comparable upper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(Comparable lower, Comparable upper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.lower = lower;</span><br><span class="line">		<span class="keyword">this</span>.upper = upper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这种多个泛型上限的类型，应该尽量把标识接口上限类型放在边界列表的尾部，这样做可以提高效率。</p>
<h3 id="为什么需要擦除类型">为什么需要擦除类型</h3>
<p>在JDK1.5之前，也就是在泛型出现之前，所有的类型包括基本数据类型(int、byte等)、包装类型、其他自定义的类型等等都可以使用类文件(.class)字节码对应的<code>java.lang.Class</code>描述，也就是<code>java.lang.Class</code>类的一个具体实例对象就可以代表任意一个指定类型的原始类型。这里把泛型出现之前的所有类型暂时称为&quot;历史原始类型&quot;。</p>
<p>在JDK1.5之后，数据类型得到了扩充，出历史原始类型扩充了四种泛型类型：参数化类型(ParameterizedType)、类型变量类型(TypeVariable)、限定符类型(WildcardType)、泛型数组类型(GenericArrayType)。历史原始类型和新扩充的泛型类型都应该统一成各自的字节码文件类型对象，也就应该把泛型类型归并进去<code>java.lang.Class</code>中。但是由于JDK已经迭代了很多版本，泛型并不属于当前Java中的基本成分，如果JVM中引入真正的泛型类型，那么必须涉及到JVM指令集和字节码文件的修改(这个修改肯定不是小的修改，因为JDK当时已经迭代了很多年，而类型是编程语言的十分基础的特性，引入泛型从项目功能迭代角度看可能需要整个JVM项目做回归测试)，这个功能的代价十分巨大，所以Java没有在Java虚拟机层面引入泛型。</p>
<p>Java为了使用泛型，于是使用了类型擦除的机制引入了&quot;泛型的使用&quot;，并没有真正意义上引入和实现泛型。Java中的泛型实现的是编译期的类型安全，也就是泛型的类型安全检查是在编译期由编译器(常见的是javac)实现的，这样就能够确保数据基于类型上的安全性并且避免了强制类型转换的麻烦(实际上，强制类型转换是由编译器完成了，只是不需要人为去完成而已)。<strong>一旦编译完成，所有的泛型类型都会被擦除，如果没有指定上限，就会擦除为Object类型，否则擦除为上限类型。</strong></p>
<p>既然Java虚拟机中不存在泛型，那么为什么可以从JDK中的一些类库获取泛型信息？这是因为类文件(.class)或者说字节码文件本身存储了泛型的信息，相关类库(可以是JDK的类库，也可以是第三方的类库)读取泛型信息的时候可以从字节码文件中提取，例如比较常用的字节码操作类库ASM就可以读取字节码中的信息甚至改造字节码动态生成类。例如前面提到的<code>Interval&lt;T extends Comparable &amp; Serializable&gt;</code>类，使用<code>javap -c -v</code>命令查看其反编译得到的字节码信息，可以看到其签名如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signature: #22                          // &lt;T::Ljava/lang/Comparable;:Ljava/io/Serializable;&gt;Ljava/lang/Object;Ljava/io/Serializable;</span><br></pre></td></tr></table></figure>
<p>这里的签名信息实际上是保存在常量池中的，关于字节码文件的解析将来会出一个系列文章详细展开。</p>
<h2 id="Type体系">Type体系</h2>
<p>前文提到了在JDK1.5中引入了四种新的泛型类型<code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code>、<code>java.lang.reflect.GenericArrayType</code>，包括原来存在的<code>java.lang.Class</code>，一共存在五种类型。为了程序的扩展性，引入了<code>java.lang.reflect.Type</code>类作为这五种类型的公共父接口，这样子就可以使用<code>java.lang.reflect.Type</code>类型参数去接收以上五种子类型的实参或者返回值，由此从逻辑上统一了泛型相关的类型和原始存在的<code>java.lang.Class</code>描述的类型。Type体系如下：</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-g-1.png" alt="j-r-g-1.png"></p>
<p>注意：</p>
<ul>
<li>ParameterizedType、TypeVariable、WildcardType、GenericArrayType都是接口，它们位于<code>java.lang.reflect</code>包中。</li>
<li>ParameterizedTypeImpl、TypeVariableImpl、WildcardTypeImpl、GenericArrayTypeImpl是四种泛型类型的实现，位于<code>sun.reflect.generics.reflectiveObjects</code>包中。</li>
</ul>
<p>Type体系虽然看似很美好解决了泛型相关的类型和原始存在的<code>java.lang.Class</code>描述的类型的统一问题，但是引入了新的问题：如果一个方法返回值为<code>java.lang.reflect.Type</code>类型，或者一个方法的入参类型为<code>java.lang.reflect.Type</code>类型，这两种情况下，可能需要对<code>java.lang.reflect.Type</code>类型的对象做子类型判断，因为它的子类型有可能是上面提到的五种类型中的其中一种，这一点提高了编码的复杂性。</p>
<h3 id="ParameterizedType">ParameterizedType</h3>
<p>ParameterizedType，parameterized type，也就是参数化类型，注释里面说到<code>ParameterizedType</code>表示一个参数化类型，例如<code>Collection&lt;String&gt;</code>，实际上只要带有参数化(泛型)标签<code>&lt;ClassName&gt;</code>的参数或者属性，都属于ParameterizedType。例如下面的类型都是ParameterizedType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set;</span><br><span class="line">Class&lt;Integer&gt; clazz;</span><br><span class="line">MyClass&lt;String&gt; myClass;</span><br><span class="line">List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而像下面的忽略泛型参数或者基本数据类型和基本数据类型的包装类都不是ParameterizedType：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"throwbale"</span>;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">Set set;</span><br><span class="line">List list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">(<span class="keyword">int</span> age,String name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java.lang.reflect.ParameterizedType</code>接口继承自<code>java.lang.reflect.Type</code>接口，实现类是<code>sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</code>，其实，必要的时候，我们也可以自行实现ParameterizedType，像一些Json解析工具都是自行实现ParameterizedType的。ParameterizedType接口的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterizedType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getRawType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getOwnerType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getActualTypeArguments()：返回这个ParameterizedType类型的参数的实际类型Type数组，Type数组里面的元素有可能是Class、ParameterizedType、TypeVariable、GenericArrayType或者WildcardType之一。值得注意的是，无论泛型符号<code>&lt;&gt;</code>中有几层<code>&lt;&gt;</code>嵌套，这个方法仅仅脱去最外层的<code>&lt;&gt;</code>，之后剩下的内容就作为这个方法的返回值。</li>
<li>Type getRawType()：返回的是当前这个ParameterizedType的原始类型，从ParameterizedTypeImpl的源码看来，原始类型rawType一定是一个<code>Class&lt;?&gt;</code>实例。举个例子，<code>List&lt;Person&gt;</code>通过<code>getRawType()</code>获取到的Type实例实际上是<code>Class&lt;?&gt;</code>实例，和List.class等价。</li>
<li>Type getOwnerType()：获取原始类型所属的类型，从ParameterizedTypeImpl的源码看来，就是调用了原始类型rawType的<code>getDeclaringClass()</code>方法，而像rawType为<code>List&lt;T&gt;</code>、<code>Map&lt;T&gt;</code>这些类型的getOwnerType()实际上就是调用List.class.getDeclaringClass()，Map.class.getDeclaringClass()，返回值都是null。</li>
</ul>
<p>举个关于ParameterizedType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main13</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Sub&gt; subClass = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Type genericSuperclass = subClass.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (genericSuperclass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">            <span class="comment">//获取父类泛型类型数组</span></span><br><span class="line">            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type type : actualTypeArguments) &#123;</span><br><span class="line">                System.out.println(type + <span class="string">" is ParameterizedType -&gt; "</span> + (type <span class="keyword">instanceof</span> ParameterizedType));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Field field = subClass.getDeclaredField(<span class="string">"clazz"</span>);</span><br><span class="line">        Type genericType = field.getGenericType();</span><br><span class="line">        System.out.println(genericType + <span class="string">" is ParameterizedType -&gt; "</span> + (genericType <span class="keyword">instanceof</span> ParameterizedType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">T</span>, <span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span>&lt;<span class="title">String</span>, <span class="title">List</span>&lt;<span class="title">Person</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span> <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">false</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">util</span>.<span class="title">List</span>&lt;<span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main13</span>$<span class="title">Person</span>&gt; <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">true</span></span></span><br><span class="line"><span class="class"><span class="title">java</span>.<span class="title">lang</span>.<span class="title">Class</span>&lt;?&gt; <span class="title">is</span> <span class="title">ParameterizedType</span> -&gt; <span class="title">true</span></span></span><br></pre></td></tr></table></figure>
<h3 id="TypeVariable">TypeVariable</h3>
<p>TypeVariable，type variable，也就是类型变量，它是各种类型变量的公共父接口，它主要用来表示带有上界的泛型参数的信息，它和ParameterizedType不同的地方是，ParameterizedType表示的参数的最外层一定是已知具体类型的(如<code>List&lt;String&gt;</code>)，而TypeVariable面向的是K、V、E等这些泛型参数字面量的表示。常见的TypeVariable的表示形式是<code>&lt;T extends KnownType-1 &amp; KnownType-2&gt;</code>。TypeVariable接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获得泛型的上限，若未明确声明上边界则默认为Object</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    <span class="comment">//获取声明该类型变量实体(即获得类、方法或构造器名)</span></span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得名称，即K、V、E之类名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得注解类型的上限，若未明确声明上边界则默认为长度为0的数组</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getBounds()：获得该类型变量的上限(上边界)，若无显式定义(extends)，默认为Object，类型变量的上限可能不止一个，因为可以用&amp;符号限定多个（这其中有且只能有一个为类或抽象类，且必须放在extends后的第一个，即若有多个上边界，则第一个&amp;之后的必为接口）。</li>
<li>D getGenericDeclaration：获得声明(定义)这个类型变量的类型及名称，会使用泛型的参数字面量表示，如<code>public void club.throwable.Main.query(java.util.List&lt;club.throwable.Person&gt;)</code>。</li>
<li>String getName()：获取泛型参数的字面量名称，即K、V、E之类名称。</li>
<li>AnnotatedType[] getAnnotatedBounds()：Jdk1.8新增的方法，用于获得注解类型的上限，若未明确声明上边界则默认为长度为0的数组。</li>
</ul>
<p>举个关于TypeVariable的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main14</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; subClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        TypeVariable&lt;Class&lt;Supper&gt;&gt;[] typeParameters = subClass.getTypeParameters();</span><br><span class="line">        <span class="keyword">for</span> (TypeVariable&lt;Class&lt;Supper&gt;&gt; typeVariable : typeParameters) &#123;</span><br><span class="line">            System.out.println(<span class="string">"getBounds --&gt; "</span> + Arrays.toString(typeVariable.getBounds()));</span><br><span class="line">            System.out.println(<span class="string">"getGenericDeclaration  --&gt; "</span> + typeVariable.getGenericDeclaration());</span><br><span class="line">            System.out.println(<span class="string">"getName --&gt; "</span> + typeVariable.getName());</span><br><span class="line">            AnnotatedType[] annotatedBounds = typeVariable.getAnnotatedBounds();</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"getAnnotatedBounds --&gt; "</span>);</span><br><span class="line">            <span class="keyword">for</span> (AnnotatedType annotatedType : annotatedBounds) &#123;</span><br><span class="line">                java.lang.annotation.Annotation[] annotations = annotatedType.getAnnotations();</span><br><span class="line">                <span class="keyword">for</span> (java.lang.annotation.Annotation annotation : annotations) &#123;</span><br><span class="line">                    stringBuilder.append(annotation).append(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(stringBuilder.toString());</span><br><span class="line">            System.out.println(<span class="string">"==================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> Annotation &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">InterFace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Person</span> &amp; <span class="title">InterFace</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getBounds --&gt; [class org.throwable.inherited.Main14$Person, interface org.throwable.inherited.Main14$InterFace]</span><br><span class="line">getGenericDeclaration  --&gt; <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main14</span>$<span class="title">Supper</span></span></span><br><span class="line"><span class="class"><span class="title">getName</span> --&gt; <span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">getAnnotatedBounds</span> --&gt;</span></span><br><span class="line"><span class="class"></span>===================</span><br><span class="line">getBounds --&gt; [interface org.throwable.inherited.Main14$Annotation]</span><br><span class="line">getGenericDeclaration  --&gt; <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">throwable</span>.<span class="title">inherited</span>.<span class="title">Main14</span>$<span class="title">Supper</span></span></span><br><span class="line"><span class="class"><span class="title">getName</span> --&gt; <span class="title">E</span></span></span><br><span class="line"><span class="class"><span class="title">getAnnotatedBounds</span> --&gt;</span></span><br><span class="line"><span class="class"></span>===================</span><br></pre></td></tr></table></figure>
<h3 id="WildcardType">WildcardType</h3>
<p>WildcardType用于表示通配符(?)类型的表达式的泛型参数，例如<code>&lt;? extends Number&gt;</code>等。根据WildcardType注释提示：现阶段通配符表达式仅仅接受一个上边界或者下边界，这个和定义类型变量时候可以指定多个上边界是不一样。但是为了保持扩展性，这里返回值类型写成了数组形式。实际上现在返回的数组的大小就是1。WildcardType接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WildcardType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Type[] getUpperBounds();</span><br><span class="line"></span><br><span class="line">    Type[] getLowerBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type[] getUpperBounds()：获取泛型通配符的上限类型Type数组，实际上目前该数组只有一个元素，也就是说只能有一个上限类型。</li>
<li>Type[] getLowerBounds()：获取泛型通配符的下限类型Type数组，实际上目前该数组只有一个元素，也就是说只能有一个下限类型。</li>
</ul>
<p>举个关于WildcardType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main16</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Main16&gt; clazz = Main16<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"print"</span>.equals(method.getName())) &#123;</span><br><span class="line">                Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (Type type : genericParameterTypes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                        ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">                        <span class="keyword">for</span> (Type actualType : actualTypeArguments) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (actualType <span class="keyword">instanceof</span> WildcardType) &#123;</span><br><span class="line">                                WildcardType wildcardType = (WildcardType) actualType;</span><br><span class="line">                                System.out.println(<span class="string">"WildcardType --&gt; "</span> + wildcardType + <span class="string">" getUpperBounds--&gt; "</span></span><br><span class="line">                                        + Arrays.toString(wildcardType.getUpperBounds()) + <span class="string">" getLowerBounds--&gt; "</span> + Arrays.toString(wildcardType.getLowerBounds()));</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Not WildcardType --&gt; "</span> + actualType);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;? extends Number&gt; list, Set&lt;? <span class="keyword">super</span> Person&gt; persons)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WildcardType --&gt; ? extends java.lang.Number getUpperBounds--&gt; [class java.lang.Number] getLowerBounds--&gt; []</span><br><span class="line">WildcardType --&gt; ? super org.throwable.inherited.Main16$Person getUpperBounds--&gt; [class java.lang.Object] getLowerBounds--&gt; [interface org.throwable.inherited.Main16$Person]</span><br></pre></td></tr></table></figure>
<p>这里注意的是<code>List&lt;? extends Number&gt; list</code>这个参数整体来看是ParameterizedType类型，剥掉第一次List之后的<code>? extends Number</code>是WildcardType类型。</p>
<h3 id="GenericArrayType">GenericArrayType</h3>
<p>GenericArrayType，generic array type，也就是泛型数组，也就是元素类型为泛型类型的数组实现了该接口。它要求元素的类型是ParameterizedType或TypeVariable(实际中发现元素是GenericArrayType也是允许的)。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] listArray; <span class="comment">//是GenericArrayType,元素是List&lt;String&gt;类型，也就是ParameterizedType类型</span></span><br><span class="line">T[] tArray; <span class="comment">//是GenericArrayType,元素是T类型，也就是TypeVariable类型</span></span><br><span class="line"></span><br><span class="line">Person[] persons; <span class="comment">//不是GenericArrayType</span></span><br><span class="line">List&lt;String&gt; strings; <span class="comment">//不是GenericArrayType</span></span><br></pre></td></tr></table></figure>
<p>GenericArrayType接口的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericArrayType</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Type <span class="title">getGenericComponentType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type getGenericComponentType()：获取泛型数组中元素的类型。注意无论从左向右有几个<code>[]</code>并列，这个方法仅仅脱去最右边的<code>[]</code>之后剩下的内容就作为这个方法的返回值。</li>
</ul>
<p>举个关于GenericArrayType的简单使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main15</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Method[] methods = Main15<span class="class">.<span class="keyword">class</span>.<span class="title">getMethods</span>()</span>;</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"method"</span>.equals(method.getName())) &#123;</span><br><span class="line">                Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">                <span class="keyword">for</span> (Type type : genericParameterTypes) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> GenericArrayType) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"GenericArrayType --&gt; "</span> + type + <span class="string">" getGenericComponentType --&gt; "</span></span><br><span class="line">                                + ((GenericArrayType) type).getGenericComponentType());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Not GenericArrayType --&gt; "</span> + type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String[] strings, List&lt;String&gt; ls, List&lt;String&gt;[] lsa, T[] ts, List&lt;T&gt;[] tla, T[][] tts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Not GenericArrayType --&gt; class [Ljava.lang.String;</span><br><span class="line">Not GenericArrayType --&gt; java.util.List&lt;java.lang.String&gt;</span><br><span class="line">GenericArrayType --&gt; java.util.List&lt;java.lang.String&gt;[] getGenericComponentType --&gt; java.util.List&lt;java.lang.String&gt;</span><br><span class="line">GenericArrayType --&gt; T[] getGenericComponentType --&gt; T</span><br><span class="line">GenericArrayType --&gt; java.util.List&lt;T&gt;[] getGenericComponentType --&gt; java.util.List&lt;T&gt;</span><br><span class="line">GenericArrayType --&gt; T[][] getGenericComponentType --&gt; T[]</span><br></pre></td></tr></table></figure>
<p>这里分析一下：</p>
<ul>
<li><code>String[] strings</code>：数组是Class类型。</li>
<li><code>List&lt;String&gt; ls</code>：列表是ParameterizedType类型。</li>
<li><code>List&lt;String&gt;[] lsa</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是<code>java.util.List&lt;java.lang.String&gt;</code>，也就是数组元素是ParameterizedType类型。</li>
<li><code>T[] ts</code>：s数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是T，也就是数组元素是TypeVariable类型。</li>
<li><code>List&lt;T&gt;[] tla</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型是<code>java.util.List&lt;T&gt;</code>，也就是数组元素是ParameterizedType类型。</li>
<li><code>T[][] tts</code>：数组是GenericArrayType类型，调用getGenericComponentType后返回的类型T[]，也就是数组元素是GenericArrayType类型。</li>
</ul>
<h2 id="泛型的约束">泛型的约束</h2>
<p>使用Java泛型的时候需要考虑一些限制，这些限制大多数是由泛型类型擦除引起的。</p>
<ul>
<li>1、不能用基本类型实例化类型参数，也就是8种基本类型不能作为泛型参数，例如<code>Pair&lt;int&gt;</code>是非法的，会导致编译错误，而<code>Pair&lt;Integer&gt;</code>是合法的。</li>
<li>2、运行时的类型查询只能适用于原始类型(非参数化类型)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的两种做法是错误的</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;) <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;T&gt;)  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair)  <span class="comment">//Right</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3、不能创建参数化类型的数组，例如<code>Pair&lt;String&gt;[] arr = new Pair&lt;String&gt;[10]</code>是非法的。</li>
<li>4、不能实例化类型变量或者类型变量数组，例如<code>T t = new T()</code>或者<code>T[] arr = new T[10]</code>都是非法的。</li>
<li>5、Varargs警告，这是因为第4点原因导致的，一般会发生在泛型类型变量作为可变参数的情况，例如<code>public static &lt;T&gt; addAll(Collection&lt;T&gt; con,T ... ts)</code>，第二个参数实际上就是泛型类型变量数组，但是这种情况是合法的，不过会受到编译器的警告，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解或者<code>@SafeVarargs</code>注解标注该方法以消除警告。</li>
<li>6、不能在静态域或者方法中引用类型变量，例如<code>private static T singleInstance;</code>这样是非法的。</li>
<li>7、不能抛出或者抛出或者捕获泛型类型变量，但是如果在异常规范中使用泛型类型变量则是允许的，举两个例子仔细品味一下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(T t)&#123;  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">catch</span>(Throwable e)&#123;  </span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8、通过使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>注解可以消除Java类型系统的部分基本限制，一般使用在强制转换原始类型为泛型类型(只是在编译层面告知编译器)的情况，如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加此注解会收到编译器的警告</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> (T) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实还有泛型的继承规则和通配符规则(可以看下前面介绍的Type的子类型)等等，这里不详细展开。</p>
<h2 id="再议泛型数组的问题">再议泛型数组的问题</h2>
<p>在Java泛型约束中，无法实例化参数化类型数组，例如<code>Pair&lt;Integer&gt;[] table = new Pair&lt;Integer&gt;[10];</code>是非法的。根本原因在于泛型类型的擦除和数组会记录元素类型的特性。举个例子，假设可以实例化参数化类型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>上面的参数化类型数组在泛型擦除之后，数组实例table的类型为<code>Pair[]</code>，数组元素类型为<code>Pair</code>，可以强转为<code>Object[]</code>类型数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objArray = table;</span><br></pre></td></tr></table></figure>
<p>基于泛型擦除，数组objArray可以任意赋值<code>Pair&lt;AnyType&gt;</code>的泛型化实例，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objArray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Integer&gt;();</span><br><span class="line">objArray[<span class="number">1</span>] = <span class="keyword">new</span> Pair&lt;Long&gt;();</span><br><span class="line">objArray[<span class="number">2</span>] = <span class="keyword">new</span> Pair&lt;String&gt;();</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><strong>这样子能够通过数组存储元素的检查，后续操作数组元素随时会出现ClassCastException。基于以上的原因，Java从编译层面直接拒绝创建参数化类型数组</strong>。</p>
<p>另外，类型变量数组的实例化也是非法的，如<code>T[] tt = new T[10];</code>，这是因为类型变量仅仅是编译期的字面量，其实和Java的类型体系是不相关的。</p>
<p>但是要注意一点：<strong>参数化类型数组和类型变量数组可以作为方法入参变量或者类的成员变量</strong>。例如下面的做法是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Pair&lt;T&gt;[] attr;</span><br><span class="line">	<span class="keyword">private</span> T[] ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Pair&lt;T&gt; pair)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T[] ts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一点，可以查看前一篇文章，其实<strong>可以使用反射创建泛型数组</strong>。</p>
<h2 id="无限定通配符">无限定通配符</h2>
<p>泛型中支持无限定通配符<code>&lt;?&gt;</code>，使用无限定通配符类型的实例有以下限制：</p>
<ul>
<li>所有的Getter方法只能返回Object类型的值。</li>
<li>所有的Setter方法只能赋值null，其他类型的值的设置都是非法的。</li>
</ul>
<p>无限定通配符类型可以看做原始类型的一个影子类型，它屏蔽了除了null之外的设值操作，所有获取值的方法只能返回Object类型结果，这种特性使得通过无限定通配符类型进行一些简单的操作变得十分方便，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasNulls</span><span class="params">(Pair&lt;?&gt; p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.getFirst() == <span class="keyword">null</span> || p.getSecond() == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果反射用得比较熟的话，<code>java.lang.Class</code>也有类似的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = ...;</span><br><span class="line">Object instance = <span class="class"><span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="桥方法-Bridge-Method">桥方法(Bridge Method)</h2>
<p>先说明一下什么是桥方法，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中一个子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Supper</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类<code>Supper&lt;T&gt;</code>在泛型擦除后原始类型是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(Object t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类<code>Sub</code>虽然实现了父类<code>Supper</code>，但是它只实现了<code>void method(Integer value)</code>而没有实现父类中的<code>void method(Object t)</code>，这个时候，编译期编译器会为子类<code>Sub</code>创建此方法，也就是子类<code>Sub</code>会变成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">implements</span> <span class="title">Supper</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.method((Integer) value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你直接这样编写一个子类<code>Sub</code>是会编译报错，而上面这里编译器生成的<code>void method(Object value)</code>方法就是桥方法。可以用反射验证一下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Method[] declaredMethods = Sub<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredMethods</span>()</span>;</span><br><span class="line">	List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Method method : declaredMethods) &#123;</span><br><span class="line">		<span class="keyword">if</span> (method.getName().equals(<span class="string">"method"</span>)) &#123;</span><br><span class="line">			methods.add(method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">		System.out.println(String.format(<span class="string">"name=%s,paramTypes=%s,isBridge=%s"</span>, method.getName(),</span><br><span class="line">		Arrays.toString(method.getParameterTypes()), method.isBridge()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">name=method,paramTypes=[class java.lang.Integer],isBridge=false</span><br><span class="line">name=method,paramTypes=[class java.lang.Object],isBridge=true</span><br></pre></td></tr></table></figure>
<p>桥方法的定义比较模糊，因此这里只考虑它出现的情况，不做盲目的定义。不单只是子类实现带有泛型参数的父类会产生桥方法，还有一种比较常见的情况是在方法覆盖的时候指定一个更加&quot;严格的&quot;返回值类型的时候，也会产生桥方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Employee implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里实际上，Employee覆盖了Object的clone()方法，因此实际上编译后Employee如下</span></span><br><span class="line"><span class="keyword">public</span> Employee implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是桥方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为：</p>
<ul>
<li>编译的时候Java的方法签名是方法名称加上方法参数类型列表，也就是方法名和参数类型列表确定一个方法的签名(这样就可以很好理解方法重载，还有Java中的参数都是形参，所以参数名称没有实质意义，只有参数类型才是有意义的)。</li>
<li>Java虚拟机定义一个方法的签名是由方法名称、方法返回值类型和方法参数类型列表组成，所以JVM认为返回值类型不同，而方法名称和参数类型列表一致的方法是不相同的方法。</li>
</ul>
<p>仔细看，其实两种情况都是由于继承才导致桥方法出现。</p>
<h2 id="JDK中操作泛型的API">JDK中操作泛型的API</h2>
<p>这里列举一下JDK中笔者所知的操作泛型的相关API(可以会有遗漏)，这些API主要和反射操作相关：</p>
<p><strong><code>java.lang.Class</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericInterfaces()</td>
<td style="text-align:center">返回类实例的接口的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericSuperclass()</td>
<td style="text-align:center">返回类实例的父类的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Constructor</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">返回构造器的异常的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回构造器的方法参数的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Method</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">返回方法的异常的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回方法参数的泛型类型</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericReturnType()</td>
<td style="text-align:center">返回方法返回值的泛型类型</td>
</tr>
</tbody>
</table>
<p><strong><code>java.lang.reflect.Field</code>中的相关方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Type getGenericType()</td>
<td style="text-align:center">返回属性的泛型类型</td>
</tr>
</tbody>
</table>
<p>如果在使用上面的方法得到的返回值和期望的返回值不相同，请加深对泛型类型擦除的认识。</p>
<h2 id="小结">小结</h2>
<p>参考资料：</p>
<p>个人认为，泛型其实是JDK迭代过程中妥协和兼容历史的产物，它是一种没有实现的泛型，当然，提供编译期类型安全这一点可以让开发者避免类型转换出现人为错误，也就是说：Java中的泛型使得程序或者代码的可读性和安全性提高，这是它的最大优势。</p>
<ul>
<li>《Java核心技术卷I-基础知识》</li>
<li><a href="https://en.wikipedia.org/wiki/Generics_in_Java" target="_blank" rel="noopener">维基百科-Generics in Java</a></li>
</ul>
<p>(本文完 e-20181204-c-3d r-20181205)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/02/java-reflection-array-enum/">
      深入分析Java反射(二)-数组和枚举
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月2日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：2.4k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：10分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-04T23:42:12+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月4日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(二)-数组和枚举</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射中可能用到的两个比较特殊的类型，数组和枚举，分别对应<code>java.lang.reflect.Array</code>和<code>java.lang.Enum</code>，后者其实并不是反射类库包中的类，但是反射的基础类库里面有使用枚举类型的方法。</p>
<h2 id="数组类型">数组类型</h2>
<p>数组是一种包含固定数量的相同类型组件(Component)的引用类型对象，也就是说数组的长度是不可变，它的每个元素都是相同类型的。创建数组实例需要定义数组的长度和组件的类型。<strong>数组是由Java虚拟机实现(这一点很重要，这就是为什么JDK类库中没有数组对应的类型的原因，array也不是Java中的保留关键字，操作数组的底层方法都是native方法)</strong>，数组类型只有继承自<code>java.lang.Object</code>的方法，数组的<code>length</code>方法实际上并不属于数组类型的一部分，数组的<code>length</code>方法其实最终调用的是<code>java.lang.reflect.Array#getLength()</code>，注意到这个方法是native方法。<code>java.lang.reflect.Array</code>是基于反射操作数组的核心类。</p>
<p>使用非反射方式创建数组实例的过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fully_qualified_class_name[] variable_name  = &#123;val1，val2，val3，...&#125;;</span><br><span class="line"></span><br><span class="line">fully_qualified_class_name[] variable_name = <span class="keyword">new</span> fully_qualified_class_name[$&#123;fix_length&#125;];</span><br><span class="line"></span><br><span class="line">例如：<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>使用反射方式就是使用<code>java.lang.reflect.Array</code>中的相关方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = Class.forName(cName);</span><br><span class="line">Object o = Array.newInstance(c, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    String v = cVals[i];</span><br><span class="line">    Constructor ctor = c.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Object val = ctor.newInstance(v);</span><br><span class="line">    Array.set(o, i, val);</span><br><span class="line">&#125;</span><br><span class="line">Object[] oo = (Object[]) o;</span><br></pre></td></tr></table></figure>
<p>下面列举一下<code>java.lang.reflect.Array</code>中的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static Object newInstance(Class&lt;?&gt; componentType, int length)</td>
<td style="text-align:center">指定组件类型和数组固定长度创建一维数组</td>
</tr>
<tr>
<td style="text-align:center">static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)</td>
<td style="text-align:center">指定组件类型和多个固定长度创建多维数组，维度的最大值为255</td>
</tr>
<tr>
<td style="text-align:center">static native int getLength(Object array)</td>
<td style="text-align:center">获取数组长度</td>
</tr>
<tr>
<td style="text-align:center">static native Object get(Object array, int index)</td>
<td style="text-align:center">通过下标访问数组元素</td>
</tr>
<tr>
<td style="text-align:center">static native void set(Object array, int index, Object value)</td>
<td style="text-align:center">通过下标设置数组元素</td>
</tr>
</tbody>
</table>
<p>这里省略了一部分对于<code>Int</code>、<code>Boolean</code>等原始类型的Setter和Getter方法。</p>
<p>在<code>java.lang.Class</code>和数组相关的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">native boolean isArray()</td>
<td style="text-align:center">判断类型是否数组类型</td>
</tr>
<tr>
<td style="text-align:center">Class&lt;?&gt; getComponentType()</td>
<td style="text-align:center">如果是数组类型则返回其组件类型，否则返回null</td>
</tr>
</tbody>
</table>
<p>这里举个例子加深下印象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayCreationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这个是我们创建的最终目标数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String R = <span class="string">"java.math.BigInteger[] bi = &#123;123,234,345&#125;"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] S = <span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>, <span class="string">"234"</span>, <span class="string">"345"</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;BigInteger&gt; componentType = BigInteger<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Object arrayObject = Array.newInstance(componentType, <span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length; i++) &#123;</span><br><span class="line">			String each = S[i];</span><br><span class="line">			Constructor&lt;BigInteger&gt; constructor = componentType.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			BigInteger value = constructor.newInstance(each);</span><br><span class="line">			Array.set(arrayObject, i, value);</span><br><span class="line">		&#125;</span><br><span class="line">		Object[] result = (Object[]) arrayObject;</span><br><span class="line">		System.out.println(String.format(<span class="string">"%s[] = %s"</span>, componentType, Arrays.toString(result)));</span><br><span class="line">		<span class="keyword">int</span> length = Array.getLength(arrayObject);</span><br><span class="line">		System.out.println(<span class="string">"Length = "</span> + length);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			System.out.println(String.format(<span class="string">"index = %d,value = %s"</span>, i, Array.get(arrayObject, i)));</span><br><span class="line">		&#125;</span><br><span class="line">		Class&lt;?&gt; arrayObjectClass = arrayObject.getClass();</span><br><span class="line">		System.out.println(<span class="string">"Is array type:"</span> + arrayObjectClass.isArray());</span><br><span class="line">		System.out.println(<span class="string">"Component type:"</span> + arrayObjectClass.getComponentType());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class java.math.BigInteger[] = [123, 234, 345]</span><br><span class="line">Length = <span class="number">3</span></span><br><span class="line">index = <span class="number">0</span>,value = <span class="number">123</span></span><br><span class="line">index = <span class="number">1</span>,value = <span class="number">234</span></span><br><span class="line">index = <span class="number">2</span>,value = <span class="number">345</span></span><br><span class="line">Is array type:<span class="keyword">true</span></span><br><span class="line">Component type:<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">math</span>.<span class="title">BigInteger</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>java.lang.reflect.Array</code>中的Setter和Getter方法如果越界操作数组元素，会抛出<code>ArrayIndexOutOfBoundsException</code>，通过Setter设置和数组初始化时候的组件类型不一致的元素会抛出<code>IllegalArgumentException</code>。</p>
<h3 id="细议数组类型">细议数组类型</h3>
<p>前面说到了数组类型的一些基础特性，这里补充一些比较高级的使用方法。</p>
<p><strong>创建特定元素类型的数组：</strong></p>
<p>因为Java泛型擦除的问题，实际上我们使用<code>Array#newInstance</code>方法只能得到一个Object类型的结果实例，其实这个结果实例的类型就是<code>ComponentType[]</code>，这里只是返回了它的父类(Object)类型实例，因此我们可以直接强转，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = (String[]) Array.newInstance(String<span class="class">.<span class="keyword">class</span>, 3)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>获取数组类型：</strong></p>
<p>在非反射方式下，我们可以通过<code>数组实例.class</code>通过class字面量直接获取数组类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class stringArrayClass = String[]<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure>
<p>反射条件下，可以通过<code>Class.forName()</code>获取数组类型，但是调用此方法的时候有个限制，类名必须使用JVM可以识别的签名形式，就是<code>[L${ComponentType};</code>，注意<code>Class.forName()</code>无法获取原始类型(如int、boolean)的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能漏了左边的[L和右边的;</span></span><br><span class="line">Class stringArrayClass = Class.forName(<span class="string">"[Ljava.lang.String;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这样做会抛出ClassNotFoundException</span></span><br><span class="line">Class intClass1 = Class.forName(<span class="string">"I"</span>);</span><br><span class="line">Class intClass2 = Class.forName(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>获取数组元素(组件)类型：</strong></p>
<p>目前获取数组组件类型只能通过数组类型实例去调用<code>Class#getComponentType()</code>。</p>
<h2 id="枚举类型">枚举类型</h2>
<p>枚举是一种语言结构(Language Construct)，用于定义可以使用一组固定的名值对表示的类型安全的枚举(原文是：An enum is a language construct that is used to define type-safe enumerations which can be used when a fixed set of named values is desired)。所有枚举都继承自<code>java.lang.Enum</code>。枚举可以包含一个或者多个枚举常量，这些枚举常量都是该枚举的实例。枚举的声明其实和一个普通的Class的声明相似，因为它可以包含字段、方法和构造函数之类的成员。</p>
<p>因为枚举就是普通的Java类，因此反射相关类库中并没有添加一个<code>java.lang.reflect.Enum</code>类型，反射中的API和枚举相关的有：</p>
<ul>
<li><code>boolean java.lang.Class#isEnum()</code>：判断类型是否枚举类型。</li>
<li><code>T[] java.lang.Class#getEnumConstants()</code>：获取类型中所有的枚举常量。</li>
<li><code>boolean java.lang.reflect.Field#isEnumConstant()</code>：判断属性是否枚举类型。</li>
</ul>
<p>如果实例中的成员属性为枚举，那么枚举的反射操作实际上就是<code>java.lang.reflect.Field</code>的相关操作。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">enum</span> Color &#123;</span><br><span class="line">		RED, BLACK, BLUE</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Color color = Color.BLACK;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;Color&gt; colorClass = Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		System.out.println(<span class="string">"Color class is enum:"</span> + colorClass.isEnum());</span><br><span class="line">		System.out.println(<span class="string">"Color values:"</span> + Arrays.toString(colorClass.getEnumConstants()));</span><br><span class="line">		ColorHolder colorHolder = <span class="keyword">new</span> ColorHolder();</span><br><span class="line">		Class&lt;ColorHolder&gt; holderClass = ColorHolder<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Field field = holderClass.getDeclaredField(<span class="string">"color"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		System.out.println(<span class="string">"Old color:"</span> + field.get(colorHolder));</span><br><span class="line">		field.set(colorHolder, Color.RED);</span><br><span class="line">		System.out.println(<span class="string">"New color:"</span> + field.get(colorHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Color class is enum:true</span><br><span class="line">Color values:[RED, BLACK, BLUE]</span><br><span class="line">Old color:BLACK</span><br><span class="line">New color:RED</span><br></pre></td></tr></table></figure>
<p>之前写过一篇文章《JDK中枚举的底层实现》，从枚举类的字节码翻译出类的代码逻辑，这里翻出来那个例子(手机操作系统枚举)说一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PhoneOsEnum &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 安卓</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ANDROID(<span class="number">1</span>, <span class="string">"android"</span>),</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * ios</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	IOS(<span class="number">2</span>, <span class="string">"ios"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer type;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line"></span><br><span class="line">	PhoneOsEnum(Integer type, String typeName) &#123;</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> typeName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是我们使用Java的关于枚举的语法创建出来的枚举类型，是编译前我们看到的Java类文件，实际上，编译完成之后，枚举类型会变成一个普通的Java类，它有以下特点：</p>
<ul>
<li>1、枚举类型会变成一个普通Java类，这个Java类会继承<code>java.lang.Enum</code>，并且把自身类型作为泛型参数类型，构造函数中必定包含name(字符串类型String)、ordinal(整型int)参数，因为父类<code>java.lang.Enum</code>的构造要求传入这两个参数。</li>
<li>2、所有的枚举成员属性都变成<code>static final</code>修饰的在第1步中提到的Java类的实例，属性的名称和原来枚举的名字一致，实例在静态代码块中创建。</li>
<li>3、新增了一个<code>static final</code>修饰的第1步中提到的Java类的数组实例，名称为<code>$VALUES</code>，此数组在静态代码块中创建，基于此数组还新增了一个静态方法<code>values()</code>，此方法就是直接返回数组的克隆。</li>
</ul>
<p>也就是上面提到的<code>PhoneOsEnum</code>在编译完成之后会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneOsEnumeration</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">PhoneOsEnumeration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PhoneOsEnumeration</span><span class="params">(String name, <span class="keyword">int</span> ordinal, Integer type, String typeName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, ordinal);</span><br><span class="line">		<span class="keyword">this</span>.type = type;</span><br><span class="line">		<span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> typeName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> PhoneOsEnumeration[] values() &#123;</span><br><span class="line">		<span class="keyword">return</span> $VALUES.clone();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PhoneOsEnumeration <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Enum.valueOf(PhoneOsEnumeration<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer type;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration ANDROID;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration IOS;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> PhoneOsEnumeration[] $VALUES;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		ANDROID = <span class="keyword">new</span> PhoneOsEnumeration(<span class="string">"ANDROID"</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"android"</span>);</span><br><span class="line">		IOS = <span class="keyword">new</span> PhoneOsEnumeration(<span class="string">"IOS"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">"ios"</span>);</span><br><span class="line">		$VALUES = <span class="keyword">new</span> PhoneOsEnumeration[]&#123;ANDROID, IOS&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，如果你直接编写一个Java类去继承<code>java.lang.Enum</code>会编译报错，也就是Java希望把枚举的行为和特性交由自身控制而不是开发者去控制，从编译层面控制枚举的类型安全。如果细心一点会发现，枚举中<code>valueOf(String name)</code>也是由<code>java.lang.Class</code>提供的，追溯到最里层是<code>T[] java.lang.Class#getEnumConstants()</code>方法，其实有可能在构造<code>$VALUES</code>属性的时候也是用到这个方法，这一点就没有深究下去，编译层面的东西可能会牵涉很多方面的知识，还没有到达那种水平。</p>
<h2 id="小结">小结</h2>
<p>数组和枚举在Java中的使用频率也是比较高的，特别是算法或者框架中，本文尝试从反射角度介绍这两个类型的使用方式，掌握它们对数组或者枚举的使用有很大的帮助。</p>
<p>(本文完 e-2018122-c-1-d r-2018124-c-1-d)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
        
          <div class='post-wrapper'>
            <article class="post white-box card-shadow  reveal ">
  


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  <h2 class="title">
    <a href="/2018/12/02/java-reflection-lib/">
      深入分析Java反射(一)-核心类库和方法
    </a>
  </h2>


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="http://throwable.club" rel="nofollow">
        
          <img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg">
        
        <p>Throwable</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-edit" aria-hidden="true"></i>
    <p>发布于：2018年12月2日</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/Java/Reflection/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>Java&nbsp;/&nbsp;Reflection</p>
    </a>
  </div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard" aria-hidden="true"></i>
      <p>字数：8.3k字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half" aria-hidden="true"></i>
      <p>时长：33分钟</p>
    </a>
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateUpdated" datetime="2018-12-02T12:24:09+08:00">
  <a class='notlink'>
    <i class="fas fa-save" aria-hidden="true"></i>
    <p>更新于：2018年12月2日</p>
  </a>
</div>

          
        
          
            

          
        
          
            

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <h1>深入分析Java反射(一)-核心类库和方法</h1>
<h2 id="前提">前提</h2>
<p>Java反射的API在JavaSE1.7的时候已经基本完善，<strong>但是本文编写的时候使用的是Oracle JDK11</strong>，因为JDK11对于sun包下的源码也上传了，可以直接通过IDE查看对应的源码和进行Debug。</p>
<p>本文主要介绍反射的基本概念以及核心类<code>Class</code>、<code>Constructor</code>、<code>Method</code>、<code>Field</code>、<code>Parameter</code>的常用方法。</p>
<p>本文极长，请准备一个使自己舒服的姿势阅读。</p>
<h2 id="什么是反射">什么是反射</h2>
<p>反射(Reflection)是一种可以在运行时检查和动态调用类、构造、方法、属性等等的编程语言的能力，甚至可以不需要在编译期感知类的名称、方法的名称等等。<strong><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">Oracle关于Java反射的官方教程</a>中指出反射是由应用程序使用，用于检查或修改在Java虚拟机中运行的应用程序的运行时行为，这是一个相对高级的功能，需要由掌握Java语言基础知识的开发者使用</strong>。</p>
<p>反射的优点有很多，前面提到可以检查或修改应用程序的运行时行为、抑制修饰符限制直接访问私有属性等等，这里主要列举一下它的缺点：</p>
<ul>
<li>性能开销：由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能低于非反射操作，应避免在性能敏感应用程序中频繁调用反射操作代码片段。</li>
<li>安全限制：反射需要运行时权限，不能在安全管理器(security manager)下进行反射操作。</li>
<li>代码可移植性：反射代码打破了抽象，反射的类库有可能随着平台(JDK)升级发生改变，反射代码中允许执行非反射代码的逻辑例如允许访问私有字段，这些问题都有可能影响到代码的可移植性。</li>
</ul>
<p>JDK中对和反射相关的类库集中在<code>java.lang.reflect</code>包和<code>java.lang</code>包中，<code>java.lang.reflect</code>包和<code>java.lang</code>包是开发者可以直接使用的，部分<code>java.lang.reflect</code>包中接口的实现类存放在<code>sun.reflect</code>包中，一般情况下<code>sun</code>包下的类库有可能跟随平台升级发生改变，一般尽量少用，否则有可能因为JDK升级导致原来的代码无法正常运行。还有部分反射相关的类库存放在<code>jdk.internal.reflect</code>包中，这个包是JDK内部使用的包，一般也不建议滥用其中的类库。可以理解为<code>java.lang.reflect</code>包和<code>java.lang</code>包中的类库就是面向开发者的类库。</p>
<h2 id="图解反射核心类的体系">图解反射核心类的体系</h2>
<p><code>java.lang.reflect</code>包反射核心类有核心类<code>Class</code>、<code>Constructor</code>、<code>Method</code>、<code>Field</code>、<code>Parameter</code>，它们的基础体系如下：</p>
<p><code>java.lang.Class</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-1.png" alt="j-r-1.png"></p>
<p><code>java.lang.reflect.Constructor</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-2.png" alt="j-r-2.png"></p>
<p><code>java.lang.reflect.Method</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-3.png" alt="j-r-3.png"></p>
<p><code>java.lang.reflect.Field</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-4.png" alt="j-r-4.png"></p>
<p><code>java.lang.reflect.Parameter</code>类继承体系:</p>
<p><img src="https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/reflection/j-r-5.png" alt="j-r-5.png"></p>
<p>由它们的类继承图可以看出：</p>
<ul>
<li>Class、Constructor、Method、Field、Parameter共有的父接口是AnnotatedElement。</li>
<li>Constructor、Method、Field共有的父类是AnnotatedElement、AccessibleObject和Member。</li>
<li>Constructor、Method共有的父类是AnnotatedElement、AccessibleObject、Member、GenericDeclaration和Executable。</li>
</ul>
<p>下面会先简单分析<code>AnnotatedElement</code>、<code>AccessibleObject</code>、<code>Member</code>、<code>GenericDeclaration</code>、<code>Executable</code>几个类提供的功能，然后重点分析<code>Class</code>、<code>Constructor</code>、<code>Method</code>、<code>Field</code>、<code>Parameter</code>的常用方法。</p>
<p>这里先说一个规律，在Class中，<code>getXXX()</code>方法和<code>getDeclearedXXX()</code>方法有所区别。注解类型<code>Annotation</code>的操作方法例外，因为基于注解的修饰符必定是public的：</p>
<ul>
<li>getDeclaredMethod(s)：返回类或接口声明的所有方法，包括公共、保护、默认(包)访问和私有方法，但不包括继承的方法。对于获取Method对象，<code>Method[] methods = clazz.getDeclaredMethods();</code>返回的是clazz本类所有修饰符(public、default、private、protected)的方法数组，但是不包含继承而来的方法。</li>
<li>getMethod(s):返回某个类的所有公用(public)方法包括其继承类的公用方法，当然也包括它所实现接口的方法。对于获取Method对象，<code>Method[] methods = clazz.getMethods();</code>表示返回clazz的父类、父类接口、本类、本类接口中的全部修饰符为public的方法数组。</li>
<li>getDeclaredField(s)和getField(s)、getDeclaredConstructor(s)和getConstructor(s)同上。</li>
<li>getDeclaredAnnotation(s)：返回直接存在于此元素上的所有注解，此方法将忽略继承的注解，准确来说就是忽略@Inherited注解的作用。</li>
<li>getAnnotation(s)：返回此元素上存在的所有注解，包括继承的所有注解。</li>
</ul>
<p>如果想获取一个类的所有修饰符的方法，包括所有父类中的方法，那么建议递归调用<code>getDeclaredMethods()</code>(所谓递归调用就是一直追溯目标类的父类递归调用<code>getDeclaredMethods()</code>方法直到父类为Object类型，这个思路可以参考Spring框架中的相关工具类)。获取一个类的所有Field、Constructor也可以类似操作，可以参考或者直接使用Spring中的工具类ReflectionUtils的相关方法。@Inherited元注解是一个标记注解，@Inherited阐述了某个被标注的Annotation类型是可以被继承的，详细的在分析AnnotatedElement的时候再展开。</p>
<h2 id="Type接口">Type接口</h2>
<p><code>java.lang.reflect.Type</code>接口是Java中所有类型的共同父类，这些类型包括原始类型、泛型类型、数组类型、类型变量和基本类型，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getTypeName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AnnotatedElement接口">AnnotatedElement接口</h2>
<p><code>AnnotatedElement</code>是一个接口，它定义的方法主要和注解操作相关，例如用于判断注解的存在性和获取注解等等。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean isAnnotationPresent(<code>Class&lt;? extends Annotation&gt;</code> annotationClass)</td>
<td style="text-align:center">判断指定的注解类型在当前的实例上是否存在</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T getAnnotation(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">获取当前实例上指定注解类型的注解实例，不存在时返回null</td>
</tr>
<tr>
<td style="text-align:center">Annotation[] getAnnotations()</td>
<td style="text-align:center">获取当前实例上所有注解实例，包括继承获得的注解，不存在则返回长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T getDeclaredAnnotation(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">获取当前实例上指定注解类型的注解实例，不包括继承获得的注解，不存在则返回长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T[] getDeclaredAnnotations(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">获取当前实例上所有的注解实例，不包括继承获得的注解，不存在则返回长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T[] getDeclaredAnnotationsByType(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">在不使用@Repeatable的时候，功能和getDeclaredAnnotations方法一致，如果使用了@Repeatable，则合并解析@Repeatable后的结果</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;T extends Annotation&gt;</code> T[] getAnnotationsByType(<code>Class&lt;T&gt;</code> annotationClass)</td>
<td style="text-align:center">如果指定annotationClass注解类型可继承(使用了@Inherited)，那么递归调用getDeclaredAnnotationsByType</td>
</tr>
</tbody>
</table>
<p>举个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"-----getAnnotations-----"</span>);</span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(annotation.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotation--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation declaredSupperAnnotation = clazz.getDeclaredAnnotation(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(declaredSupperAnnotation);</span><br><span class="line">        System.out.println(<span class="string">"-----getAnnotation--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation supperAnnotation = clazz.getAnnotation(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(supperAnnotation);</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotation--&gt;SubAnnotation-----"</span>);</span><br><span class="line">        SubAnnotation declaredSubAnnotation = clazz.getDeclaredAnnotation(SubAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(declaredSubAnnotation);</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotationsByType--&gt;SubAnnotation-----"</span>);</span><br><span class="line">        SubAnnotation[] declaredSubAnnotationsByType = clazz.getDeclaredAnnotationsByType(SubAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (SubAnnotation subAnnotation : declaredSubAnnotationsByType) &#123;</span><br><span class="line">            System.out.println(subAnnotation);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----getDeclaredAnnotationsByType--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation[] declaredSupperAnnotationsByType = clazz.getDeclaredAnnotationsByType(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (SupperAnnotation supperAnnotation1 : declaredSupperAnnotationsByType) &#123;</span><br><span class="line">            System.out.println(supperAnnotation1);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----getAnnotationsByType--&gt;SupperAnnotation-----"</span>);</span><br><span class="line">        SupperAnnotation[] supperAnnotationsByType = clazz.getAnnotationsByType(SupperAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (SupperAnnotation supperAnnotation2 : supperAnnotationsByType) &#123;</span><br><span class="line">            System.out.println(supperAnnotation2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SupperAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SubAnnotation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Inherited</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@interface</span> SupperAnnotation &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "SupperAnnotation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@interface</span> SubAnnotation &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "SubAnnotation"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-----getAnnotations-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SupperAnnotation(value=SupperAnnotation)</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SubAnnotation(value=SubAnnotation)</span><br><span class="line">-----getDeclaredAnnotation--&gt;SupperAnnotation-----</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">-----getAnnotation--&gt;SupperAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SupperAnnotation(value=SupperAnnotation)</span><br><span class="line">-----getDeclaredAnnotation--&gt;SubAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SubAnnotation(value=SubAnnotation)</span><br><span class="line">-----getDeclaredAnnotationsByType--&gt;SubAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SubAnnotation(value=SubAnnotation)</span><br><span class="line">-----getDeclaredAnnotationsByType--&gt;SupperAnnotation-----</span><br><span class="line">-----getAnnotationsByType--&gt;SupperAnnotation-----</span><br><span class="line"><span class="meta">@org</span>.throwable.inherited.Main$SupperAnnotation(value=SupperAnnotation)</span><br></pre></td></tr></table></figure>
<p>可以尝试注释掉@Inherited再运行一次，对比一下结果。如果注释掉@Inherited，从Sub这个类永远无法获取到它的父类Supper中的@SupperAnnotation。Class、Constructor、Method、Field、Parameter都实现了AnnotatedElement接口，所以它们都具备操作注解的功能。</p>
<h2 id="Member接口">Member接口</h2>
<p>Member接口注解提供成员属性的一些描述，主要提供的方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getDeclaringClass()</td>
<td style="text-align:center">获取声明的Class对象，也就是获取当前Member实例的来源Class对象</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">获取实例的名称，对于Constructor返回全类名，对于Method返回方法名，对于Field返回属性名</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">获取实例的修饰符</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">是否合成的</td>
</tr>
</tbody>
</table>
<p>这些方法里面除了<code>isSynthetic()</code>都比较好理解。synthetic总的来说，是由编译器引入的字段、方法、类或其他结构，主要用于JVM内部使用，为了遵循某些规范而作的一些小技巧从而绕过这些规范，有点作弊的感觉，只不过是由编译器光明正大为之，一般开发者是没有权限的(但事实上有时候还是能被利用到的)。下面这个例子参考自<a href="https://blog.csdn.net/a327369238/article/details/52608805" target="_blank" rel="noopener">synthetic Java合成类型</a>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSynthetic</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println (name + <span class="string">" : "</span> + Class.forName (name).isSynthetic ());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException exc) &#123;</span><br><span class="line">            exc.printStackTrace (System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner ();</span><br><span class="line">        checkSynthetic (<span class="string">"com.fcc.test.Main"</span>);</span><br><span class="line">        checkSynthetic (<span class="string">"com.fcc.test.Main$Inner"</span>);</span><br><span class="line">        checkSynthetic (<span class="string">"com.fcc.test.Main$1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：</span></span><br><span class="line">com.fcc.test.Main : <span class="keyword">false</span></span><br><span class="line">com.fcc.test.Main$Inner : <span class="keyword">false</span></span><br><span class="line">com.fcc.test.Main$<span class="number">1</span> : <span class="keyword">true</span></span><br><span class="line"><span class="comment">//编译结果，生成三个class文件: Main.class/Main$Inner/Main$1.class</span></span><br><span class="line"><span class="comment">// $FF: synthetic class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span>$1 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Inner这个内部类是私有的，私有内部类。拥有内部类的类编译后内外部类两者没有关系，那么私有内部类编译后默认是没有对外构造器的(如果以上代码中在Inner手动给一个public的构造器，<code>Main$1</code>是不会出现的)，但是我们又知道，外部类是可以引用内部类的，那么编译后，又是两个毫无关系的类，一个类没对外构造器，但另一个类确实是有对这个类的实例对象权限(这里就是重点，内部类哪怕没有public构造器，外部类都有实例化内部类对象的权限)的，这种情况下编译器就会生成一个合成类，也就是<code>Main$1</code>，一个什么也没有的空类(是的，什么也没有，连构造器都没有)。但到这里，仍然不明白其实现原理是怎么样的，原先以为合成类是那个内部类的副本，外部类访问内部类，在编译器认为只是和合成类交互，只是合成类只有外部类有权限访问，但是事实上，不管内部类怎么变化，合成类只是一个空的类，有点类似标记作用(真正作用却是不得而知)。</p>
<h2 id="AccessibleObject类">AccessibleObject类</h2>
<p><code>AccessibleObject</code>是一个普通Java类，实现了AnnotatedElement接口，但是对应AnnotatedElement的非默认方法的实现都是直接抛异常，也就是AnnotatedElement的接口方法必须由AccessibleObject的子类去实现，个人认为AccessibleObject应该设计为抽象类。<code>AccessibleObject</code>在JDK1.1的时候已经存在，在JDK9的时候被改进过，添加了一些新的方法，下面列举一下常用的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">设置实例是否可以访问，如果设置为true，可以抑制修饰符，直接进行访问</td>
</tr>
<tr>
<td style="text-align:center">boolean isAccessible()</td>
<td style="text-align:center">返回实例是否可以访问，实际上这个值并不准确，它只有在setAccessible被调用的时候才会更新</td>
</tr>
<tr>
<td style="text-align:center">boolean trySetAccessible()</td>
<td style="text-align:center">功能类似于setAccessible(boolean flag)，返回值决定是否抑制修饰符成功</td>
</tr>
<tr>
<td style="text-align:center">static void setAccessible(AccessibleObject[] array, boolean flag)</td>
<td style="text-align:center">setAccessible(boolean flag)的批量操作方法</td>
</tr>
</tbody>
</table>
<p>一般而言，我们需要通过<code>getModifiers()</code>方法判断修饰符是否public，如果是非public，则需要调用<code>setAccessible(true)</code>进行修饰符抑制，否则会因为无权限访问会抛出异常。</p>
<h2 id="GenericDeclaration接口">GenericDeclaration接口</h2>
<p>GenericDeclaration接口继承自AnnotatedElement，它的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericDeclaration</span> <span class="keyword">extends</span> <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TypeVariable&lt;?&gt;[] getTypeParameters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新增了一个方法<code>getTypeParameters()</code>用于返回类型变量<code>TypeVariable</code>数组，这里的<code>TypeVariable</code>是类型变量，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeVariable</span>&lt;<span class="title">D</span> <span class="keyword">extends</span> <span class="title">GenericDeclaration</span>&gt; <span class="keyword">extends</span> <span class="title">Type</span>, <span class="title">AnnotatedElement</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得泛型的类型(Type)上限数组，若未明确声明上边界则默认为Object</span></span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    <span class="comment">//获取声明该类型变量实体(即获得类、方法或构造器名)</span></span><br><span class="line">    <span class="function">D <span class="title">getGenericDeclaration</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得泛型参数的字面量名称，即K、V、E之类名称</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得泛型的注解类型(AnnotatedType)上限数组，若未明确声明上则为长度为0的空数组</span></span><br><span class="line">    AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面的文章介绍泛型的时候再展开。</p>
<h2 id="Executable类">Executable类</h2>
<p><code>Executable</code>是一个抽象类，它继承自<code>AccessibleObject</code>，实现了<code>Member</code>和<code>GenericDeclaration</code>接口。<code>Executable</code>的实现类是<code>Method</code>和<code>Constructor</code>，它的主要功能是从<code>Method</code>和<code>Constructor</code>抽取出两者可以共用的一些方法例如注解的操作，参数的操作等等，这里不详细展开。</p>
<h2 id="Modifier">Modifier</h2>
<p>Modifier主要提供一系列的静态方法，用于判断基于int类型的修饰符参数的具体类型，这个修饰符参数来源于Class、Constructor、Method、Field、Parameter的<code>getModifiers()</code>方法。下面介绍一下Modifier的主要方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">static boolean isAbstract(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括abstract修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isFinal(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括final修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isInterface(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括interface修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isNative(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括native修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isPrivate(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括private修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isProtected(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括protected修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isPublic(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括public修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isStatic(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括static修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isStrict(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括strictfp修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isSynchronized(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括synchronized修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isTransient(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括transient修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean isVolatile(int mod)</td>
<td style="text-align:center">整数modifier参数是否包括volatile修饰符</td>
</tr>
<tr>
<td style="text-align:center">static boolean toString(int mod)</td>
<td style="text-align:center">返回描述指定修饰符中的访问修饰符标志的字符串</td>
</tr>
</tbody>
</table>
<h2 id="Class类">Class类</h2>
<p><code>Class</code>实现了<code>Serializable</code>、<code>GenericDeclaration</code>、<code>Type</code>、<code>AnnotatedElement</code>接口，它提供了类型判断、类型实例化、获取方法列表、获取字段列表、获取父类泛型类型等方法。下面主要介绍一下它的主要方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> forName(String className)</td>
<td style="text-align:center">传入全类名创建Class实例</td>
</tr>
<tr>
<td style="text-align:center">T newInstance()</td>
<td style="text-align:center">通过当前的Class实例进行实例化对象，返回的就是新建的对象</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">native方法，返回当前Class的修饰符</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回类名称，虚拟机中类名表示</td>
</tr>
<tr>
<td style="text-align:center">String getCanonicalName()</td>
<td style="text-align:center">返回类名称，便于理解的类名表示</td>
</tr>
<tr>
<td style="text-align:center">String getSimpleName()</td>
<td style="text-align:center">返回类名称，源代码中给出的底层类的简单名称</td>
</tr>
<tr>
<td style="text-align:center">Package getPackage()</td>
<td style="text-align:center">返回类的包属性</td>
</tr>
<tr>
<td style="text-align:center">String getPackageName()</td>
<td style="text-align:center">返回类的包路径名称</td>
</tr>
<tr>
<td style="text-align:center">String toGenericString()</td>
<td style="text-align:center">返回描述此Class的字符串，其中包括类型参数的字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>TypeVariable&lt;Class&lt;T&gt;&gt;[]</code> getTypeParameters()</td>
<td style="text-align:center">获取类定义泛型的类型变量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getClasses()</td>
<td style="text-align:center">获取所有的修饰符为public的成员Class，包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getDeclaredClasses()</td>
<td style="text-align:center">获取本类所有修饰符的成员Class，不包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;[]</code> getConstructors()</td>
<td style="text-align:center">获取所有的修饰符为public的构造器，包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;T&gt;</code> getConstructor(<code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">获取参数类型匹配的修饰符为public的构造器，包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;[]</code> getDeclaredConstructors()</td>
<td style="text-align:center">获取本类所有修饰符的构造器，不包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;T&gt;[]</code> getDeclaredConstructor(<code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">获取本类参数类型匹配的所有修饰符的构造器，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method[] getMethods()</td>
<td style="text-align:center">获取本类所有的修饰符为public的方法列表，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method[] getDeclaredMethods()</td>
<td style="text-align:center">获取本类所有修饰符的方法列表，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method getMethod(String name, <code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">通过指定方法名和参数类型获取本类修饰符为public的方法，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Method getDeclaredMethod(String name, <code>Class&lt;?&gt;... parameterTypes</code>)</td>
<td style="text-align:center">通过指定方法名和参数类型获取本类不限修饰符的方法，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field[] getFields()</td>
<td style="text-align:center">获取本类所有的修饰符为public的属性列表，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field[] getDeclaredFields()</td>
<td style="text-align:center">获取本类所有修饰符的属性列表，不包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field getField(String name)</td>
<td style="text-align:center">通过指定属性名名获取本类修饰符为public的属性，包括父类</td>
</tr>
<tr>
<td style="text-align:center">Field getDeclaredField(String name)</td>
<td style="text-align:center">通过指定属性名获取本类不限修饰符的属性，不包括父类</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[] getInterfaces()</code></td>
<td style="text-align:center">获取类实现的所有接口的Class数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericInterfaces()</td>
<td style="text-align:center">获取类实现的所有泛型参数接口的Type数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;? super T&gt;</code> getSuperclass()</td>
<td style="text-align:center">获取当前类的父类的Class，如果当前类是Object、接口、基本数据类型(primitive)或者void，则返回null</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericSuperclass()</td>
<td style="text-align:center">获取当前类的泛型参数父类的Type，如果当前类是Object、接口、基本数据类型(primitive)或者void，则返回null</td>
</tr>
<tr>
<td style="text-align:center">native boolean isInstance(Object obj)</td>
<td style="text-align:center">判断传入的object是否当前类的实例</td>
</tr>
<tr>
<td style="text-align:center">native boolean isAssignableFrom(<code>Class&lt;?&gt; cls</code>)</td>
<td style="text-align:center">判断传入的Class对象是否和当前类相同，或者是否当前类的超类或超接口</td>
</tr>
<tr>
<td style="text-align:center">native boolean isInterface()</td>
<td style="text-align:center">判断当前类是否接口</td>
</tr>
<tr>
<td style="text-align:center">native boolean isArray()</td>
<td style="text-align:center">判断当前类是否数组</td>
</tr>
<tr>
<td style="text-align:center">native boolean isPrimitive()</td>
<td style="text-align:center">判断当前类是否基本数据类型</td>
</tr>
<tr>
<td style="text-align:center">boolean isAnnotation()</td>
<td style="text-align:center">判断当前类是否注解类型</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">判断当前类是否复合</td>
</tr>
<tr>
<td style="text-align:center">native <code>Class&lt;?&gt;</code> getComponentType()</td>
<td style="text-align:center">如果当前类是数组，返回数组元素的类型</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getEnclosingClass()</td>
<td style="text-align:center">返回一个类，当前类(一般是成员类)在这个类(封闭类，相对于内部类的外部类或者说外面一层)中定义</td>
</tr>
<tr>
<td style="text-align:center"><code>Constructor&lt;?&gt;</code> getEnclosingConstructor()</td>
<td style="text-align:center">返回构造器，当前类是在这个构造函数中定义</td>
</tr>
<tr>
<td style="text-align:center">Method getEnclosingMethod()</td>
<td style="text-align:center">返回方法，当前类是在这个方法中定义</td>
</tr>
<tr>
<td style="text-align:center">Module getModule()</td>
<td style="text-align:center">返回模块，JDK9新增方法</td>
</tr>
</tbody>
</table>
<p><code>getName()</code>、<code>getCanonicalName()</code>和<code>getSimpleName()</code>都是用于获取类的名称，但是有所区别，下面举个列子说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Supper&lt;String, List&lt;Integer&gt;&gt; supper = <span class="keyword">new</span> Supper&lt;&gt;();</span><br><span class="line">		Class&lt;?&gt; clazz = supper.getClass();</span><br><span class="line">		System.out.println(<span class="string">"name-&gt;"</span> + clazz.getName());</span><br><span class="line">		System.out.println(<span class="string">"canonicalName-&gt;"</span> + clazz.getCanonicalName());</span><br><span class="line">		System.out.println(<span class="string">"simpleName-&gt;"</span> + clazz.getSimpleName());</span><br><span class="line">		System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">		String[][] strings = <span class="keyword">new</span> String[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">		System.out.println(<span class="string">"name-&gt;"</span> + strings.getClass().getName());</span><br><span class="line">		System.out.println(<span class="string">"canonicalName-&gt;"</span> + strings.getClass().getCanonicalName());</span><br><span class="line">		System.out.println(<span class="string">"simpleName-&gt;"</span> + strings.getClass().getSimpleName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> K key;</span><br><span class="line">		<span class="keyword">private</span> V value;</span><br><span class="line">        <span class="comment">//省略setter和getter方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name-&gt;club.throwable.reflect.Main$Supper</span><br><span class="line">canonicalName-&gt;club.throwable.reflect.Main.Supper</span><br><span class="line">simpleName-&gt;Supper</span><br><span class="line">======================================</span><br><span class="line">name-&gt;[[Ljava.lang.String;</span><br><span class="line">canonicalName-&gt;java.lang.String[][]</span><br><span class="line">simpleName-&gt;String[][]</span><br></pre></td></tr></table></figure>
<p>简单理解为：</p>
<ul>
<li><code>getName()</code>：用于获取类在Java虚拟机中的类名表示。</li>
<li><code>getCanonicalName()</code>：用于获取全类名，包括包路径，包路径以点号分隔。</li>
<li><code>getSimpleName()</code>：用于获取类名，不包括包路径。</li>
</ul>
<p>下面再举一个例子通过类名进行实例化对象和操作，从例子可以看到，实例化对象可以不依赖<code>new</code>关键字，这就是反射的强大之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">"club.throwable.reflect.Main3$Supper"</span>);</span><br><span class="line">		Supper supper = (Supper) clazz.newInstance();</span><br><span class="line">		System.out.println(supper.sayHello(<span class="string">"throwable"</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> String.format(<span class="string">"%s say hello!"</span>, name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意一点，<code>Class.forName</code>方法只能使用在修饰符为public的类上，如果使用在其他修饰符类上会抛出异常(IllegalAccessException)，那么，如果上面的Supper类的修饰符修改为private，怎么样才能正常实例化它？这个问题将会在下面分析Constructor的时候得到解决。另外，这里的<code>Class.forName</code>方法不是获取Class实例的唯一方式，总结有以下三种方式：</p>
<ul>
<li>1、使用类的字面量&quot;类名.class&quot;。类字面常量使得创建Class对象的引用时不会自动地初始化该对象，而是按照之前提到的加载，链接，初始化三个步骤，这三个步骤是个懒加载的过程，不使用的时候就不加载。</li>
<li>2、使用<code>Class.forName(全类名);</code>方法。</li>
<li>3、使用实例的<code>getClass()</code>方法。<code>getClass()</code>是所有的对象都能够使用的方法，因为getClass()方法是Object类的方法，所有的类都继承了Object，因此所有类的对象也都具有getClass()方法。</li>
</ul>
<p>一般来说，使用&quot;类名.class&quot;，这样做即简单安全又比较高效。因为在编译时就会受到检查，因此不需要置于try语句块中，并且它根除了对forName()方法的调用(forName()方法是一个耗时比较多的方法)，所以相对比较高效。</p>
<p>最后，分析一下这几个比较难懂的方法<code>getEnclosingClass()</code>、<code>getEnclosingConstructor()</code>、<code>getEnclosingMethod()</code>：</p>
<ul>
<li><code>getEnclosingClass()</code>：返回一个类，当前类(一般是成员类)在这个类(<strong>一般叫封闭类，相对于内部类的外部类或者说外面一层</strong>)中定义。</li>
<li><code>getEnclosingConstructor()</code>：返回构造器，当前类是在这个构造函数中定义。</li>
<li><code>getEnclosingClass()</code>：返回方法，当前类是在这个方法中定义。</li>
</ul>
<p><strong>我们在新建一个类的时候，这个类可以使另一个类中定义的成员类、构造方法中定义的内部类、方法中定义的内部类。可以通过当前的类反向获取定义当前的类的类、构造或者方法，这三种情况对应上面三个方法</strong>。举个例子：</p>
<p><code>getEnclosingClass()</code>方法使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Outter.Inner&gt; clazz = Outter.Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class&lt;?&gt; enclosingClass = clazz.getEnclosingClass();</span><br><span class="line">        System.out.println(enclosingClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Inner类是Outter类的成员类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.throwable.inherited.Main5$Outter</span><br></pre></td></tr></table></figure>
<p>在这里，Inner就是当前定义的类，它是Outter的静态成员类，或者说Outter是Inner的封闭类，通过Inner的Class的<code>getEnclosingClass()</code>方法获取到的就是Outter的Class实例。</p>
<p><code>getEnclosingConstructor()</code>方法使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Outter的无参数构造器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//构造中定义的内部类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;Inner&gt; innerClass = Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Class&lt;?&gt; enclosingClass = innerClass.getEnclosingClass();</span><br><span class="line">            System.out.println(enclosingClass.getName());</span><br><span class="line">            Constructor&lt;?&gt; enclosingConstructor = innerClass.getEnclosingConstructor();</span><br><span class="line">            System.out.println(enclosingConstructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.throwable.inherited.Main6$Outter</span><br><span class="line">org.throwable.inherited.Main6$Outter</span><br></pre></td></tr></table></figure>
<p>在这里，Inner是Outter的无参数构造里面定义的构造内部类，它也只能在Outter的无参数构造里面使用，通过Inner的Class的<code>getEnclosingConstructor()</code>方法获取到的就是Outter的无参数构造。</p>
<p><code>getEnclosingMethod()</code>方法使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main7</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        outter.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//方法print中定义的内部类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;Inner&gt; innerClass = Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            Class&lt;?&gt; enclosingClass = innerClass.getEnclosingClass();</span><br><span class="line">            System.out.println(enclosingClass.getName());</span><br><span class="line">            Method enclosingMethod = innerClass.getEnclosingMethod();</span><br><span class="line">            System.out.println(enclosingMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.throwable.inherited.Main7$Outter</span><br><span class="line">print</span><br></pre></td></tr></table></figure>
<p>在这里，Inner是Outter的print方法里面定义的方法内部类，它也只能在Outter的print方法里面使用，通过Inner的Class的<code>getEnclosingMethod()</code>方法获取到的就是Outter的print方法。这种方式可能不常用，但是可以在某版本的spring-jdbc的<code>JdbcTemplate</code>的源码中看到类似的类定义逻辑。</p>
<p>前面介绍过<code>getXXX()</code>方法和<code>getDeclearedXXX()</code>方法有所区别，这里做个对比表格：</p>
<p><strong>Class中获取Field列表的方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class中的API</th>
<th style="text-align:center">获取所有的Field</th>
<th style="text-align:center">包括继承的Field</th>
<th style="text-align:center">包括私有的Field</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDeclaredField()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getField()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">getDeclaredFields()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getFields()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p><strong>Class中获取Method列表的方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class中的API</th>
<th style="text-align:center">获取所有的Method</th>
<th style="text-align:center">包括继承的Method</th>
<th style="text-align:center">包括私有的Method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDeclaredMethod()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getMethod()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">getDeclaredMethods()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getMethods()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<p><strong>Class中获取Constructor列表的方法：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">Class中的API</th>
<th style="text-align:center">获取所有的Constructor</th>
<th style="text-align:center">包括私有的Constructor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getDeclaredConstructor()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getConstructor()</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">getDeclaredConstructors()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">getConstructors()</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<h2 id="Constructor类">Constructor类</h2>
<p><code>Constructor</code>用于描述一个类的构造函数。它除了能获取到构造的注解信息、参数的注解信息、参数的信息之外，还有一个很重要的作用是可以抑制修饰符进行实例化，而Class的实例化方法<code>newInstance</code>只能实例化修饰符为public的类。Constructor的主要方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;T&gt;</code> getDeclaringClass()</td>
<td style="text-align:center">获取当前构造的定义类</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">获取当前构造的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">获取当前构造的修饰符</td>
</tr>
<tr>
<td style="text-align:center">String toGenericString()</td>
<td style="text-align:center">返回描述此构造的字符串，其中包括类型参数的字面量</td>
</tr>
<tr>
<td style="text-align:center"><code>TypeVariable&lt;Constructor&lt;T&gt;&gt;[]</code> getTypeParameters()</td>
<td style="text-align:center">获取类定义泛型参数的类型变量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getExceptionTypes()</td>
<td style="text-align:center">获取当前构造异常类型数组，如果不存在则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">获取当前构造异常类型数组的泛型类型，如果不存在则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">获取当前构造参数的泛型类型，如果不存在则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Annotation[][] getParameterAnnotations()</td>
<td style="text-align:center">获取当前构造参数的注解数组，这里是二维数组的原因是一个参数可以使用多个注解</td>
</tr>
<tr>
<td style="text-align:center">int getParameterCount()</td>
<td style="text-align:center">获取当前构造参数的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getParameterTypes()</td>
<td style="text-align:center">获取当前构造参数的Class数组</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">当前构造是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isVarArgs()</td>
<td style="text-align:center">当前构造是否使用不定参数</td>
</tr>
<tr>
<td style="text-align:center">T newInstance(Object…initargs)</td>
<td style="text-align:center">使用此构造对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例</td>
</tr>
<tr>
<td style="text-align:center">Parameter[] getParameters()</td>
<td style="text-align:center">返回此构造对象的参数Parameter数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">抑制构造访问修饰符的权限判断</td>
</tr>
</tbody>
</table>
<p>下面我们举个例子说明使用构造实例化对象可以抑制修饰符访问权限控制的问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Constructor&lt;Supper&gt; constructor = supperClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(Boolean.TRUE);</span><br><span class="line">        Supper supper = constructor.newInstance();</span><br><span class="line">        supper.sayHello(<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<p>这就是为什么一些IOC容器的实现框架中实例化类的时候优先依赖于无参数构造的原因，如果使用<code>Class#newInstance</code>方法，上面的代码调用逻辑会抛异常。</p>
<h2 id="Method类">Method类</h2>
<p>Method用于描述一个类的方法。它除了能获取方法的注解信息，还能获取方法参数、返回值的注解信息和其他信息。Method常用的方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getDeclaringClass()</td>
<td style="text-align:center">获取方法对应的Class</td>
</tr>
<tr>
<td style="text-align:center">Object getDefaultValue()</td>
<td style="text-align:center">获取方法上的注解成员的默认值</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getExceptionTypes()</td>
<td style="text-align:center">获取方法上的异常类型数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericExceptionTypes()</td>
<td style="text-align:center">获取方法上的异常泛型类型Type数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Parameter[] getParameters()</td>
<td style="text-align:center">返回方法的参数Parameter数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">int getParameterCount()</td>
<td style="text-align:center">返回方法的参数的数量</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;[]</code> getParameterTypes()</td>
<td style="text-align:center">返回方法的参数的类型Class数组，如果没有则返回一个长度为0的数组</td>
</tr>
<tr>
<td style="text-align:center">Annotation[][] getParameterAnnotations()</td>
<td style="text-align:center">返回方法的注解Annotation数组，这里使用二维数组的原因是一个参数可以使用多个注解</td>
</tr>
<tr>
<td style="text-align:center"><code>TypeVariable&lt;Method&gt;[]</code> getTypeParameters()</td>
<td style="text-align:center">返回方法的泛型参数的类型变量</td>
</tr>
<tr>
<td style="text-align:center">Type[] getGenericParameterTypes()</td>
<td style="text-align:center">返回方法参数的泛型类型Type数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getReturnType()</td>
<td style="text-align:center">返回方法的返回值的类型Class</td>
</tr>
<tr>
<td style="text-align:center">Type getGenericReturnType()</td>
<td style="text-align:center">返回方法的返回值的泛型类型Type</td>
</tr>
<tr>
<td style="text-align:center">AnnotatedType getAnnotatedReturnType()</td>
<td style="text-align:center">获取方法返回值的注解类型实例AnnotatedType</td>
</tr>
<tr>
<td style="text-align:center">boolean isBridge()</td>
<td style="text-align:center">是否桥方法</td>
</tr>
<tr>
<td style="text-align:center">boolean isDefault()</td>
<td style="text-align:center">是否接口的默认方法</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isVarArgs()</td>
<td style="text-align:center">是否使用了不定参数</td>
</tr>
<tr>
<td style="text-align:center">String toGenericString()</td>
<td style="text-align:center">返回方法带有泛型字面量的描述字符串</td>
</tr>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回方法的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">返回方法的修饰符</td>
</tr>
<tr>
<td style="text-align:center">Object invoke(Object obj, Object… args)</td>
<td style="text-align:center">对带有指定参数的指定对象调用由此方法对象表示的底层方法</td>
</tr>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">抑制方法访问修饰符的权限判断</td>
</tr>
</tbody>
</table>
<p>关注其中的<code>invoke(Object obj, Object... args)</code>方法，第一个是要调用这个方法的对象，剩下的方法的参数，返回值就是该方法执行的返回值。如果方法的修饰符不是public，在调用<code>invoke</code>方法前需要调用<code>setAccessible(boolean flag)</code>抑制方法访问修饰符的权限判断，否则会抛出异常。举个例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main10</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Supper supper = supperClass.newInstance();</span><br><span class="line">        Method sayHello = supperClass.getDeclaredMethod(<span class="string">"sayHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHello.setAccessible(Boolean.TRUE);</span><br><span class="line">        sayHello.invoke(supper,<span class="string">"throwable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throwable say hello!</span><br></pre></td></tr></table></figure>
<h2 id="Field类">Field类</h2>
<p><code>Field</code>类用来描述一个类里面的属性或者叫成员变量，通过Field可以获取属性的注解信息、泛型信息，获取和设置属性的值等等。Field的主要方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回该属性的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">返回该属性的修饰符</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getType()</td>
<td style="text-align:center">返回该属性的类型Class</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getParameterizedType()</td>
<td style="text-align:center">返回该属性的泛型类型Type</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">该属性是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isEnumConstant()</td>
<td style="text-align:center">该属性是否枚举类型的元素</td>
</tr>
<tr>
<td style="text-align:center">Object get(Object obj)</td>
<td style="text-align:center">通过对象实例获取该属性的值</td>
</tr>
<tr>
<td style="text-align:center">void set(Object obj,Object value)</td>
<td style="text-align:center">通过对象实例设置该属性的值</td>
</tr>
<tr>
<td style="text-align:center">void setAccessible(boolean flag)</td>
<td style="text-align:center">抑制属性访问修饰符的权限判断</td>
</tr>
</tbody>
</table>
<p>这里忽略了注解以及Field实现了<code>FieldAccessor</code>接口中的<code>getBoolean</code>、<code>setBoolean</code>等方法。下面举个例子说明一下Field的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main12</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Supper supper = supperClass.newInstance();</span><br><span class="line">        Method sayHello = supperClass.getDeclaredMethod(<span class="string">"sayHello"</span>);</span><br><span class="line">        sayHello.setAccessible(Boolean.TRUE);</span><br><span class="line">        Field name = supperClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        name.setAccessible(Boolean.TRUE);</span><br><span class="line">        name.set(supper,<span class="string">"throwable"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Field get--&gt;"</span> + name.get(supper));</span><br><span class="line">        sayHello.invoke(supper);</span><br><span class="line">        name.set(supper, <span class="string">"throwable-10086"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Field get--&gt;"</span> + name.get(supper));</span><br><span class="line">        sayHello.invoke(supper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field get--&gt;throwable</span><br><span class="line">throwable say hello!</span><br><span class="line">Field get--&gt;throwable-<span class="number">10086</span></span><br><span class="line">throwable-<span class="number">10086</span> say hello!</span><br></pre></td></tr></table></figure>
<h2 id="Parameter类">Parameter类</h2>
<p><code>Parameter</code>用于描述<code>Method</code>或者<code>Constructor</code>的参数，主要是用于获取参数的名称。因为在Java中没有形式参数的概念，也就是参数都是没有名称的。Jdk1.8新增了Parameter用来填补这个问题，使用javac编译器的时候加上<code>-parameters</code>参数的话，会在生成的.class文件中额外存储参数的元信息，这样会导致.class文件的大小增加。当你输入<code>javac -help</code>的时候，你会看到-parameters这个选项。获取Parameter的方法是Method或者Constructor的父类Executable的getParamaters方法。一般而言，Parameter是用于获取参数名称的后备方案，因为Jdk1.8之前没有这个类，并且即使使用了Jdk1.8如果javac编译器的时候没有加上<code>-parameters</code>参数的话，通过Parameter获取到的参数名称将会是&quot;arg0&quot;、“arg1”…&quot;argn&quot;类似的没有意义的参数名称。一般框架中使用其他方法解析方法或者构造器的参数名称，参考Spring的源码，具体是<code>LocalVariableTableParameterNameDiscoverer</code>，是使用ASM去解析和读取类文件字节码，提取参数名称。Parameter的主要方法如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">String getName()</td>
<td style="text-align:center">返回该参数的名称</td>
</tr>
<tr>
<td style="text-align:center">int getModifiers()</td>
<td style="text-align:center">返回该参数的修饰符</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getType()</td>
<td style="text-align:center">返回该参数的类型Class</td>
</tr>
<tr>
<td style="text-align:center"><code>Class&lt;?&gt;</code> getParameterizedType()</td>
<td style="text-align:center">返回该参数的泛型类型Type</td>
</tr>
<tr>
<td style="text-align:center">boolean isNamePresent()</td>
<td style="text-align:center">该参数的名称是否保存在class文件中，需要编译时加参数-parameters</td>
</tr>
<tr>
<td style="text-align:center">boolean isImplicit()</td>
<td style="text-align:center">该参数是否隐式声明</td>
</tr>
<tr>
<td style="text-align:center">boolean isSynthetic()</td>
<td style="text-align:center">该参数是否复合的</td>
</tr>
<tr>
<td style="text-align:center">boolean isVarArgs()</td>
<td style="text-align:center">该参数是否不定参数</td>
</tr>
</tbody>
</table>
<p>这里举个例子，编译时候添加参数<code>-parameters</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main11</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;Supper&gt; supperClass = Supper<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method sayHello = supperClass.getDeclaredMethod(<span class="string">"sayHello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        sayHello.setAccessible(Boolean.TRUE);</span><br><span class="line">        Parameter[] parameters = sayHello.getParameters();</span><br><span class="line">        <span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">            System.out.println(<span class="string">"isNamePresent-&gt;"</span> + parameter.isNamePresent());</span><br><span class="line">            System.out.println(<span class="string">"isImplicit-&gt;"</span> + parameter.isImplicit());</span><br><span class="line">            System.out.println(<span class="string">"getName-&gt;"</span> + parameter.getName());</span><br><span class="line">            System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Supper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s say hello!"</span>, name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isNamePresent-&gt;<span class="keyword">true</span></span><br><span class="line">isImplicit-&gt;<span class="keyword">false</span></span><br><span class="line">getName-&gt;name</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure>
<p>如果不设置编译参数<code>-parameters</code>，会输出下面的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isNamePresent-&gt;<span class="keyword">false</span></span><br><span class="line">isImplicit-&gt;<span class="keyword">false</span></span><br><span class="line">getName-&gt;arg0</span><br><span class="line">=====================</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>这篇文章开篇对反射的基本进行介绍，后面花大量篇幅列举了相关类库的API和API使用，掌握这些类库，才能轻松地进行反射编程。</p>
<p>(本文完 e-2018122)</p>

      
    </div>
    <!-- 
      <div class="full-width auto-padding tags">
        
          <a href="/blog/tags/Java/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Java</a>
        
          <a href="/blog/tags/Reflection/" rel="nofollow"><i class="fas fa-tag fa-fw"></i> Reflection</a>
        
      </div>
     -->
  </section>
</article>

          </div>
        
      
    
  </section>
  
    
      <br>
      <div class="prev-next">
        
          <a class="prev" rel="prev" href="/page/8/">
            <section class="post prev white-box card-shadow " >
              <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
            </section>
          </a>
        
        <p class="current">
          9 / 11
        </p>
        
          <a class="next" rel="next" href="/page/10/">
            <section class="post next white-box card-shadow ">
              &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
            </section>
          </a>
        
      </div>
    
    <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
    
    

  


</div>
<aside class='l_side'>
  
    
    
      
        
          <section class='widget card-shadow  blogger'>
  <div class='content'>
    
      <div class='avatar'>
        <img class='avatar' src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/mine/doge_avatar.jpg'/>
      </div>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/atom.xml"
              class="social fas fa-rss fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:739805340@qq.com"
              class="social fas fa-envelope fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/zjcscut"
              class="social fab fa-github fa-lg flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
          
  <section class='widget card-shadow  category'>
    <header>
  <div>
    
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i><span class='name'>文章分类</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <ul class="entry navigation">
        
          <li><a class="flat-box"
            title="/blog/categories/Framework/" href="/blog/categories/Framework/"
            id="blogcategoriesFramework"
            ><div class='name'>Framework</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Archunit/" href="/blog/categories/Framework/Archunit/"
            id="blogcategoriesFrameworkArchunit"
            ><div class='name'>Archunit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Cglib/" href="/blog/categories/Framework/Cglib/"
            id="blogcategoriesFrameworkCglib"
            ><div class='name'>Cglib</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Hystrix/" href="/blog/categories/Framework/Hystrix/"
            id="blogcategoriesFrameworkHystrix"
            ><div class='name'>Hystrix</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Micrometer/" href="/blog/categories/Framework/Micrometer/"
            id="blogcategoriesFrameworkMicrometer"
            ><div class='name'>Micrometer</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Mybatis/" href="/blog/categories/Framework/Mybatis/"
            id="blogcategoriesFrameworkMybatis"
            ><div class='name'>Mybatis</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Framework/Zuul/" href="/blog/categories/Framework/Zuul/"
            id="blogcategoriesFrameworkZuul"
            ><div class='name'>Zuul</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Go/" href="/blog/categories/Go/"
            id="blogcategoriesGo"
            ><div class='name'>Go</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Go/Golang/" href="/blog/categories/Go/Golang/"
            id="blogcategoriesGoGolang"
            ><div class='name'>Golang</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/In-Action/" href="/blog/categories/In-Action/"
            id="blogcategoriesIn-Action"
            ><div class='name'>In Action</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/In-Action/Distributed-Transaction/" href="/blog/categories/In-Action/Distributed-Transaction/"
            id="blogcategoriesIn-ActionDistributed-Transaction"
            ><div class='name'>Distributed Transaction</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Java/" href="/blog/categories/Java/"
            id="blogcategoriesJava"
            ><div class='name'>Java</div><div class='badge'>(37)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Algorithm/" href="/blog/categories/Java/Algorithm/"
            id="blogcategoriesJavaAlgorithm"
            ><div class='name'>Algorithm</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Annotation/" href="/blog/categories/Java/Annotation/"
            id="blogcategoriesJavaAnnotation"
            ><div class='name'>Annotation</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Concurrency/" href="/blog/categories/Java/Concurrency/"
            id="blogcategoriesJavaConcurrency"
            ><div class='name'>Concurrency</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Design-Pattern/" href="/blog/categories/Java/Design-Pattern/"
            id="blogcategoriesJavaDesign-Pattern"
            ><div class='name'>Design Pattern</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Enum/" href="/blog/categories/Java/Enum/"
            id="blogcategoriesJavaEnum"
            ><div class='name'>Enum</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Functional-Programming/" href="/blog/categories/Java/Functional-Programming/"
            id="blogcategoriesJavaFunctional-Programming"
            ><div class='name'>Functional Programming</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Instrument/" href="/blog/categories/Java/Instrument/"
            id="blogcategoriesJavaInstrument"
            ><div class='name'>Instrument</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Introspector/" href="/blog/categories/Java/Introspector/"
            id="blogcategoriesJavaIntrospector"
            ><div class='name'>Introspector</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/JVM/" href="/blog/categories/Java/JVM/"
            id="blogcategoriesJavaJVM"
            ><div class='name'>JVM</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Lambda/" href="/blog/categories/Java/Lambda/"
            id="blogcategoriesJavaLambda"
            ><div class='name'>Lambda</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Netty/" href="/blog/categories/Java/Netty/"
            id="blogcategoriesJavaNetty"
            ><div class='name'>Netty</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Java/Reflection/" href="/blog/categories/Java/Reflection/"
            id="blogcategoriesJavaReflection"
            ><div class='name'>Reflection</div><div class='badge'>(8)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Life/" href="/blog/categories/Life/"
            id="blogcategoriesLife"
            ><div class='name'>Life</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Middleware/" href="/blog/categories/Middleware/"
            id="blogcategoriesMiddleware"
            ><div class='name'>Middleware</div><div class='badge'>(34)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Quartz/" href="/blog/categories/Middleware/Quartz/"
            id="blogcategoriesMiddlewareQuartz"
            ><div class='name'>Quartz</div><div class='badge'>(14)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/RabbitMQ/" href="/blog/categories/Middleware/RabbitMQ/"
            id="blogcategoriesMiddlewareRabbitMQ"
            ><div class='name'>RabbitMQ</div><div class='badge'>(9)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Redis/" href="/blog/categories/Middleware/Redis/"
            id="blogcategoriesMiddlewareRedis"
            ><div class='name'>Redis</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Middleware/Zookeeper/" href="/blog/categories/Middleware/Zookeeper/"
            id="blogcategoriesMiddlewareZookeeper"
            ><div class='name'>Zookeeper</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/MySQL/" href="/blog/categories/MySQL/"
            id="blogcategoriesMySQL"
            ><div class='name'>MySQL</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Netty/" href="/blog/categories/Netty/"
            id="blogcategoriesNetty"
            ><div class='name'>Netty</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Netty/Java/" href="/blog/categories/Netty/Java/"
            id="blogcategoriesNettyJava"
            ><div class='name'>Java</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SOFAStack/" href="/blog/categories/SOFAStack/"
            id="blogcategoriesSOFAStack"
            ><div class='name'>SOFAStack</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SOFAStack/Nacos/" href="/blog/categories/SOFAStack/Nacos/"
            id="blogcategoriesSOFAStackNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring-Cloud/" href="/blog/categories/Spring-Cloud/"
            id="blogcategoriesSpring-Cloud"
            ><div class='name'>Spring Cloud</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/" href="/blog/categories/Spring-Cloud/Spring-Cloud-Gateway/"
            id="blogcategoriesSpring-CloudSpring-Cloud-Gateway"
            ><div class='name'>Spring Cloud Gateway</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/Spring/" href="/blog/categories/Spring/"
            id="blogcategoriesSpring"
            ><div class='name'>Spring</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/Prometheus/" href="/blog/categories/Spring/Prometheus/"
            id="blogcategoriesSpringPrometheus"
            ><div class='name'>Prometheus</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringBoot/" href="/blog/categories/Spring/SpringBoot/"
            id="blogcategoriesSpringSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/Spring/SpringMVC/" href="/blog/categories/Spring/SpringMVC/"
            id="blogcategoriesSpringSpringMVC"
            ><div class='name'>SpringMVC</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/SpringBoot/" href="/blog/categories/SpringBoot/"
            id="blogcategoriesSpringBoot"
            ><div class='name'>SpringBoot</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child"
            title="/blog/categories/SpringBoot/Nacos/" href="/blog/categories/SpringBoot/Nacos/"
            id="blogcategoriesSpringBootNacos"
            ><div class='name'>Nacos</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box"
            title="/blog/categories/hexo/" href="/blog/categories/hexo/"
            id="blogcategorieshexo"
            ><div class='name'>hexo</div><div class='badge'>(1)</div></a></li>
        
      </ul>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
        
          
  <section class='widget card-shadow  tagcloud'>
    <header>
  <div>
    
      <i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class='name'>热门标签</span>
    

  </div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
      target="_self"
    
    href="/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content'>
      <a href="/blog/tags/AQS/" style="font-size: 14px; color: #999">AQS</a> <a href="/blog/tags/Algorithm/" style="font-size: 14px; color: #999">Algorithm</a> <a href="/blog/tags/Annotation/" style="font-size: 14px; color: #999">Annotation</a> <a href="/blog/tags/Archunit/" style="font-size: 14px; color: #999">Archunit</a> <a href="/blog/tags/Cglib/" style="font-size: 14.83px; color: #939393">Cglib</a> <a href="/blog/tags/Concurrency/" style="font-size: 14.83px; color: #939393">Concurrency</a> <a href="/blog/tags/Design-Pattern/" style="font-size: 14px; color: #999">Design Pattern</a> <a href="/blog/tags/Distributed-Transaction/" style="font-size: 14.83px; color: #939393">Distributed Transaction</a> <a href="/blog/tags/Enum/" style="font-size: 14px; color: #999">Enum</a> <a href="/blog/tags/ExecutorService/" style="font-size: 14px; color: #999">ExecutorService</a> <a href="/blog/tags/Framework/" style="font-size: 17.33px; color: #828282">Framework</a> <a href="/blog/tags/Go/" style="font-size: 14px; color: #999">Go</a> <a href="/blog/tags/Golang/" style="font-size: 14px; color: #999">Golang</a> <a href="/blog/tags/Hystrix/" style="font-size: 14px; color: #999">Hystrix</a> <a href="/blog/tags/In-Action/" style="font-size: 16.5px; color: #888">In Action</a> <a href="/blog/tags/Instrument/" style="font-size: 14px; color: #999">Instrument</a> <a href="/blog/tags/Introspector/" style="font-size: 14px; color: #999">Introspector</a> <a href="/blog/tags/JSR-310/" style="font-size: 17.33px; color: #828282">JSR-310</a> <a href="/blog/tags/JVM/" style="font-size: 14px; color: #999">JVM</a> <a href="/blog/tags/Java/" style="font-size: 24px; color: #555">Java</a> <a href="/blog/tags/Lambda/" style="font-size: 14px; color: #999">Lambda</a> <a href="/blog/tags/Life/" style="font-size: 14px; color: #999">Life</a> <a href="/blog/tags/ListenableFuture/" style="font-size: 14px; color: #999">ListenableFuture</a> <a href="/blog/tags/Micrometer/" style="font-size: 14.83px; color: #939393">Micrometer</a> <a href="/blog/tags/Middleware/" style="font-size: 23.17px; color: #5b5b5b">Middleware</a> <a href="/blog/tags/MySQL/" style="font-size: 14px; color: #999">MySQL</a> <a href="/blog/tags/Mybatis/" style="font-size: 14px; color: #999">Mybatis</a> <a href="/blog/tags/Nacos/" style="font-size: 14.83px; color: #939393">Nacos</a> <a href="/blog/tags/Netty/" style="font-size: 18.17px; color: #7d7d7d">Netty</a> <a href="/blog/tags/Object/" style="font-size: 14px; color: #999">Object</a> <a href="/blog/tags/Optional/" style="font-size: 14px; color: #999">Optional</a> <a href="/blog/tags/Quartz/" style="font-size: 22.33px; color: #606060">Quartz</a> <a href="/blog/tags/RabbitMQ/" style="font-size: 20.67px; color: #6c6c6c">RabbitMQ</a> <a href="/blog/tags/Redis/" style="font-size: 21.5px; color: #666">Redis</a> <a href="/blog/tags/Reference/" style="font-size: 14px; color: #999">Reference</a> <a href="/blog/tags/Reflection/" style="font-size: 19.83px; color: #717171">Reflection</a> <a href="/blog/tags/SOFAStack/" style="font-size: 14px; color: #999">SOFAStack</a> <a href="/blog/tags/Security/" style="font-size: 14px; color: #999">Security</a> <a href="/blog/tags/Spring/" style="font-size: 17.33px; color: #828282">Spring</a> <a href="/blog/tags/Spring-Cloud/" style="font-size: 18.17px; color: #7d7d7d">Spring Cloud</a> <a href="/blog/tags/Spring-Cloud-Gateway/" style="font-size: 19px; color: #777">Spring Cloud Gateway</a> <a href="/blog/tags/SpringBoot/" style="font-size: 15.67px; color: #8e8e8e">SpringBoot</a> <a href="/blog/tags/SpringCloud/" style="font-size: 14px; color: #999">SpringCloud</a> <a href="/blog/tags/SpringMVC/" style="font-size: 14.83px; color: #939393">SpringMVC</a> <a href="/blog/tags/Thread/" style="font-size: 14.83px; color: #939393">Thread</a> <a href="/blog/tags/ThreadLocal/" style="font-size: 14px; color: #999">ThreadLocal</a> <a href="/blog/tags/ThreadPoolExecutor/" style="font-size: 14px; color: #999">ThreadPoolExecutor</a> <a href="/blog/tags/Zookeeper/" style="font-size: 14px; color: #999">Zookeeper</a> <a href="/blog/tags/Zuul/" style="font-size: 14px; color: #999">Zuul</a> <a href="/blog/tags/hexo/" style="font-size: 14px; color: #999">hexo</a> <a href="/blog/tags/hexo-theme/" style="font-size: 14px; color: #999">hexo theme</a>
    </div>
  </section>


        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
  
</aside>

<footer class="clearfix ">
  <br><br>
  
    <div class="social-wrapper">
      
        
          <a href="/atom.xml"
            class="social fas fa-rss fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="mailto:739805340@qq.com"
            class="social fas fa-envelope fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
        
          <a href="https://github.com/zjcscut"
            class="social fab fa-github fa-lg flat-btn"
            target="_blank"
            rel="external nofollow noopener noreferrer">
          </a>
        
      
    </div>
  
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/volantis/" target="_blank" class="codename">Volantis</a>
    作为主题
    
      ，
      总访问量为
      <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
      次
    
    。
  </div>
  
    <div class='copyright'>
    <p><a href="http://throwable.club">Copyright © 2017-2020 Throwable</a></p>

    </div>
  
</footer>
<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>

<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>


  <script src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>














  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/search.js"></script>



  
    
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@20.2.30/js/commentTyping.js"></script>

  





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





<script src='https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/static/js/roll.js'></script>


  <script>setLoadingBarProgress(100);</script>
</body>
</html>
